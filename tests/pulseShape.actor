actor pulseShape() 
// Inputs:
int symb,             // I-Q symbols from QPSK modulator 
uint len       // Payload length
// Outputs:
==> 
bool done,                          // Flag to terminate
int hsp                // Half-sine pulse samples
:
    int rd_start;
    int tot_start;
    int symb0;
    int symb1;
    int symb2;
    int symb3;
    
	uint body_iterations;   // Number of times the "body" part of the transmission has to be repeated 
	uint body_index;        // Number of times the "body" part of the transmission has been repeated
	uint hsp_count;          // counter for half-sine pulse samples transmitted
    int hsp_out;
    
    int St;
    
    invariant 0 <= St && St < 6 
    invariant 0 <= hsp_count && hsp_count <= 8
    invariant body_index <= body_iterations
    invariant 2 <= St && St <= 4 ==> body_index < body_iterations
    invariant St = 5 || St = 0 ==> body_index = body_iterations
    
    invariant rd0(len) > 0 ==> body_iterations = 32*prev(len)
    invariant St = 0 || St = 1 || St = 5 ==> rd0(symb) = rd_start + (2*body_index)
    invariant St = 2 ==> rd0(symb) = rd_start + (2*body_index) + 1
    invariant St = 3 || St = 4 ==> rd0(symb) = rd_start + (2*body_index) + 2
    invariant St = 0 ==> rd0(symb) = rd_start+2*body_iterations
    invariant St = 0 ==> rd0(len) = tot0(done)
    invariant St != 0 ==> rd0(len) = tot0(done)+1
    
    invariant St != 3 && St != 4 && St != 5 ==> hsp_count = 0
    
    invariant St = 0 && body_iterations > 0 ==> tot0(hsp) = tot_start + (16*body_iterations)+8
    invariant St = 1 ==> tot0(hsp) = tot_start + (16*body_index)
    invariant St = 2 ==> tot0(hsp) = tot_start + (16*body_index)
    invariant St = 3 ==> tot0(hsp) = tot_start + (16*body_index) + hsp_count
    invariant St = 4 ==> tot0(hsp) = tot_start + (16*body_index) + 8 + hsp_count
    invariant St = 5 ==> tot0(hsp) = tot_start + (16*body_index) + hsp_count

	// one-time initialization routine
	initialize ==>
	do
	    rd_start := rd0(symb)
	    tot_start := tot0(hsp)
		symb3 := 0x7F;
		hsp_count := 0;
		St := 0;
		body_index := 0;
		body_iterations := 0;
	end
	
	// init action
	// Fired when payload length is known
	init: action len:[ len_in ] ==>
	guard St = 0
	requires 0 < len_in
	do
	    rd_start := rd0(symb)
	    tot_start := tot0(hsp)
		body_iterations := len_in * 32; 
		body_index := 0;
		symb2 := 0x7F;
		St := 1;
	end

	// read1 action
	// read first symbol
	read1: action symb:[ symb_in ] ==>
	guard St = 1 && body_index < body_iterations
	do
		symb0 := symb_in;
		St := 2;
	end

	// read2 action
	// read second symbol
	read2: action symb:[ symb_in ] ==>
	guard St = 2
	do
		symb1 := symb_in;
		hsp_count := 0;
		St := 3;
	end
	
	// tx_body1 action
	// produces a half-sine pulse sample
	tx_body1: action ==> hsp:[ hsp_out ]
	guard St = 3 && hsp_count < 8
	do	
		havoc hsp_out;
		hsp_count := hsp_count + 1;
		St := 3;
	end

	// tx_body1_done action
	// transition to tx_body2
	tx_body1_done: action ==>
	guard St = 3
	do
		hsp_count := 0;
		St := 4;
	end
		
	// tx_body2 action
	// produces a half-sine pulse sample
	tx_body2: action ==> hsp:[ hsp_out ]
	guard St = 4 && hsp_count < 8
	do	
		havoc hsp_out;
		hsp_count := hsp_count + 1;
		St := 4;
	end
		
	// tx_body1_done action
	// transition to tx_tail
	tx_body2_done: action ==>
	guard St = 4
	do
		symb2 := symb1;
		body_index := body_index + 1; 
		hsp_count := 0;
		St := 1;
	end

	// tx_tail_start action
	// Start transmitting tail
	tx_tail_start: action ==>
	guard St = 1 && body_index = body_iterations
    do
        St := 5;
	end

	// tx_tail_body action
	// produces a half-sine pulse sample
	tx_tail_body: action ==> hsp:[ hsp_out ]
	guard St = 5 && hsp_count < 8
	do
		havoc hsp_out;
		hsp_count := hsp_count + 1;
		St := 5;
	end
    
	tx_tail_done: action ==> done: [ true ]
	guard St = 5
	do
		hsp_count := 0;
		St := 0;
	end

	schedule fsm s_start :
		s_start ( init ) --> s_read1;

		s_read1 ( tx_tail_start ) --> s_tx_tail;
		s_tx_tail ( tx_tail_body ) --> s_tx_tail;
		s_tx_tail ( tx_tail_done ) --> s_start;

		s_read1 ( read1 ) --> s_read2;
		s_read2 ( read2 ) --> s_tx_body1;
		s_tx_body1 ( tx_body1 ) --> s_tx_body1;
		s_tx_body1 ( tx_body1_done ) --> s_tx_body2;
		s_tx_body2 ( tx_body2 ) --> s_tx_body2;
		s_tx_body2 ( tx_body2_done ) --> s_read1;
	end
	
	priority
		tx_tail_body > tx_tail_done;
		tx_body2 > tx_body2_done;
		tx_body1 > tx_body1_done
	end

end

