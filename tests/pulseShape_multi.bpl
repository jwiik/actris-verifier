// ---------------------------------------------------------------
// -- Types and global variables ---------------------------------
// ---------------------------------------------------------------
type Chan a;
type Actor;
type CType = <a>[Chan a]int;
type MType = <a>[Chan a][int]a;
type State;

var M: MType;
var C: CType;
var R: CType;
var I: CType;

const unique this#: Actor;
type List a = [int]a;
var AT#intlst: List int;

function AT#Min(x:int, y: int): int { if x <= y then x else y }

// ---------------------------------------------------------------
// -- End of prelude ---------------------------------------------
// ---------------------------------------------------------------

procedure pulseShape#init#0()
  modifies C, R, M, I;
{
  var symb: Chan (int);
  var len: Chan (int);
  var done: Chan (bool);
  var hsp: Chan (int);
  var this#: Actor;
  var symb_mem: int;
  var body_iterations: int;
  var body_index: int;
  var hsps0: int;
  var hsps1: int;
  var hsps2: int;
  var hsps3: int;
  var hsps4: int;
  var hsps5: int;
  var hsps6: int;
  var hsps7: int;
  var hsps8: int;
  var hsps9: int;
  var hsps10: int;
  var hsps11: int;
  var hsps12: int;
  var hsps13: int;
  var hsps14: int;
  var hsps15: int;
  var St: int;
  var rd_start: int;
  var tot_start: int;
  assume (symb != len) && (symb != hsp) && (len != hsp);
  assume R[symb] == 0;
  assume R[len] == 0;
  assume C[done] == 0;
  assume C[hsp] == 0;
  rd_start := R[symb];
  tot_start := C[hsp];
  body_index := 0;
  body_iterations := 0;
  St := 0;
  assert {:msg "23.22: Initialization might not establish the invariant (#0)"} 0 <= rd_start;
  assert {:msg "24.22: Initialization might not establish the invariant (#1)"} 0 <= tot_start;
  assert {:msg "25.22: Initialization might not establish the invariant (#2)"} rd_start <= R[symb];
  assert {:msg "26.22: Initialization might not establish the invariant (#3)"} tot_start <= C[hsp];
  assert {:msg "27.22: Initialization might not establish the invariant (#4)"} (St == 0) <==> (R[len] == C[done]);
  assert {:msg "28.22: Initialization might not establish the invariant (#5)"} (St == 1) <==> (R[len] == (C[done] + 1));
  assert {:msg "29.19: Initialization might not establish the invariant (#6)"} (R[len] > 0) ==> (body_iterations == (M[len][R[len] - 1] * 32));
  assert {:msg "30.19: Initialization might not establish the invariant (#7)"} body_index <= body_iterations;
  assert {:msg "31.19: Initialization might not establish the invariant (#8)"} R[symb] == (rd_start + (2 * body_index));
  assert {:msg "32.19: Initialization might not establish the invariant (#9)"} R[symb] == (rd_start + (2 * body_index));
  assert {:msg "33.19: Initialization might not establish the invariant (#10)"} (St == 1) ==> (C[hsp] == (tot_start + (16 * body_index)));
  assert {:msg "34.19: Initialization might not establish the invariant (#11)"} (St == 0) && (R[len] > 0) ==> (C[hsp] == ((tot_start + (16 * body_index)) + 8));
}
procedure pulseShape#init#1()
  modifies C, R, M, I;
{
  var symb: Chan (int);
  var len: Chan (int);
  var done: Chan (bool);
  var hsp: Chan (int);
  var this#: Actor;
  var symb_mem: int;
  var body_iterations: int;
  var body_index: int;
  var hsps0: int;
  var hsps1: int;
  var hsps2: int;
  var hsps3: int;
  var hsps4: int;
  var hsps5: int;
  var hsps6: int;
  var hsps7: int;
  var hsps8: int;
  var hsps9: int;
  var hsps10: int;
  var hsps11: int;
  var hsps12: int;
  var hsps13: int;
  var hsps14: int;
  var hsps15: int;
  var St: int;
  var rd_start: int;
  var tot_start: int;
  var len#0: int;
  assume (symb != len) && (symb != hsp) && (len != hsp);
  assume 0 <= R[symb];
  assume 0 <= R[len];
  assume 0 <= C[done];
  assume 0 <= C[hsp];
  assume 0 <= rd_start;
  assume 0 <= tot_start;
  assume rd_start <= R[symb];
  assume tot_start <= C[hsp];
  assume (St == 0) <==> (R[len] == C[done]);
  assume (St == 1) <==> (R[len] == (C[done] + 1));
  assume (R[len] > 0) ==> (body_iterations == (M[len][R[len] - 1] * 32));
  assume body_index <= body_iterations;
  assume R[symb] == (rd_start + (2 * body_index));
  assume R[symb] == (rd_start + (2 * body_index));
  assume (St == 1) ==> (C[hsp] == (tot_start + (16 * body_index)));
  assume (St == 0) && (R[len] > 0) ==> (C[hsp] == ((tot_start + (16 * body_index)) + 8));
  len#0 := M[len][R[len]];
  R[len] := R[len] + 1;
  assume len#0 >= 0;
  assume St == 0;
  rd_start := R[symb];
  tot_start := C[hsp];
  body_iterations := len#0 * 32;
  body_index := 0;
  symb_mem := 127;
  St := 1;
  assert {:msg "23.22: Action at 48.2 might not preserve invariant (#12)"} 0 <= rd_start;
  assert {:msg "24.22: Action at 48.2 might not preserve invariant (#13)"} 0 <= tot_start;
  assert {:msg "25.22: Action at 48.2 might not preserve invariant (#14)"} rd_start <= R[symb];
  assert {:msg "26.22: Action at 48.2 might not preserve invariant (#15)"} tot_start <= C[hsp];
  assert {:msg "27.22: Action at 48.2 might not preserve invariant (#16)"} (St == 0) <==> (R[len] == C[done]);
  assert {:msg "28.22: Action at 48.2 might not preserve invariant (#17)"} (St == 1) <==> (R[len] == (C[done] + 1));
  assert {:msg "29.19: Action at 48.2 might not preserve invariant (#18)"} (R[len] > 0) ==> (body_iterations == (M[len][R[len] - 1] * 32));
  assert {:msg "30.19: Action at 48.2 might not preserve invariant (#19)"} body_index <= body_iterations;
  assert {:msg "31.19: Action at 48.2 might not preserve invariant (#20)"} R[symb] == (rd_start + (2 * body_index));
  assert {:msg "32.19: Action at 48.2 might not preserve invariant (#21)"} R[symb] == (rd_start + (2 * body_index));
  assert {:msg "33.19: Action at 48.2 might not preserve invariant (#22)"} (St == 1) ==> (C[hsp] == (tot_start + (16 * body_index)));
  assert {:msg "34.19: Action at 48.2 might not preserve invariant (#23)"} (St == 0) && (R[len] > 0) ==> (C[hsp] == ((tot_start + (16 * body_index)) + 8));
}
procedure pulseShape#tx_body#2()
  modifies C, R, M, I;
{
  var symb: Chan (int);
  var len: Chan (int);
  var done: Chan (bool);
  var hsp: Chan (int);
  var this#: Actor;
  var symb_mem: int;
  var body_iterations: int;
  var body_index: int;
  var hsps0: int;
  var hsps1: int;
  var hsps2: int;
  var hsps3: int;
  var hsps4: int;
  var hsps5: int;
  var hsps6: int;
  var hsps7: int;
  var hsps8: int;
  var hsps9: int;
  var hsps10: int;
  var hsps11: int;
  var hsps12: int;
  var hsps13: int;
  var hsps14: int;
  var hsps15: int;
  var St: int;
  var rd_start: int;
  var tot_start: int;
  var symb#0: int;
  var symb#1: int;
  assume (symb != len) && (symb != hsp) && (len != hsp);
  assume 0 <= R[symb];
  assume 0 <= R[len];
  assume 0 <= C[done];
  assume 0 <= C[hsp];
  assume 0 <= rd_start;
  assume 0 <= tot_start;
  assume rd_start <= R[symb];
  assume tot_start <= C[hsp];
  assume (St == 0) <==> (R[len] == C[done]);
  assume (St == 1) <==> (R[len] == (C[done] + 1));
  assume (R[len] > 0) ==> (body_iterations == (M[len][R[len] - 1] * 32));
  assume body_index <= body_iterations;
  assume R[symb] == (rd_start + (2 * body_index));
  assume R[symb] == (rd_start + (2 * body_index));
  assume (St == 1) ==> (C[hsp] == (tot_start + (16 * body_index)));
  assume (St == 0) && (R[len] > 0) ==> (C[hsp] == ((tot_start + (16 * body_index)) + 8));
  symb#0 := M[symb][R[symb]];
  R[symb] := R[symb] + 1;
  symb#1 := M[symb][R[symb]];
  R[symb] := R[symb] + 1;
  assume (St == 1) && (body_index < body_iterations);
  havoc hsps0;
  havoc hsps1;
  havoc hsps2;
  havoc hsps3;
  havoc hsps4;
  havoc hsps5;
  havoc hsps6;
  havoc hsps7;
  havoc hsps8;
  havoc hsps9;
  havoc hsps10;
  havoc hsps11;
  havoc hsps12;
  havoc hsps13;
  havoc hsps14;
  havoc hsps15;
  symb_mem := symb#1;
  body_index := body_index + 1;
  St := 1;
  M[hsp][C[hsp]] := hsps0;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps1;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps2;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps3;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps4;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps5;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps6;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps7;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps8;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps9;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps10;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps11;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps12;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps13;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps14;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps15;
  C[hsp] := C[hsp] + 1;
  assert {:msg "23.22: Action at 62.2 might not preserve invariant (#24)"} 0 <= rd_start;
  assert {:msg "24.22: Action at 62.2 might not preserve invariant (#25)"} 0 <= tot_start;
  assert {:msg "25.22: Action at 62.2 might not preserve invariant (#26)"} rd_start <= R[symb];
  assert {:msg "26.22: Action at 62.2 might not preserve invariant (#27)"} tot_start <= C[hsp];
  assert {:msg "27.22: Action at 62.2 might not preserve invariant (#28)"} (St == 0) <==> (R[len] == C[done]);
  assert {:msg "28.22: Action at 62.2 might not preserve invariant (#29)"} (St == 1) <==> (R[len] == (C[done] + 1));
  assert {:msg "29.19: Action at 62.2 might not preserve invariant (#30)"} (R[len] > 0) ==> (body_iterations == (M[len][R[len] - 1] * 32));
  assert {:msg "30.19: Action at 62.2 might not preserve invariant (#31)"} body_index <= body_iterations;
  assert {:msg "31.19: Action at 62.2 might not preserve invariant (#32)"} R[symb] == (rd_start + (2 * body_index));
  assert {:msg "32.19: Action at 62.2 might not preserve invariant (#33)"} R[symb] == (rd_start + (2 * body_index));
  assert {:msg "33.19: Action at 62.2 might not preserve invariant (#34)"} (St == 1) ==> (C[hsp] == (tot_start + (16 * body_index)));
  assert {:msg "34.19: Action at 62.2 might not preserve invariant (#35)"} (St == 0) && (R[len] > 0) ==> (C[hsp] == ((tot_start + (16 * body_index)) + 8));
}
procedure pulseShape#tx_tail#3()
  modifies C, R, M, I;
{
  var symb: Chan (int);
  var len: Chan (int);
  var done: Chan (bool);
  var hsp: Chan (int);
  var this#: Actor;
  var symb_mem: int;
  var body_iterations: int;
  var body_index: int;
  var hsps0: int;
  var hsps1: int;
  var hsps2: int;
  var hsps3: int;
  var hsps4: int;
  var hsps5: int;
  var hsps6: int;
  var hsps7: int;
  var hsps8: int;
  var hsps9: int;
  var hsps10: int;
  var hsps11: int;
  var hsps12: int;
  var hsps13: int;
  var hsps14: int;
  var hsps15: int;
  var St: int;
  var rd_start: int;
  var tot_start: int;
  assume (symb != len) && (symb != hsp) && (len != hsp);
  assume 0 <= R[symb];
  assume 0 <= R[len];
  assume 0 <= C[done];
  assume 0 <= C[hsp];
  assume 0 <= rd_start;
  assume 0 <= tot_start;
  assume rd_start <= R[symb];
  assume tot_start <= C[hsp];
  assume (St == 0) <==> (R[len] == C[done]);
  assume (St == 1) <==> (R[len] == (C[done] + 1));
  assume (R[len] > 0) ==> (body_iterations == (M[len][R[len] - 1] * 32));
  assume body_index <= body_iterations;
  assume R[symb] == (rd_start + (2 * body_index));
  assume R[symb] == (rd_start + (2 * body_index));
  assume (St == 1) ==> (C[hsp] == (tot_start + (16 * body_index)));
  assume (St == 0) && (R[len] > 0) ==> (C[hsp] == ((tot_start + (16 * body_index)) + 8));
  assume (St == 1) && (body_index == body_iterations);
  havoc hsps0;
  havoc hsps1;
  havoc hsps2;
  havoc hsps3;
  havoc hsps4;
  havoc hsps5;
  havoc hsps6;
  havoc hsps7;
  St := 0;
  M[hsp][C[hsp]] := hsps0;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps1;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps2;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps3;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps4;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps5;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps6;
  C[hsp] := C[hsp] + 1;
  M[hsp][C[hsp]] := hsps7;
  C[hsp] := C[hsp] + 1;
  M[done][C[done]] := true;
  C[done] := C[done] + 1;
  assert {:msg "23.22: Action at 90.2 might not preserve invariant (#36)"} 0 <= rd_start;
  assert {:msg "24.22: Action at 90.2 might not preserve invariant (#37)"} 0 <= tot_start;
  assert {:msg "25.22: Action at 90.2 might not preserve invariant (#38)"} rd_start <= R[symb];
  assert {:msg "26.22: Action at 90.2 might not preserve invariant (#39)"} tot_start <= C[hsp];
  assert {:msg "27.22: Action at 90.2 might not preserve invariant (#40)"} (St == 0) <==> (R[len] == C[done]);
  assert {:msg "28.22: Action at 90.2 might not preserve invariant (#41)"} (St == 1) <==> (R[len] == (C[done] + 1));
  assert {:msg "29.19: Action at 90.2 might not preserve invariant (#42)"} (R[len] > 0) ==> (body_iterations == (M[len][R[len] - 1] * 32));
  assert {:msg "30.19: Action at 90.2 might not preserve invariant (#43)"} body_index <= body_iterations;
  assert {:msg "31.19: Action at 90.2 might not preserve invariant (#44)"} R[symb] == (rd_start + (2 * body_index));
  assert {:msg "32.19: Action at 90.2 might not preserve invariant (#45)"} R[symb] == (rd_start + (2 * body_index));
  assert {:msg "33.19: Action at 90.2 might not preserve invariant (#46)"} (St == 1) ==> (C[hsp] == (tot_start + (16 * body_index)));
  assert {:msg "34.19: Action at 90.2 might not preserve invariant (#47)"} (St == 0) && (R[len] > 0) ==> (C[hsp] == ((tot_start + (16 * body_index)) + 8));
}
procedure pulseShape##GuardWD#4()
  modifies C, R, M, I;
{
  var symb: Chan (int);
  var len: Chan (int);
  var done: Chan (bool);
  var hsp: Chan (int);
  var this#: Actor;
  var symb_mem: int;
  var body_iterations: int;
  var body_index: int;
  var hsps0: int;
  var hsps1: int;
  var hsps2: int;
  var hsps3: int;
  var hsps4: int;
  var hsps5: int;
  var hsps6: int;
  var hsps7: int;
  var hsps8: int;
  var hsps9: int;
  var hsps10: int;
  var hsps11: int;
  var hsps12: int;
  var hsps13: int;
  var hsps14: int;
  var hsps15: int;
  var St: int;
  var rd_start: int;
  var tot_start: int;
  var len#0: int;
  var symb#0: int;
  var symb#1: int;
  assume (symb != len) && (symb != hsp) && (len != hsp);
  assert {:msg "1.1: The actions of actor 'pulseShape' might not have mutually exclusive guards (#48)"} !((1 <= (C[len] - R[len])) && (St == 0) && (2 <= (C[symb] - R[symb])) && (St == 1) && (body_index < body_iterations));
  assert {:msg "1.1: The actions of actor 'pulseShape' might not have mutually exclusive guards (#49)"} !((1 <= (C[len] - R[len])) && (St == 0) && (St == 1) && (body_index == body_iterations));
  assert {:msg "1.1: The actions of actor 'pulseShape' might not have mutually exclusive guards (#50)"} !((2 <= (C[symb] - R[symb])) && (St == 1) && (body_index < body_iterations) && (St == 1) && (body_index == body_iterations));
}
procedure Net#init#5()
  modifies C, R, M, I;
{
  var Net#shp: Actor;
  var Net#a: Chan (int);
  var Net#b: Chan (int);
  var Net#c: Chan (int);
  var Net#d: Chan (bool);
  var AV#shp#symb_mem: int;
  var AV#shp#body_iterations: int;
  var AV#shp#body_index: int;
  var AV#shp#hsps0: int;
  var AV#shp#hsps1: int;
  var AV#shp#hsps2: int;
  var AV#shp#hsps3: int;
  var AV#shp#hsps4: int;
  var AV#shp#hsps5: int;
  var AV#shp#hsps6: int;
  var AV#shp#hsps7: int;
  var AV#shp#hsps8: int;
  var AV#shp#hsps9: int;
  var AV#shp#hsps10: int;
  var AV#shp#hsps11: int;
  var AV#shp#hsps12: int;
  var AV#shp#hsps13: int;
  var AV#shp#hsps14: int;
  var AV#shp#hsps15: int;
  var AV#shp#St: int;
  var AV#shp#rd_start: int;
  var AV#shp#tot_start: int;
  assume (Net#a != Net#b) && (Net#a != Net#c) && (Net#b != Net#c);
  assume 0 <= I[Net#a];
  assume I[Net#a] <= R[Net#a];
  assume R[Net#a] <= C[Net#a];
  assume 0 <= I[Net#b];
  assume I[Net#b] <= R[Net#b];
  assume R[Net#b] <= C[Net#b];
  assume 0 <= I[Net#c];
  assume I[Net#c] <= R[Net#c];
  assume R[Net#c] <= C[Net#c];
  assume I[Net#c] == R[Net#c];
  assume 0 <= I[Net#d];
  assume I[Net#d] <= R[Net#d];
  assume R[Net#d] <= C[Net#d];
  assume I[Net#d] == R[Net#d];
  assume C[Net#a] == 0;
  assume R[Net#a] == 0;
  assume C[Net#b] == 0;
  assume R[Net#b] == 0;
  assume C[Net#c] == 0;
  assume R[Net#c] == 0;
  assume C[Net#d] == 0;
  assume R[Net#d] == 0;
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  assert {:msg "121.15: Initialization of network 'Net' might not establish the channel invariant (#51)"} AV#shp#rd_start == I[Net#b];
  assert {:msg "122.16: Initialization of network 'Net' might not establish the channel invariant (#52)"} (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assert {:msg "123.15: Initialization of network 'Net' might not establish the channel invariant (#53)"} (264 * I[Net#b]) == (32 * I[Net#c]);
  I := R;
  assert {:msg "120.13: Network initialization might not establish the network invariant (#54)"} AV#shp#St == 0;
  assert {:msg "131.5: The initialization might produce unspecified tokens on channel a (#55)"} (C[Net#a] - R[Net#a]) == 0;
  assert {:msg "132.5: The initialization might produce unspecified tokens on channel b (#56)"} (C[Net#b] - R[Net#b]) == 0;
  assert {:msg "133.5: The initialization might produce unspecified tokens on channel c (#57)"} (C[Net#c] - R[Net#c]) == 0;
  assert {:msg "134.5: The initialization might produce unspecified tokens on channel d (#58)"} (C[Net#d] - R[Net#d]) == 0;
}
procedure Net##pulseShape#init#6()
  modifies C, R, M, I;
{
  var Net#shp: Actor;
  var Net#a: Chan (int);
  var Net#b: Chan (int);
  var Net#c: Chan (int);
  var Net#d: Chan (bool);
  var AV#shp#symb_mem: int;
  var AV#shp#body_iterations: int;
  var AV#shp#body_index: int;
  var AV#shp#hsps0: int;
  var AV#shp#hsps1: int;
  var AV#shp#hsps2: int;
  var AV#shp#hsps3: int;
  var AV#shp#hsps4: int;
  var AV#shp#hsps5: int;
  var AV#shp#hsps6: int;
  var AV#shp#hsps7: int;
  var AV#shp#hsps8: int;
  var AV#shp#hsps9: int;
  var AV#shp#hsps10: int;
  var AV#shp#hsps11: int;
  var AV#shp#hsps12: int;
  var AV#shp#hsps13: int;
  var AV#shp#hsps14: int;
  var AV#shp#hsps15: int;
  var AV#shp#St: int;
  var AV#shp#rd_start: int;
  var AV#shp#tot_start: int;
  var len#len_in: int;
  assume (Net#a != Net#b) && (Net#a != Net#c) && (Net#b != Net#c);
  assume 0 <= I[Net#a];
  assume I[Net#a] <= R[Net#a];
  assume R[Net#a] <= C[Net#a];
  assume 0 <= I[Net#b];
  assume I[Net#b] <= R[Net#b];
  assume R[Net#b] <= C[Net#b];
  assume 0 <= I[Net#c];
  assume I[Net#c] <= R[Net#c];
  assume R[Net#c] <= C[Net#c];
  assume I[Net#c] == R[Net#c];
  assume 0 <= I[Net#d];
  assume I[Net#d] <= R[Net#d];
  assume R[Net#d] <= C[Net#d];
  assume I[Net#d] == R[Net#d];
  assume AV#shp#rd_start == I[Net#b];
  assume (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assume (264 * I[Net#b]) == (32 * I[Net#c]);
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  assume (1 <= (C[Net#a] - R[Net#a])) && (AV#shp#St == 0);
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  len#len_in := M[Net#a][R[Net#a]];
  R[Net#a] := R[Net#a] + 1;
  assert {:msg "50.11: Precondition might not hold for instance at 127.5 (#59)"} len#len_in >= 0;
  havoc AV#shp#tot_start;
  havoc AV#shp#rd_start;
  havoc AV#shp#St;
  havoc AV#shp#body_iterations;
  havoc AV#shp#symb_mem;
  havoc AV#shp#body_index;
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  assert {:msg "121.15: Action at 48.2 ('init') for actor instance 'shp' might not preserve the channel invariant (#60)"} AV#shp#rd_start == I[Net#b];
  assert {:msg "122.16: Action at 48.2 ('init') for actor instance 'shp' might not preserve the channel invariant (#61)"} (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assert {:msg "123.15: Action at 48.2 ('init') for actor instance 'shp' might not preserve the channel invariant (#62)"} (264 * I[Net#b]) == (32 * I[Net#c]);
}
procedure Net##pulseShape#tx_body#7()
  modifies C, R, M, I;
{
  var Net#shp: Actor;
  var Net#a: Chan (int);
  var Net#b: Chan (int);
  var Net#c: Chan (int);
  var Net#d: Chan (bool);
  var AV#shp#symb_mem: int;
  var AV#shp#body_iterations: int;
  var AV#shp#body_index: int;
  var AV#shp#hsps0: int;
  var AV#shp#hsps1: int;
  var AV#shp#hsps2: int;
  var AV#shp#hsps3: int;
  var AV#shp#hsps4: int;
  var AV#shp#hsps5: int;
  var AV#shp#hsps6: int;
  var AV#shp#hsps7: int;
  var AV#shp#hsps8: int;
  var AV#shp#hsps9: int;
  var AV#shp#hsps10: int;
  var AV#shp#hsps11: int;
  var AV#shp#hsps12: int;
  var AV#shp#hsps13: int;
  var AV#shp#hsps14: int;
  var AV#shp#hsps15: int;
  var AV#shp#St: int;
  var AV#shp#rd_start: int;
  var AV#shp#tot_start: int;
  var symb#symb_1: int;
  var symb#symb_2: int;
  assume (Net#a != Net#b) && (Net#a != Net#c) && (Net#b != Net#c);
  assume 0 <= I[Net#a];
  assume I[Net#a] <= R[Net#a];
  assume R[Net#a] <= C[Net#a];
  assume 0 <= I[Net#b];
  assume I[Net#b] <= R[Net#b];
  assume R[Net#b] <= C[Net#b];
  assume 0 <= I[Net#c];
  assume I[Net#c] <= R[Net#c];
  assume R[Net#c] <= C[Net#c];
  assume I[Net#c] == R[Net#c];
  assume 0 <= I[Net#d];
  assume I[Net#d] <= R[Net#d];
  assume R[Net#d] <= C[Net#d];
  assume I[Net#d] == R[Net#d];
  assume AV#shp#rd_start == I[Net#b];
  assume (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assume (264 * I[Net#b]) == (32 * I[Net#c]);
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  assume (2 <= (C[Net#b] - R[Net#b])) && (AV#shp#St == 1) && (AV#shp#body_index < AV#shp#body_iterations);
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  symb#symb_1 := M[Net#b][R[Net#b]];
  R[Net#b] := R[Net#b] + 1;
  symb#symb_2 := M[Net#b][R[Net#b]];
  R[Net#b] := R[Net#b] + 1;
  havoc AV#shp#symb_mem;
  havoc AV#shp#body_index;
  havoc AV#shp#St;
  M[Net#c][C[Net#c]] := AV#shp#hsps0;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps1;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps2;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps3;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps4;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps5;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps6;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps7;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps8;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps9;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps10;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps11;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps12;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps13;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps14;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps15;
  C[Net#c] := C[Net#c] + 1;
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  assert {:msg "121.15: Action at 62.2 ('tx_body') for actor instance 'shp' might not preserve the channel invariant (#63)"} AV#shp#rd_start == I[Net#b];
  assert {:msg "122.16: Action at 62.2 ('tx_body') for actor instance 'shp' might not preserve the channel invariant (#64)"} (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assert {:msg "123.15: Action at 62.2 ('tx_body') for actor instance 'shp' might not preserve the channel invariant (#65)"} (264 * I[Net#b]) == (32 * I[Net#c]);
}
procedure Net##pulseShape#tx_tail#8()
  modifies C, R, M, I;
{
  var Net#shp: Actor;
  var Net#a: Chan (int);
  var Net#b: Chan (int);
  var Net#c: Chan (int);
  var Net#d: Chan (bool);
  var AV#shp#symb_mem: int;
  var AV#shp#body_iterations: int;
  var AV#shp#body_index: int;
  var AV#shp#hsps0: int;
  var AV#shp#hsps1: int;
  var AV#shp#hsps2: int;
  var AV#shp#hsps3: int;
  var AV#shp#hsps4: int;
  var AV#shp#hsps5: int;
  var AV#shp#hsps6: int;
  var AV#shp#hsps7: int;
  var AV#shp#hsps8: int;
  var AV#shp#hsps9: int;
  var AV#shp#hsps10: int;
  var AV#shp#hsps11: int;
  var AV#shp#hsps12: int;
  var AV#shp#hsps13: int;
  var AV#shp#hsps14: int;
  var AV#shp#hsps15: int;
  var AV#shp#St: int;
  var AV#shp#rd_start: int;
  var AV#shp#tot_start: int;
  assume (Net#a != Net#b) && (Net#a != Net#c) && (Net#b != Net#c);
  assume 0 <= I[Net#a];
  assume I[Net#a] <= R[Net#a];
  assume R[Net#a] <= C[Net#a];
  assume 0 <= I[Net#b];
  assume I[Net#b] <= R[Net#b];
  assume R[Net#b] <= C[Net#b];
  assume 0 <= I[Net#c];
  assume I[Net#c] <= R[Net#c];
  assume R[Net#c] <= C[Net#c];
  assume I[Net#c] == R[Net#c];
  assume 0 <= I[Net#d];
  assume I[Net#d] <= R[Net#d];
  assume R[Net#d] <= C[Net#d];
  assume I[Net#d] == R[Net#d];
  assume AV#shp#rd_start == I[Net#b];
  assume (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assume (264 * I[Net#b]) == (32 * I[Net#c]);
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  assume (AV#shp#St == 1) && (AV#shp#body_index == AV#shp#body_iterations);
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  havoc AV#shp#St;
  M[Net#c][C[Net#c]] := AV#shp#hsps0;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps1;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps2;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps3;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps4;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps5;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps6;
  C[Net#c] := C[Net#c] + 1;
  M[Net#c][C[Net#c]] := AV#shp#hsps7;
  C[Net#c] := C[Net#c] + 1;
  M[Net#d][C[Net#d]] := true;
  C[Net#d] := C[Net#d] + 1;
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  assert {:msg "121.15: Action at 90.2 ('tx_tail') for actor instance 'shp' might not preserve the channel invariant (#66)"} AV#shp#rd_start == I[Net#b];
  assert {:msg "122.16: Action at 90.2 ('tx_tail') for actor instance 'shp' might not preserve the channel invariant (#67)"} (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assert {:msg "123.15: Action at 90.2 ('tx_tail') for actor instance 'shp' might not preserve the channel invariant (#68)"} (264 * I[Net#b]) == (32 * I[Net#c]);
}
procedure Net#entry()
  modifies C, R, M, I;
{
  var Net#shp: Actor;
  var Net#a: Chan (int);
  var Net#b: Chan (int);
  var Net#c: Chan (int);
  var Net#d: Chan (bool);
  var AV#shp#symb_mem: int;
  var AV#shp#body_iterations: int;
  var AV#shp#body_index: int;
  var AV#shp#hsps0: int;
  var AV#shp#hsps1: int;
  var AV#shp#hsps2: int;
  var AV#shp#hsps3: int;
  var AV#shp#hsps4: int;
  var AV#shp#hsps5: int;
  var AV#shp#hsps6: int;
  var AV#shp#hsps7: int;
  var AV#shp#hsps8: int;
  var AV#shp#hsps9: int;
  var AV#shp#hsps10: int;
  var AV#shp#hsps11: int;
  var AV#shp#hsps12: int;
  var AV#shp#hsps13: int;
  var AV#shp#hsps14: int;
  var AV#shp#hsps15: int;
  var AV#shp#St: int;
  var AV#shp#rd_start: int;
  var AV#shp#tot_start: int;
  assume (Net#a != Net#b) && (Net#a != Net#c) && (Net#b != Net#c);
  assume 0 <= I[Net#a];
  assume I[Net#a] <= R[Net#a];
  assume R[Net#a] <= C[Net#a];
  assume 0 <= I[Net#b];
  assume I[Net#b] <= R[Net#b];
  assume R[Net#b] <= C[Net#b];
  assume 0 <= I[Net#c];
  assume I[Net#c] <= R[Net#c];
  assume R[Net#c] <= C[Net#c];
  assume I[Net#c] == R[Net#c];
  assume 0 <= I[Net#d];
  assume I[Net#d] <= R[Net#d];
  assume R[Net#d] <= C[Net#d];
  assume I[Net#d] == R[Net#d];
  assume C[Net#a] == R[Net#a];
  assume C[Net#b] == R[Net#b];
  assume C[Net#c] == R[Net#c];
  assume C[Net#d] == R[Net#d];
  assume AV#shp#St == 0;
  assume AV#shp#rd_start == I[Net#b];
  assume (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assume (264 * I[Net#b]) == (32 * I[Net#c]);
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  assert {:msg "114.1: Sub-actors in the network might fire without network input. This is not permitted. (#69)"} !((AV#shp#St == 1) && (AV#shp#body_index == AV#shp#body_iterations));
  assert {:msg "114.1: Sub-actors in the network might fire without network input. This is not permitted. (#70)"} !((2 <= (C[Net#b] - R[Net#b])) && (AV#shp#St == 1) && (AV#shp#body_index < AV#shp#body_iterations));
  assert {:msg "114.1: Sub-actors in the network might fire without network input. This is not permitted. (#71)"} !((1 <= (C[Net#a] - R[Net#a])) && (AV#shp#St == 0));
}
procedure Net#anon$1#input#len#9()
  modifies C, R, M, I;
{
  var Net#shp: Actor;
  var Net#a: Chan (int);
  var Net#b: Chan (int);
  var Net#c: Chan (int);
  var Net#d: Chan (bool);
  var AV#shp#symb_mem: int;
  var AV#shp#body_iterations: int;
  var AV#shp#body_index: int;
  var AV#shp#hsps0: int;
  var AV#shp#hsps1: int;
  var AV#shp#hsps2: int;
  var AV#shp#hsps3: int;
  var AV#shp#hsps4: int;
  var AV#shp#hsps5: int;
  var AV#shp#hsps6: int;
  var AV#shp#hsps7: int;
  var AV#shp#hsps8: int;
  var AV#shp#hsps9: int;
  var AV#shp#hsps10: int;
  var AV#shp#hsps11: int;
  var AV#shp#hsps12: int;
  var AV#shp#hsps13: int;
  var AV#shp#hsps14: int;
  var AV#shp#hsps15: int;
  var AV#shp#St: int;
  var AV#shp#rd_start: int;
  var AV#shp#tot_start: int;
  assume (Net#a != Net#b) && (Net#a != Net#c) && (Net#b != Net#c);
  assume 0 <= I[Net#a];
  assume I[Net#a] <= R[Net#a];
  assume R[Net#a] <= C[Net#a];
  assume 0 <= I[Net#b];
  assume I[Net#b] <= R[Net#b];
  assume R[Net#b] <= C[Net#b];
  assume 0 <= I[Net#c];
  assume I[Net#c] <= R[Net#c];
  assume R[Net#c] <= C[Net#c];
  assume I[Net#c] == R[Net#c];
  assume 0 <= I[Net#d];
  assume I[Net#d] <= R[Net#d];
  assume R[Net#d] <= C[Net#d];
  assume I[Net#d] == R[Net#d];
  assume C[Net#a] < 1;
  assume AV#shp#rd_start == I[Net#b];
  assume (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assume (264 * I[Net#b]) == (32 * I[Net#c]);
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  C[Net#a] := C[Net#a] + 1;
  assume (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assert {:msg "121.15: Channel invariant might be falsified by network input (#72)"} AV#shp#rd_start == I[Net#b];
  assert {:msg "122.16: Channel invariant might be falsified by network input (#73)"} (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assert {:msg "123.15: Channel invariant might be falsified by network input (#74)"} (264 * I[Net#b]) == (32 * I[Net#c]);
}
procedure Net#anon$1#input#symb#10()
  modifies C, R, M, I;
{
  var Net#shp: Actor;
  var Net#a: Chan (int);
  var Net#b: Chan (int);
  var Net#c: Chan (int);
  var Net#d: Chan (bool);
  var AV#shp#symb_mem: int;
  var AV#shp#body_iterations: int;
  var AV#shp#body_index: int;
  var AV#shp#hsps0: int;
  var AV#shp#hsps1: int;
  var AV#shp#hsps2: int;
  var AV#shp#hsps3: int;
  var AV#shp#hsps4: int;
  var AV#shp#hsps5: int;
  var AV#shp#hsps6: int;
  var AV#shp#hsps7: int;
  var AV#shp#hsps8: int;
  var AV#shp#hsps9: int;
  var AV#shp#hsps10: int;
  var AV#shp#hsps11: int;
  var AV#shp#hsps12: int;
  var AV#shp#hsps13: int;
  var AV#shp#hsps14: int;
  var AV#shp#hsps15: int;
  var AV#shp#St: int;
  var AV#shp#rd_start: int;
  var AV#shp#tot_start: int;
  assume (Net#a != Net#b) && (Net#a != Net#c) && (Net#b != Net#c);
  assume 0 <= I[Net#a];
  assume I[Net#a] <= R[Net#a];
  assume R[Net#a] <= C[Net#a];
  assume 0 <= I[Net#b];
  assume I[Net#b] <= R[Net#b];
  assume R[Net#b] <= C[Net#b];
  assume 0 <= I[Net#c];
  assume I[Net#c] <= R[Net#c];
  assume R[Net#c] <= C[Net#c];
  assume I[Net#c] == R[Net#c];
  assume 0 <= I[Net#d];
  assume I[Net#d] <= R[Net#d];
  assume R[Net#d] <= C[Net#d];
  assume I[Net#d] == R[Net#d];
  assume C[Net#b] < 32;
  assume AV#shp#rd_start == I[Net#b];
  assume (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assume (264 * I[Net#b]) == (32 * I[Net#c]);
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  C[Net#b] := C[Net#b] + 1;
  assume (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assert {:msg "121.15: Channel invariant might be falsified by network input (#75)"} AV#shp#rd_start == I[Net#b];
  assert {:msg "122.16: Channel invariant might be falsified by network input (#76)"} (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assert {:msg "123.15: Channel invariant might be falsified by network input (#77)"} (264 * I[Net#b]) == (32 * I[Net#c]);
}
procedure Net#anon$1#exit#11()
  modifies C, R, M, I;
{
  var Net#shp: Actor;
  var Net#a: Chan (int);
  var Net#b: Chan (int);
  var Net#c: Chan (int);
  var Net#d: Chan (bool);
  var AV#shp#symb_mem: int;
  var AV#shp#body_iterations: int;
  var AV#shp#body_index: int;
  var AV#shp#hsps0: int;
  var AV#shp#hsps1: int;
  var AV#shp#hsps2: int;
  var AV#shp#hsps3: int;
  var AV#shp#hsps4: int;
  var AV#shp#hsps5: int;
  var AV#shp#hsps6: int;
  var AV#shp#hsps7: int;
  var AV#shp#hsps8: int;
  var AV#shp#hsps9: int;
  var AV#shp#hsps10: int;
  var AV#shp#hsps11: int;
  var AV#shp#hsps12: int;
  var AV#shp#hsps13: int;
  var AV#shp#hsps14: int;
  var AV#shp#hsps15: int;
  var AV#shp#St: int;
  var AV#shp#rd_start: int;
  var AV#shp#tot_start: int;
  assume (Net#a != Net#b) && (Net#a != Net#c) && (Net#b != Net#c);
  assume 0 <= I[Net#a];
  assume I[Net#a] <= R[Net#a];
  assume R[Net#a] <= C[Net#a];
  assume 0 <= I[Net#b];
  assume I[Net#b] <= R[Net#b];
  assume R[Net#b] <= C[Net#b];
  assume 0 <= I[Net#c];
  assume I[Net#c] <= R[Net#c];
  assume R[Net#c] <= C[Net#c];
  assume I[Net#c] == R[Net#c];
  assume 0 <= I[Net#d];
  assume I[Net#d] <= R[Net#d];
  assume R[Net#d] <= C[Net#d];
  assume I[Net#d] == R[Net#d];
  assume AV#shp#rd_start == I[Net#b];
  assume (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assume (264 * I[Net#b]) == (32 * I[Net#c]);
  assume 0 <= AV#shp#rd_start;
  assume 0 <= AV#shp#tot_start;
  assume AV#shp#rd_start <= R[Net#b];
  assume AV#shp#tot_start <= C[Net#c];
  assume (AV#shp#St == 0) <==> (R[Net#a] == C[Net#d]);
  assume (AV#shp#St == 1) <==> (R[Net#a] == (C[Net#d] + 1));
  assume (R[Net#a] > 0) ==> (AV#shp#body_iterations == (M[Net#a][R[Net#a] - 1] * 32));
  assume AV#shp#body_index <= AV#shp#body_iterations;
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume R[Net#b] == (AV#shp#rd_start + (2 * AV#shp#body_index));
  assume (AV#shp#St == 1) ==> (C[Net#c] == (AV#shp#tot_start + (16 * AV#shp#body_index)));
  assume (AV#shp#St == 0) && (R[Net#a] > 0) ==> (C[Net#c] == ((AV#shp#tot_start + (16 * AV#shp#body_index)) + 8));
  assume (C[Net#a] - I[Net#a]) == 1;
  assume (C[Net#b] - I[Net#b]) == 32;
  assume (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assume !((AV#shp#St == 1) && (AV#shp#body_index == AV#shp#body_iterations));
  assume !((2 <= (C[Net#b] - R[Net#b])) && (AV#shp#St == 1) && (AV#shp#body_index < AV#shp#body_iterations));
  assume !((1 <= (C[Net#a] - R[Net#a])) && (AV#shp#St == 0));
  R[Net#c] := R[Net#c] + 264;
  R[Net#d] := R[Net#d] + 1;
  I := R;
  assert {:msg "121.15: The network might not preserve the channel invariant (#78)"} AV#shp#rd_start == I[Net#b];
  assert {:msg "122.16: The network might not preserve the channel invariant (#79)"} (forall i: int :: 
    (0 <= i) && (i < C[Net#a]) ==> (M[Net#a][i] == 16)
  );
  assert {:msg "123.15: The network might not preserve the channel invariant (#80)"} (264 * I[Net#b]) == (32 * I[Net#c]);
  assert {:msg "120.13: The network might not preserve the network invariant (#81)"} AV#shp#St == 0;
  assert {:msg "116.3: The network might leave unread tokens on channel a (#82)"} C[Net#a] == R[Net#a];
  assert {:msg "116.3: The network might leave unread tokens on channel b (#83)"} C[Net#b] == R[Net#b];
  assert {:msg "116.3: The network might not produce the specified number of tokens on output hsp (#84)"} C[Net#c] == R[Net#c];
  assert {:msg "116.3: The network might not produce the specified number of tokens on output done (#85)"} C[Net#d] == R[Net#d];
}
