actor pulseShape() 
// Inputs:
int symb,		// I-Q symbols from QPSK modulator 
int len		// Payload length
// Outputs:
==> 
bool done,		// flag to terminate
int hsp			// Half-sine pulse samples
:
	int symb_mem;			// Temporary storage for symbol values during transmission
										// the current hsp. range: [0...8] 
	uint body_iterations;	// Number of times the "body" part of the transmission has to be repeated 
	uint body_index;		// Number of times the "body" part of the transmission has been repeated
    
    int hsps0; int hsps1; int hsps2; int hsps3; int hsps4; int hsps5; int hsps6; int hsps7;
    int hsps8; int hsps9; int hsps10; int hsps11; int hsps12; int hsps13; int hsps14; int hsps15;
    
    int St;
    
    int rd_start; // Ghost var
    int tot_start // Ghost var
   
    public invariant 0 <= rd_start
    public invariant 0 <= tot_start
    public invariant rd_start <= rd0(symb)
    public invariant tot_start <= tot0(hsp)
    public invariant St = 0 <==> rd0(len) = tot0(done)
    public invariant St = 1 <==> rd0(len) = tot0(done)+1
	public invariant rd0(len) > 0 ==> body_iterations = prev(len)*32
	public invariant body_index <= body_iterations
	public invariant rd0(symb) = rd_start + 2*body_index
	public invariant rd0(symb) = rd_start + 2*body_index
	public invariant St = 1 ==> tot0(hsp) = tot_start + 16*body_index
	public invariant St = 0 && rd0(len) > 0 ==> tot0(hsp) = tot_start + 16*body_index+8
	
 	initialize ==>
 	do 
 	 	rd_start := rd0(symb)
 		tot_start := tot0(hsp)
 		body_index := 0;
 		body_iterations := 0;
 		St := 0

 	end

	// init action
	// Fired when payload length is known
	init: action len:[len_in] ==>
	guard St = 0
	requires len_in >= 0 // This program is not correct without this assumption
	do
		rd_start := rd0(symb)
 		tot_start := tot0(hsp)
		body_iterations := (len_in * 32); 
		body_index := 0;
		symb_mem := 0x7F;
		St := 1;
	end

	// tx-body action
	// Consumes 2, produces 16 samples
	tx_body: action symb:[ symb_1, symb_2 ] ==> 
	   hsp:[ hsps0, hsps1, hsps2, hsps3, hsps4, hsps5, hsps6, hsps7, hsps8, hsps9, hsps10, hsps11, hsps12, hsps13, hsps14, hsps15 ]
	guard
		St = 1 && body_index < body_iterations
	do	
		havoc hsps0;
		havoc hsps1;
		havoc hsps2;
		havoc hsps3;
		havoc hsps4;
		havoc hsps5;
		havoc hsps6;
		havoc hsps7;
		havoc hsps8;
		havoc hsps9;
		havoc hsps10;
		havoc hsps11;
		havoc hsps12;
		havoc hsps13;
		havoc hsps14;
		havoc hsps15;
		symb_mem := symb_2;
		body_index := body_index + 1; 
		St := 1;
	end

	// tx_tail action
	// Finalizes the transmission signal with the fixed 0x7F value
	tx_tail: action ==> hsp:[ hsps0, hsps1, hsps2, hsps3, hsps4, hsps5, hsps6, hsps7 ], done: [ true ]
	guard
		St = 1 && body_index = body_iterations
	do
		havoc hsps0;
		havoc hsps1;
		havoc hsps2;
		havoc hsps3;
		havoc hsps4;
		havoc hsps5;
		havoc hsps6;
		havoc hsps7;
		St := 0;
	end

	schedule fsm s_start :
		s_start ( init ) --> s_idle;
		s_idle ( tx_body ) --> s_idle;
		s_idle ( tx_tail ) --> s_start;
	end

end


network Net int len, int symb ==> int hsp, bool done :
    
  action len:1, symb:32 ==> hsp:264, done:1
    requires (forall int i :: every(len,i) ==> len[i] = 16)
  end
  
  invariant subvar(shp,St) = 0
  chinvariant subvar(shp,rd_start) = @(symb)
  chinvariant (forall int i :: every(a,i) ==> a[i] = 16)
  chinvariant 264*@(symb) = 32*@(hsp)
  
  
  entities
    shp = pulseShape();
  end
  
  structure
    a: len --> shp.len;
    b: symb --> shp.symb;
    c: shp.hsp --> hsp;
    d: shp.done --> done;
  end

end