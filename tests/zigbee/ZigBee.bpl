// ---------------------------------------------------------------
// -- Types and global variables ---------------------------------
// ---------------------------------------------------------------
type Ref;
type Chan a;
type Field a;
type Actor;
type CType = <a>[Chan a]int;
type MType = <a>[Chan a][int]a;
type Obj = <a>[Field a]a;
type HType = [Ref]Obj;
type ModeType = [Actor]int;

var M#: MType;
var C#: CType;
var R#: CType;
var I#: CType;
var B#: CType;
var Mode#: ModeType;
var I#sub: CType;

var H#: HType;

const unique this#: Actor;

function AT#Min(x:int, y: int): int { if x <= y then x else y }

// ---------------------------------------------------------------
// -- Axiomatisation for map data type ---------------------------
// ---------------------------------------------------------------
type Map a b;

function Map#Select<T,U>(Map T U, T): U;
function Map#Store<T,U>(Map T U, T, U): Map T U;
axiom (
  forall<T,U> m: Map T U, k1: T, val: U :: { Map#Store(m,k1,val) }
    Map#Select(Map#Store(m,k1,val),k1) == val
);
axiom (
  forall<T,U> m: Map T U, k1: T, k2: T, val: U :: { Map#Select(Map#Store(m,k1,val),k2) }
    k1 != k2 ==> Map#Select(Map#Store(m,k1,val),k2) == Map#Select(m,k2)
);

// ---------------------------------------------------------------
// -- Bit vector operations --------------------------------------
// ---------------------------------------------------------------
// Size: 8
function {:bvbuiltin "bvand"} AT#BvAnd8(a: bv8, b: bv8): bv8;
function {:bvbuiltin "bvor"} AT#BvOr8(a: bv8, b: bv8): bv8;
function {:bvbuiltin "bvnot"} AT#BvNot8(a: bv8): bv8;
function {:bvbuiltin "bvneg"} AT#BvNeg8(a: bv8): bv8;
function {:bvbuiltin "bvadd"} AT#BvAdd8(a: bv8, b: bv8): bv8;
function {:bvbuiltin "bvsub"} AT#BvSub8(a: bv8, b: bv8): bv8;
function {:bvbuiltin "bvmul"} AT#BvMul8(a: bv8, b: bv8): bv8;
function {:bvbuiltin "bvsdiv"} AT#BvSdiv8(a: bv8, b: bv8): bv8;
function {:bvbuiltin "bvudiv"} AT#BvUdiv8(a: bv8, b: bv8): bv8;
function {:bvbuiltin "bvshl"} AT#BvShl8(bv8,bv8): bv8;
function {:bvbuiltin "bvlshr"} AT#BvLshr8(bv8,bv8): bv8;
function {:bvbuiltin "bvashr"} AT#BvAshr8(bv8,bv8): bv8;
function {:bvbuiltin "bvule"} AT#BvUle8(a: bv8, b: bv8): bool;
function {:bvbuiltin "bvult"} AT#BvUlt8(a: bv8, b: bv8): bool;
function {:bvbuiltin "bvuge"} AT#BvUge8(a: bv8, b: bv8): bool;
function {:bvbuiltin "bvugt"} AT#BvUgt8(a: bv8, b: bv8): bool;
function {:bvbuiltin "bvsle"} AT#BvSle8(a: bv8, b: bv8): bool;
function {:bvbuiltin "bvslt"} AT#BvSlt8(a: bv8, b: bv8): bool;
function {:bvbuiltin "bvsge"} AT#BvSge8(a: bv8, b: bv8): bool;
function {:bvbuiltin "bvsgt"} AT#BvSgt8(a: bv8, b: bv8): bool;
function AT#BvXor8(a: bv8, b: bv8): bv8;
function AT#BvAbs8(a: bv8): bv8;

axiom (forall a,b: bv8 :: AT#BvXor8(a,b) == AT#BvAnd8(AT#BvOr8(a,b), AT#BvNot8(AT#BvAnd8(a,b))) );
axiom (forall a,b: bv8 :: AT#BvAbs8(a) == (if AT#BvSle8(0bv8,a) then a else AT#BvNeg8(a)) );

// ---------------------------------------------------------------
// -- Bit vector operations --------------------------------------
// ---------------------------------------------------------------
// Size: 14
function {:bvbuiltin "bvand"} AT#BvAnd14(a: bv14, b: bv14): bv14;
function {:bvbuiltin "bvor"} AT#BvOr14(a: bv14, b: bv14): bv14;
function {:bvbuiltin "bvnot"} AT#BvNot14(a: bv14): bv14;
function {:bvbuiltin "bvneg"} AT#BvNeg14(a: bv14): bv14;
function {:bvbuiltin "bvadd"} AT#BvAdd14(a: bv14, b: bv14): bv14;
function {:bvbuiltin "bvsub"} AT#BvSub14(a: bv14, b: bv14): bv14;
function {:bvbuiltin "bvmul"} AT#BvMul14(a: bv14, b: bv14): bv14;
function {:bvbuiltin "bvsdiv"} AT#BvSdiv14(a: bv14, b: bv14): bv14;
function {:bvbuiltin "bvudiv"} AT#BvUdiv14(a: bv14, b: bv14): bv14;
function {:bvbuiltin "bvshl"} AT#BvShl14(bv14,bv14): bv14;
function {:bvbuiltin "bvlshr"} AT#BvLshr14(bv14,bv14): bv14;
function {:bvbuiltin "bvashr"} AT#BvAshr14(bv14,bv14): bv14;
function {:bvbuiltin "bvule"} AT#BvUle14(a: bv14, b: bv14): bool;
function {:bvbuiltin "bvult"} AT#BvUlt14(a: bv14, b: bv14): bool;
function {:bvbuiltin "bvuge"} AT#BvUge14(a: bv14, b: bv14): bool;
function {:bvbuiltin "bvugt"} AT#BvUgt14(a: bv14, b: bv14): bool;
function {:bvbuiltin "bvsle"} AT#BvSle14(a: bv14, b: bv14): bool;
function {:bvbuiltin "bvslt"} AT#BvSlt14(a: bv14, b: bv14): bool;
function {:bvbuiltin "bvsge"} AT#BvSge14(a: bv14, b: bv14): bool;
function {:bvbuiltin "bvsgt"} AT#BvSgt14(a: bv14, b: bv14): bool;
function AT#BvXor14(a: bv14, b: bv14): bv14;
function AT#BvAbs14(a: bv14): bv14;

axiom (forall a,b: bv14 :: AT#BvXor14(a,b) == AT#BvAnd14(AT#BvOr14(a,b), AT#BvNot14(AT#BvAnd14(a,b))) );
axiom (forall a,b: bv14 :: AT#BvAbs14(a) == (if AT#BvSle14(0bv14,a) then a else AT#BvNeg14(a)) );

// ---------------------------------------------------------------
// -- Bit vector operations --------------------------------------
// ---------------------------------------------------------------
// Size: 32
function {:bvbuiltin "bvand"} AT#BvAnd32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvor"} AT#BvOr32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvnot"} AT#BvNot32(a: bv32): bv32;
function {:bvbuiltin "bvneg"} AT#BvNeg32(a: bv32): bv32;
function {:bvbuiltin "bvadd"} AT#BvAdd32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvsub"} AT#BvSub32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvmul"} AT#BvMul32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvsdiv"} AT#BvSdiv32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvudiv"} AT#BvUdiv32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvshl"} AT#BvShl32(bv32,bv32): bv32;
function {:bvbuiltin "bvlshr"} AT#BvLshr32(bv32,bv32): bv32;
function {:bvbuiltin "bvashr"} AT#BvAshr32(bv32,bv32): bv32;
function {:bvbuiltin "bvule"} AT#BvUle32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvult"} AT#BvUlt32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvuge"} AT#BvUge32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvugt"} AT#BvUgt32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvsle"} AT#BvSle32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvslt"} AT#BvSlt32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvsge"} AT#BvSge32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvsgt"} AT#BvSgt32(a: bv32, b: bv32): bool;
function AT#BvXor32(a: bv32, b: bv32): bv32;
function AT#BvAbs32(a: bv32): bv32;

axiom (forall a,b: bv32 :: AT#BvXor32(a,b) == AT#BvAnd32(AT#BvOr32(a,b), AT#BvNot32(AT#BvAnd32(a,b))) );
axiom (forall a,b: bv32 :: AT#BvAbs32(a) == (if AT#BvSle32(0bv32,a) then a else AT#BvNeg32(a)) );

// ---------------------------------------------------------------
// -- Bitvector to integer ---------------------------------------
// ---------------------------------------------------------------
// Size: 8
function AT#Bit0bv8(vec: bv8): bool { AT#BvAnd8(vec,1bv8) != 0bv8 }
function AT#Bit1bv8(vec: bv8): bool { AT#BvAnd8(vec,2bv8) != 0bv8 }
function AT#Bit2bv8(vec: bv8): bool { AT#BvAnd8(vec,4bv8) != 0bv8 }
function AT#Bit3bv8(vec: bv8): bool { AT#BvAnd8(vec,8bv8) != 0bv8 }
function AT#Bit4bv8(vec: bv8): bool { AT#BvAnd8(vec,16bv8) != 0bv8 }
function AT#Bit5bv8(vec: bv8): bool { AT#BvAnd8(vec,32bv8) != 0bv8 }
function AT#Bit6bv8(vec: bv8): bool { AT#BvAnd8(vec,64bv8) != 0bv8 }
function AT#Bit7bv8(vec: bv8): bool { AT#BvAnd8(vec,128bv8) != 0bv8 }

function AT#Bv2Int8(vec: bv8): int {
  (if AT#Bit0bv8(vec) then 1 else 0) +
  (if AT#Bit1bv8(vec) then 2 else 0) +
  (if AT#Bit2bv8(vec) then 4 else 0) +
  (if AT#Bit3bv8(vec) then 8 else 0) +
  (if AT#Bit4bv8(vec) then 16 else 0) +
  (if AT#Bit5bv8(vec) then 32 else 0) +
  (if AT#Bit6bv8(vec) then 64 else 0) +
  (if AT#Bit7bv8(vec) then 128 else 0)
}

// ---------------------------------------------------------------
// -- Bitvector to integer ---------------------------------------
// ---------------------------------------------------------------
// Size: 14
function AT#Bit0bv14(vec: bv14): bool { AT#BvAnd14(vec,1bv14) != 0bv14 }
function AT#Bit1bv14(vec: bv14): bool { AT#BvAnd14(vec,2bv14) != 0bv14 }
function AT#Bit2bv14(vec: bv14): bool { AT#BvAnd14(vec,4bv14) != 0bv14 }
function AT#Bit3bv14(vec: bv14): bool { AT#BvAnd14(vec,8bv14) != 0bv14 }
function AT#Bit4bv14(vec: bv14): bool { AT#BvAnd14(vec,16bv14) != 0bv14 }
function AT#Bit5bv14(vec: bv14): bool { AT#BvAnd14(vec,32bv14) != 0bv14 }
function AT#Bit6bv14(vec: bv14): bool { AT#BvAnd14(vec,64bv14) != 0bv14 }
function AT#Bit7bv14(vec: bv14): bool { AT#BvAnd14(vec,128bv14) != 0bv14 }
function AT#Bit8bv14(vec: bv14): bool { AT#BvAnd14(vec,256bv14) != 0bv14 }
function AT#Bit9bv14(vec: bv14): bool { AT#BvAnd14(vec,512bv14) != 0bv14 }
function AT#Bit10bv14(vec: bv14): bool { AT#BvAnd14(vec,1024bv14) != 0bv14 }
function AT#Bit11bv14(vec: bv14): bool { AT#BvAnd14(vec,2048bv14) != 0bv14 }
function AT#Bit12bv14(vec: bv14): bool { AT#BvAnd14(vec,4096bv14) != 0bv14 }
function AT#Bit13bv14(vec: bv14): bool { AT#BvAnd14(vec,8192bv14) != 0bv14 }

function AT#Bv2Int14(vec: bv14): int {
  (if AT#Bit0bv14(vec) then 1 else 0) +
  (if AT#Bit1bv14(vec) then 2 else 0) +
  (if AT#Bit2bv14(vec) then 4 else 0) +
  (if AT#Bit3bv14(vec) then 8 else 0) +
  (if AT#Bit4bv14(vec) then 16 else 0) +
  (if AT#Bit5bv14(vec) then 32 else 0) +
  (if AT#Bit6bv14(vec) then 64 else 0) +
  (if AT#Bit7bv14(vec) then 128 else 0) +
  (if AT#Bit8bv14(vec) then 256 else 0) +
  (if AT#Bit9bv14(vec) then 512 else 0) +
  (if AT#Bit10bv14(vec) then 1024 else 0) +
  (if AT#Bit11bv14(vec) then 2048 else 0) +
  (if AT#Bit12bv14(vec) then 4096 else 0) +
  (if AT#Bit13bv14(vec) then 8192 else 0)
}

// ---------------------------------------------------------------
// -- End of prelude ---------------------------------------------
// ---------------------------------------------------------------

procedure chipMapper#init#0()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var data: Chan (bv8);
  var chip: Chan (bv32);
  var Chip_map_table: Map (bv8) (bv32);
  var lsn: bv8;
  var msn: bv8;
  assume true;
  assume (I#[data] == 0) && (R#[data] == 0) && (C#[data] == 0);
  assume (I#[chip] == 0) && (R#[chip] == 0) && (C#[chip] == 0);
}
procedure chipMapper#anon$0#1()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var data: Chan (bv8);
  var chip: Chan (bv32);
  var Chip_map_table: Map (bv8) (bv32);
  var lsn: bv8;
  var msn: bv8;
  var data#0: bv8;
  assume true;
  assume (0 <= I#[data]) && (I#[data] <= R#[data]) && (R#[data] <= C#[data]);
  assume (0 <= I#[chip]) && (I#[chip] <= R#[chip]) && (R#[chip] <= C#[chip]);
  assume (2 * R#[data]) == C#[chip];
  assume 1 <= (C#[data] - R#[data]);
  data#0 := M#[data][R#[data]];
  R#[data] := R#[data] + 1;
  assume true;
  lsn := AT#BvAnd8(data#0, 15bv8);
  msn := AT#BvAnd8(AT#BvLshr8(data#0, 4bv8), 15bv8);
  M#[chip][C#[chip]] := Map#Select(Chip_map_table, lsn);
  C#[chip] := C#[chip] + 1;
  M#[chip][C#[chip]] := Map#Select(Chip_map_table, msn);
  C#[chip] := C#[chip] + 1;
}
procedure headerAdd#init#2()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pl_bits: Chan (bv8);
  var St_in: Chan (int);
  var octet_count_in: Chan (bv8);
  var octet_index_in: Chan (bv8);
  var data: Chan (bv8);
  var len: Chan (bv8);
  var St_out: Chan (int);
  var octet_count_out: Chan (bv8);
  var octet_index_out: Chan (bv8);
  var octet_count: bv8;
  var octet_index: bv8;
  var HEADER_LEN: bv8;
  var Header: Map (bv8) (bv8);
  var data_out: bv8;
  assume (pl_bits != octet_count_in) && (pl_bits != octet_index_in) && (pl_bits != data) && (pl_bits != len) && (pl_bits != octet_count_out) && (pl_bits != octet_index_out) && (St_in != St_out) && (octet_count_in != octet_index_in) && (octet_count_in != data) && (octet_count_in != len) && (octet_count_in != octet_count_out) && (octet_count_in != octet_index_out) && (octet_index_in != data) && (octet_index_in != len) && (octet_index_in != octet_count_out) && (octet_index_in != octet_index_out) && (data != len) && (data != octet_count_out) && (data != octet_index_out) && (len != octet_count_out) && (len != octet_index_out) && (octet_count_out != octet_index_out);
  assume (I#[pl_bits] == 0) && (R#[pl_bits] == 0) && (C#[pl_bits] == 0);
  assume (I#[St_in] == 0) && (R#[St_in] == 0) && (C#[St_in] == 0);
  assume (I#[octet_count_in] == 0) && (R#[octet_count_in] == 0) && (C#[octet_count_in] == 0);
  assume (I#[octet_index_in] == 0) && (R#[octet_index_in] == 0) && (C#[octet_index_in] == 0);
  assume (I#[data] == 0) && (R#[data] == 0) && (C#[data] == 0);
  assume (I#[len] == 0) && (R#[len] == 0) && (C#[len] == 0);
  assume (I#[St_out] == 0) && (R#[St_out] == 0) && (C#[St_out] == 0);
  assume (I#[octet_count_out] == 0) && (R#[octet_count_out] == 0) && (C#[octet_count_out] == 0);
  assume (I#[octet_index_out] == 0) && (R#[octet_index_out] == 0) && (C#[octet_index_out] == 0);
  M#[octet_index_out][C#[octet_index_out]] := 0bv8;
  C#[octet_index_out] := C#[octet_index_out] + 1;
  M#[octet_count_out][C#[octet_count_out]] := 0bv8;
  C#[octet_count_out] := C#[octet_count_out] + 1;
  M#[St_out][C#[St_out]] := 0;
  C#[St_out] := C#[St_out] + 1;
}
procedure headerAdd#get_data_len#3()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pl_bits: Chan (bv8);
  var St_in: Chan (int);
  var octet_count_in: Chan (bv8);
  var octet_index_in: Chan (bv8);
  var data: Chan (bv8);
  var len: Chan (bv8);
  var St_out: Chan (int);
  var octet_count_out: Chan (bv8);
  var octet_index_out: Chan (bv8);
  var octet_count: bv8;
  var octet_index: bv8;
  var HEADER_LEN: bv8;
  var Header: Map (bv8) (bv8);
  var data_out: bv8;
  var pl_bits#0: bv8;
  var octet_index_in#0: bv8;
  var octet_count_in#0: bv8;
  var St_in#0: int;
  assume (pl_bits != octet_count_in) && (pl_bits != octet_index_in) && (pl_bits != data) && (pl_bits != len) && (pl_bits != octet_count_out) && (pl_bits != octet_index_out) && (St_in != St_out) && (octet_count_in != octet_index_in) && (octet_count_in != data) && (octet_count_in != len) && (octet_count_in != octet_count_out) && (octet_count_in != octet_index_out) && (octet_index_in != data) && (octet_index_in != len) && (octet_index_in != octet_count_out) && (octet_index_in != octet_index_out) && (data != len) && (data != octet_count_out) && (data != octet_index_out) && (len != octet_count_out) && (len != octet_index_out) && (octet_count_out != octet_index_out);
  assume (0 <= I#[pl_bits]) && (I#[pl_bits] <= R#[pl_bits]) && (R#[pl_bits] <= C#[pl_bits]);
  assume (0 <= I#[St_in]) && (I#[St_in] <= R#[St_in]) && (R#[St_in] <= C#[St_in]);
  assume (0 <= I#[octet_count_in]) && (I#[octet_count_in] <= R#[octet_count_in]) && (R#[octet_count_in] <= C#[octet_count_in]);
  assume (0 <= I#[octet_index_in]) && (I#[octet_index_in] <= R#[octet_index_in]) && (R#[octet_index_in] <= C#[octet_index_in]);
  assume (0 <= I#[data]) && (I#[data] <= R#[data]) && (R#[data] <= C#[data]);
  assume (0 <= I#[len]) && (I#[len] <= R#[len]) && (R#[len] <= C#[len]);
  assume (0 <= I#[St_out]) && (I#[St_out] <= R#[St_out]) && (R#[St_out] <= C#[St_out]);
  assume (0 <= I#[octet_count_out]) && (I#[octet_count_out] <= R#[octet_count_out]) && (R#[octet_count_out] <= C#[octet_count_out]);
  assume (0 <= I#[octet_index_out]) && (I#[octet_index_out] <= R#[octet_index_out]) && (R#[octet_index_out] <= C#[octet_index_out]);
  assume (1 <= (C#[pl_bits] - R#[pl_bits])) && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in]));
  pl_bits#0 := M#[pl_bits][R#[pl_bits]];
  R#[pl_bits] := R#[pl_bits] + 1;
  octet_index_in#0 := M#[octet_index_in][R#[octet_index_in]];
  R#[octet_index_in] := R#[octet_index_in] + 1;
  octet_count_in#0 := M#[octet_count_in][R#[octet_count_in]];
  R#[octet_count_in] := R#[octet_count_in] + 1;
  St_in#0 := M#[St_in][R#[St_in]];
  R#[St_in] := R#[St_in] + 1;
  assume St_in#0 == 0;
  M#[octet_index_out][C#[octet_index_out]] := 0bv8;
  C#[octet_index_out] := C#[octet_index_out] + 1;
  M#[octet_count_out][C#[octet_count_out]] := AT#BvAdd8(AT#BvAdd8(pl_bits#0, 5bv8), 1bv8);
  C#[octet_count_out] := C#[octet_count_out] + 1;
  M#[St_out][C#[St_out]] := 1;
  C#[St_out] := C#[St_out] + 1;
  M#[len][C#[len]] := AT#BvAdd8(AT#BvAdd8(pl_bits#0, 5bv8), 1bv8);
  C#[len] := C#[len] + 1;
}
procedure headerAdd#send_header#4()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pl_bits: Chan (bv8);
  var St_in: Chan (int);
  var octet_count_in: Chan (bv8);
  var octet_index_in: Chan (bv8);
  var data: Chan (bv8);
  var len: Chan (bv8);
  var St_out: Chan (int);
  var octet_count_out: Chan (bv8);
  var octet_index_out: Chan (bv8);
  var octet_count: bv8;
  var octet_index: bv8;
  var HEADER_LEN: bv8;
  var Header: Map (bv8) (bv8);
  var data_out: bv8;
  var pl_bits#0: bv8;
  var octet_index_in#0: bv8;
  var octet_count_in#0: bv8;
  var St_in#0: int;
  assume (pl_bits != octet_count_in) && (pl_bits != octet_index_in) && (pl_bits != data) && (pl_bits != len) && (pl_bits != octet_count_out) && (pl_bits != octet_index_out) && (St_in != St_out) && (octet_count_in != octet_index_in) && (octet_count_in != data) && (octet_count_in != len) && (octet_count_in != octet_count_out) && (octet_count_in != octet_index_out) && (octet_index_in != data) && (octet_index_in != len) && (octet_index_in != octet_count_out) && (octet_index_in != octet_index_out) && (data != len) && (data != octet_count_out) && (data != octet_index_out) && (len != octet_count_out) && (len != octet_index_out) && (octet_count_out != octet_index_out);
  assume (0 <= I#[pl_bits]) && (I#[pl_bits] <= R#[pl_bits]) && (R#[pl_bits] <= C#[pl_bits]);
  assume (0 <= I#[St_in]) && (I#[St_in] <= R#[St_in]) && (R#[St_in] <= C#[St_in]);
  assume (0 <= I#[octet_count_in]) && (I#[octet_count_in] <= R#[octet_count_in]) && (R#[octet_count_in] <= C#[octet_count_in]);
  assume (0 <= I#[octet_index_in]) && (I#[octet_index_in] <= R#[octet_index_in]) && (R#[octet_index_in] <= C#[octet_index_in]);
  assume (0 <= I#[data]) && (I#[data] <= R#[data]) && (R#[data] <= C#[data]);
  assume (0 <= I#[len]) && (I#[len] <= R#[len]) && (R#[len] <= C#[len]);
  assume (0 <= I#[St_out]) && (I#[St_out] <= R#[St_out]) && (R#[St_out] <= C#[St_out]);
  assume (0 <= I#[octet_count_out]) && (I#[octet_count_out] <= R#[octet_count_out]) && (R#[octet_count_out] <= C#[octet_count_out]);
  assume (0 <= I#[octet_index_out]) && (I#[octet_index_out] <= R#[octet_index_out]) && (R#[octet_index_out] <= C#[octet_index_out]);
  assume (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in]));
  octet_index_in#0 := M#[octet_index_in][R#[octet_index_in]];
  R#[octet_index_in] := R#[octet_index_in] + 1;
  octet_count_in#0 := M#[octet_count_in][R#[octet_count_in]];
  R#[octet_count_in] := R#[octet_count_in] + 1;
  St_in#0 := M#[St_in][R#[St_in]];
  R#[St_in] := R#[St_in] + 1;
  assume AT#BvUlt8(octet_index_in#0, 5bv8) && (St_in#0 == 1);
  data_out := Map#Select(Header, octet_index_in#0);
  M#[St_out][C#[St_out]] := 1;
  C#[St_out] := C#[St_out] + 1;
  M#[octet_index_out][C#[octet_index_out]] := AT#BvAdd8(octet_index_in#0, 1bv8);
  C#[octet_index_out] := C#[octet_index_out] + 1;
  M#[octet_count_out][C#[octet_count_out]] := octet_count_in#0;
  C#[octet_count_out] := C#[octet_count_out] + 1;
  M#[data][C#[data]] := data_out;
  C#[data] := C#[data] + 1;
}
procedure headerAdd#send_length#5()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pl_bits: Chan (bv8);
  var St_in: Chan (int);
  var octet_count_in: Chan (bv8);
  var octet_index_in: Chan (bv8);
  var data: Chan (bv8);
  var len: Chan (bv8);
  var St_out: Chan (int);
  var octet_count_out: Chan (bv8);
  var octet_index_out: Chan (bv8);
  var octet_count: bv8;
  var octet_index: bv8;
  var HEADER_LEN: bv8;
  var Header: Map (bv8) (bv8);
  var data_out: bv8;
  var pl_bits#0: bv8;
  var octet_index_in#0: bv8;
  var octet_count_in#0: bv8;
  var St_in#0: int;
  assume (pl_bits != octet_count_in) && (pl_bits != octet_index_in) && (pl_bits != data) && (pl_bits != len) && (pl_bits != octet_count_out) && (pl_bits != octet_index_out) && (St_in != St_out) && (octet_count_in != octet_index_in) && (octet_count_in != data) && (octet_count_in != len) && (octet_count_in != octet_count_out) && (octet_count_in != octet_index_out) && (octet_index_in != data) && (octet_index_in != len) && (octet_index_in != octet_count_out) && (octet_index_in != octet_index_out) && (data != len) && (data != octet_count_out) && (data != octet_index_out) && (len != octet_count_out) && (len != octet_index_out) && (octet_count_out != octet_index_out);
  assume (0 <= I#[pl_bits]) && (I#[pl_bits] <= R#[pl_bits]) && (R#[pl_bits] <= C#[pl_bits]);
  assume (0 <= I#[St_in]) && (I#[St_in] <= R#[St_in]) && (R#[St_in] <= C#[St_in]);
  assume (0 <= I#[octet_count_in]) && (I#[octet_count_in] <= R#[octet_count_in]) && (R#[octet_count_in] <= C#[octet_count_in]);
  assume (0 <= I#[octet_index_in]) && (I#[octet_index_in] <= R#[octet_index_in]) && (R#[octet_index_in] <= C#[octet_index_in]);
  assume (0 <= I#[data]) && (I#[data] <= R#[data]) && (R#[data] <= C#[data]);
  assume (0 <= I#[len]) && (I#[len] <= R#[len]) && (R#[len] <= C#[len]);
  assume (0 <= I#[St_out]) && (I#[St_out] <= R#[St_out]) && (R#[St_out] <= C#[St_out]);
  assume (0 <= I#[octet_count_out]) && (I#[octet_count_out] <= R#[octet_count_out]) && (R#[octet_count_out] <= C#[octet_count_out]);
  assume (0 <= I#[octet_index_out]) && (I#[octet_index_out] <= R#[octet_index_out]) && (R#[octet_index_out] <= C#[octet_index_out]);
  assume (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in]));
  octet_index_in#0 := M#[octet_index_in][R#[octet_index_in]];
  R#[octet_index_in] := R#[octet_index_in] + 1;
  octet_count_in#0 := M#[octet_count_in][R#[octet_count_in]];
  R#[octet_count_in] := R#[octet_count_in] + 1;
  St_in#0 := M#[St_in][R#[St_in]];
  R#[St_in] := R#[St_in] + 1;
  assume (octet_index_in#0 == 5bv8) && (St_in#0 == 1);
  M#[St_out][C#[St_out]] := 2;
  C#[St_out] := C#[St_out] + 1;
  M#[octet_index_out][C#[octet_index_out]] := AT#BvAdd8(octet_index_in#0, 1bv8);
  C#[octet_index_out] := C#[octet_index_out] + 1;
  M#[octet_count_out][C#[octet_count_out]] := octet_count_in#0;
  C#[octet_count_out] := C#[octet_count_out] + 1;
  M#[data][C#[data]] := AT#BvSub8(AT#BvSub8(octet_count_in#0, 5bv8), 1bv8);
  C#[data] := C#[data] + 1;
}
procedure headerAdd#send_payload_octet#6()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pl_bits: Chan (bv8);
  var St_in: Chan (int);
  var octet_count_in: Chan (bv8);
  var octet_index_in: Chan (bv8);
  var data: Chan (bv8);
  var len: Chan (bv8);
  var St_out: Chan (int);
  var octet_count_out: Chan (bv8);
  var octet_index_out: Chan (bv8);
  var octet_count: bv8;
  var octet_index: bv8;
  var HEADER_LEN: bv8;
  var Header: Map (bv8) (bv8);
  var data_out: bv8;
  var pl_bits#0: bv8;
  var octet_index_in#0: bv8;
  var octet_count_in#0: bv8;
  var St_in#0: int;
  assume (pl_bits != octet_count_in) && (pl_bits != octet_index_in) && (pl_bits != data) && (pl_bits != len) && (pl_bits != octet_count_out) && (pl_bits != octet_index_out) && (St_in != St_out) && (octet_count_in != octet_index_in) && (octet_count_in != data) && (octet_count_in != len) && (octet_count_in != octet_count_out) && (octet_count_in != octet_index_out) && (octet_index_in != data) && (octet_index_in != len) && (octet_index_in != octet_count_out) && (octet_index_in != octet_index_out) && (data != len) && (data != octet_count_out) && (data != octet_index_out) && (len != octet_count_out) && (len != octet_index_out) && (octet_count_out != octet_index_out);
  assume (0 <= I#[pl_bits]) && (I#[pl_bits] <= R#[pl_bits]) && (R#[pl_bits] <= C#[pl_bits]);
  assume (0 <= I#[St_in]) && (I#[St_in] <= R#[St_in]) && (R#[St_in] <= C#[St_in]);
  assume (0 <= I#[octet_count_in]) && (I#[octet_count_in] <= R#[octet_count_in]) && (R#[octet_count_in] <= C#[octet_count_in]);
  assume (0 <= I#[octet_index_in]) && (I#[octet_index_in] <= R#[octet_index_in]) && (R#[octet_index_in] <= C#[octet_index_in]);
  assume (0 <= I#[data]) && (I#[data] <= R#[data]) && (R#[data] <= C#[data]);
  assume (0 <= I#[len]) && (I#[len] <= R#[len]) && (R#[len] <= C#[len]);
  assume (0 <= I#[St_out]) && (I#[St_out] <= R#[St_out]) && (R#[St_out] <= C#[St_out]);
  assume (0 <= I#[octet_count_out]) && (I#[octet_count_out] <= R#[octet_count_out]) && (R#[octet_count_out] <= C#[octet_count_out]);
  assume (0 <= I#[octet_index_out]) && (I#[octet_index_out] <= R#[octet_index_out]) && (R#[octet_index_out] <= C#[octet_index_out]);
  assume (1 <= (C#[pl_bits] - R#[pl_bits])) && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in]));
  pl_bits#0 := M#[pl_bits][R#[pl_bits]];
  R#[pl_bits] := R#[pl_bits] + 1;
  octet_index_in#0 := M#[octet_index_in][R#[octet_index_in]];
  R#[octet_index_in] := R#[octet_index_in] + 1;
  octet_count_in#0 := M#[octet_count_in][R#[octet_count_in]];
  R#[octet_count_in] := R#[octet_count_in] + 1;
  St_in#0 := M#[St_in][R#[St_in]];
  R#[St_in] := R#[St_in] + 1;
  assume AT#BvUlt8(octet_index_in#0, octet_count_in#0) && (St_in#0 == 2);
  M#[St_out][C#[St_out]] := (if AT#BvAdd8(octet_index_in#0, 1bv8) == octet_count_in#0 then 0 else 2);
  C#[St_out] := C#[St_out] + 1;
  M#[octet_index_out][C#[octet_index_out]] := AT#BvAdd8(octet_index_in#0, 1bv8);
  C#[octet_index_out] := C#[octet_index_out] + 1;
  M#[octet_count_out][C#[octet_count_out]] := octet_count_in#0;
  C#[octet_count_out] := C#[octet_count_out] + 1;
  M#[data][C#[data]] := pl_bits#0;
  C#[data] := C#[data] + 1;
}
procedure headerAdd##GuardWD#7()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pl_bits: Chan (bv8);
  var St_in: Chan (int);
  var octet_count_in: Chan (bv8);
  var octet_index_in: Chan (bv8);
  var data: Chan (bv8);
  var len: Chan (bv8);
  var St_out: Chan (int);
  var octet_count_out: Chan (bv8);
  var octet_index_out: Chan (bv8);
  var octet_count: bv8;
  var octet_index: bv8;
  var HEADER_LEN: bv8;
  var Header: Map (bv8) (bv8);
  var data_out: bv8;
  var pl_bits#0: bv8;
  var octet_index_in#0: bv8;
  var octet_count_in#0: bv8;
  var St_in#0: int;
  assume (pl_bits != octet_count_in) && (pl_bits != octet_index_in) && (pl_bits != data) && (pl_bits != len) && (pl_bits != octet_count_out) && (pl_bits != octet_index_out) && (St_in != St_out) && (octet_count_in != octet_index_in) && (octet_count_in != data) && (octet_count_in != len) && (octet_count_in != octet_count_out) && (octet_count_in != octet_index_out) && (octet_index_in != data) && (octet_index_in != len) && (octet_index_in != octet_count_out) && (octet_index_in != octet_index_out) && (data != len) && (data != octet_count_out) && (data != octet_index_out) && (len != octet_count_out) && (len != octet_index_out) && (octet_count_out != octet_index_out);
  assert {:msg "ZigBee.actor(31.1): The actions 'get_data_len' and 'send_header' of actor 'headerAdd' might not have mutually exclusive guards (#0)"} !(true && (1 <= (C#[pl_bits] - R#[pl_bits])) && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[St_in][R#[St_in]] == 0) && true && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && AT#BvUlt8(M#[octet_index_in][R#[octet_index_in]], 5bv8) && (M#[St_in][R#[St_in]] == 1));
  assert {:msg "ZigBee.actor(31.1): The actions 'get_data_len' and 'send_length' of actor 'headerAdd' might not have mutually exclusive guards (#1)"} !(true && (1 <= (C#[pl_bits] - R#[pl_bits])) && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[St_in][R#[St_in]] == 0) && true && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[octet_index_in][R#[octet_index_in]] == 5bv8) && (M#[St_in][R#[St_in]] == 1));
  assert {:msg "ZigBee.actor(31.1): The actions 'get_data_len' and 'send_payload_octet' of actor 'headerAdd' might not have mutually exclusive guards (#2)"} !(true && (1 <= (C#[pl_bits] - R#[pl_bits])) && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[St_in][R#[St_in]] == 0) && true && (1 <= (C#[pl_bits] - R#[pl_bits])) && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && AT#BvUlt8(M#[octet_index_in][R#[octet_index_in]], M#[octet_count_in][R#[octet_count_in]]) && (M#[St_in][R#[St_in]] == 2));
  assert {:msg "ZigBee.actor(31.1): The actions 'send_header' and 'send_length' of actor 'headerAdd' might not have mutually exclusive guards (#3)"} !(true && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && AT#BvUlt8(M#[octet_index_in][R#[octet_index_in]], 5bv8) && (M#[St_in][R#[St_in]] == 1) && true && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[octet_index_in][R#[octet_index_in]] == 5bv8) && (M#[St_in][R#[St_in]] == 1));
  assert {:msg "ZigBee.actor(31.1): The actions 'send_header' and 'send_payload_octet' of actor 'headerAdd' might not have mutually exclusive guards (#4)"} !(true && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && AT#BvUlt8(M#[octet_index_in][R#[octet_index_in]], 5bv8) && (M#[St_in][R#[St_in]] == 1) && true && (1 <= (C#[pl_bits] - R#[pl_bits])) && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && AT#BvUlt8(M#[octet_index_in][R#[octet_index_in]], M#[octet_count_in][R#[octet_count_in]]) && (M#[St_in][R#[St_in]] == 2));
  assert {:msg "ZigBee.actor(31.1): The actions 'send_length' and 'send_payload_octet' of actor 'headerAdd' might not have mutually exclusive guards (#5)"} !(true && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[octet_index_in][R#[octet_index_in]] == 5bv8) && (M#[St_in][R#[St_in]] == 1) && true && (1 <= (C#[pl_bits] - R#[pl_bits])) && (1 <= (C#[octet_index_in] - R#[octet_index_in])) && (1 <= (C#[octet_count_in] - R#[octet_count_in])) && (1 <= (C#[St_in] - R#[St_in])) && AT#BvUlt8(M#[octet_index_in][R#[octet_index_in]], M#[octet_count_in][R#[octet_count_in]]) && (M#[St_in][R#[St_in]] == 2));
}
procedure headerAddNw#init#8()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var headerAddNw#a: Actor;
  var headerAddNw#input: Chan (bv8);
  var headerAddNw#octet_count: Chan (bv8);
  var headerAddNw#octet_index: Chan (bv8);
  var headerAddNw#St: Chan (int);
  var headerAddNw#data: Chan (bv8);
  var headerAddNw#len: Chan (bv8);
  var AV#a#octet_count: bv8;
  var AV#a#octet_index: bv8;
  var AV#a#HEADER_LEN: bv8;
  var AV#a#Header: Map (bv8) (bv8);
  var AV#a#data_out: bv8;
  assume (headerAddNw#input != headerAddNw#octet_count) && (headerAddNw#input != headerAddNw#octet_index) && (headerAddNw#input != headerAddNw#data) && (headerAddNw#input != headerAddNw#len) && (headerAddNw#octet_count != headerAddNw#octet_index) && (headerAddNw#octet_count != headerAddNw#data) && (headerAddNw#octet_count != headerAddNw#len) && (headerAddNw#octet_index != headerAddNw#data) && (headerAddNw#octet_index != headerAddNw#len) && (headerAddNw#data != headerAddNw#len);
  assume 0 <= I#[headerAddNw#input];
  assume I#[headerAddNw#input] <= R#[headerAddNw#input];
  assume R#[headerAddNw#input] <= C#[headerAddNw#input];
  assume 0 <= I#[headerAddNw#octet_count];
  assume I#[headerAddNw#octet_count] <= R#[headerAddNw#octet_count];
  assume R#[headerAddNw#octet_count] <= C#[headerAddNw#octet_count];
  assume 0 <= I#[headerAddNw#octet_index];
  assume I#[headerAddNw#octet_index] <= R#[headerAddNw#octet_index];
  assume R#[headerAddNw#octet_index] <= C#[headerAddNw#octet_index];
  assume 0 <= I#[headerAddNw#St];
  assume I#[headerAddNw#St] <= R#[headerAddNw#St];
  assume R#[headerAddNw#St] <= C#[headerAddNw#St];
  assume 0 <= I#[headerAddNw#data];
  assume I#[headerAddNw#data] <= R#[headerAddNw#data];
  assume R#[headerAddNw#data] <= C#[headerAddNw#data];
  assume I#[headerAddNw#data] == R#[headerAddNw#data];
  assume 0 <= I#[headerAddNw#len];
  assume I#[headerAddNw#len] <= R#[headerAddNw#len];
  assume R#[headerAddNw#len] <= C#[headerAddNw#len];
  assume I#[headerAddNw#len] == R#[headerAddNw#len];
  assume (B#[headerAddNw#input] == 4) && (B#[headerAddNw#data] == 9) && (B#[headerAddNw#len] == 1);
  assume C#[headerAddNw#input] == 0;
  assume R#[headerAddNw#input] == 0;
  assume C#[headerAddNw#octet_count] == 0;
  assume R#[headerAddNw#octet_count] == 0;
  assume C#[headerAddNw#octet_index] == 0;
  assume R#[headerAddNw#octet_index] == 0;
  assume C#[headerAddNw#St] == 0;
  assume R#[headerAddNw#St] == 0;
  assume C#[headerAddNw#data] == 0;
  assume R#[headerAddNw#data] == 0;
  assume C#[headerAddNw#len] == 0;
  assume R#[headerAddNw#len] == 0;
  M#[headerAddNw#octet_index][C#[headerAddNw#octet_index]] := 0bv8;
  C#[headerAddNw#octet_index] := C#[headerAddNw#octet_index] + 1;
  M#[headerAddNw#octet_count][C#[headerAddNw#octet_count]] := 0bv8;
  C#[headerAddNw#octet_count] := C#[headerAddNw#octet_count] + 1;
  M#[headerAddNw#St][C#[headerAddNw#St]] := 0;
  C#[headerAddNw#St] := C#[headerAddNw#St] + 1;
  assert {:msg "ZigBee.actor(146.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#6)"} (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assert {:msg "ZigBee.actor(147.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#7)"} I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assert {:msg "ZigBee.actor(150.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#8)"} ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assert {:msg "ZigBee.actor(153.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#9)"} AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(156.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#10)"} (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assert {:msg "ZigBee.actor(158.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#11)"} ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assert {:msg "ZigBee.actor(160.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#12)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(161.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#13)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assert {:msg "ZigBee.actor(162.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#14)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(164.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#15)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assert {:msg "ZigBee.actor(165.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#16)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assert {:msg "ZigBee.actor(167.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#17)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assert {:msg "ZigBee.actor(168.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#18)"} ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assert {:msg "ZigBee.actor(169.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#19)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assert {:msg "ZigBee.actor(171.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#20)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assert {:msg "ZigBee.actor(173.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#21)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assert {:msg "ZigBee.actor(174.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#22)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assert {:msg "ZigBee.actor(176.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#23)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assert {:msg "ZigBee.actor(177.15): Initialization of network 'headerAddNw' might not establish the channel invariant (#24)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  I# := R#;
  assert {:msg "ZigBee.actor(143.13): Initialization of network 'headerAddNw' might not establish the network invariant (#25)"} ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assert {:msg "ZigBee.actor(144.13): Initialization of network 'headerAddNw' might not establish the network invariant (#26)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "Initialization of network 'headerAddNw' might not establish the network invariant: Unread tokens might be left on channel input (#27)"} (C#[headerAddNw#input] - R#[headerAddNw#input]) == 0;
  assert {:msg "Initialization of network 'headerAddNw' might not establish the network invariant: Unread tokens might be left on channel data (#28)"} (C#[headerAddNw#data] - R#[headerAddNw#data]) == 0;
  assert {:msg "Initialization of network 'headerAddNw' might not establish the network invariant: Unread tokens might be left on channel len (#29)"} (C#[headerAddNw#len] - R#[headerAddNw#len]) == 0;
}
procedure headerAddNw##headerAdd#get_data_len#9()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var headerAddNw#a: Actor;
  var headerAddNw#input: Chan (bv8);
  var headerAddNw#octet_count: Chan (bv8);
  var headerAddNw#octet_index: Chan (bv8);
  var headerAddNw#St: Chan (int);
  var headerAddNw#data: Chan (bv8);
  var headerAddNw#len: Chan (bv8);
  var AV#a#octet_count: bv8;
  var AV#a#octet_index: bv8;
  var AV#a#HEADER_LEN: bv8;
  var AV#a#Header: Map (bv8) (bv8);
  var AV#a#data_out: bv8;
  var pl_bits#bits_in: bv8;
  var octet_index_in#octet_index: bv8;
  var octet_count_in#octet_count: bv8;
  var St_in#St: int;
  assume (headerAddNw#input != headerAddNw#octet_count) && (headerAddNw#input != headerAddNw#octet_index) && (headerAddNw#input != headerAddNw#data) && (headerAddNw#input != headerAddNw#len) && (headerAddNw#octet_count != headerAddNw#octet_index) && (headerAddNw#octet_count != headerAddNw#data) && (headerAddNw#octet_count != headerAddNw#len) && (headerAddNw#octet_index != headerAddNw#data) && (headerAddNw#octet_index != headerAddNw#len) && (headerAddNw#data != headerAddNw#len);
  assume 0 <= I#[headerAddNw#input];
  assume I#[headerAddNw#input] <= R#[headerAddNw#input];
  assume R#[headerAddNw#input] <= C#[headerAddNw#input];
  assume 0 <= I#[headerAddNw#octet_count];
  assume I#[headerAddNw#octet_count] <= R#[headerAddNw#octet_count];
  assume R#[headerAddNw#octet_count] <= C#[headerAddNw#octet_count];
  assume 0 <= I#[headerAddNw#octet_index];
  assume I#[headerAddNw#octet_index] <= R#[headerAddNw#octet_index];
  assume R#[headerAddNw#octet_index] <= C#[headerAddNw#octet_index];
  assume 0 <= I#[headerAddNw#St];
  assume I#[headerAddNw#St] <= R#[headerAddNw#St];
  assume R#[headerAddNw#St] <= C#[headerAddNw#St];
  assume 0 <= I#[headerAddNw#data];
  assume I#[headerAddNw#data] <= R#[headerAddNw#data];
  assume R#[headerAddNw#data] <= C#[headerAddNw#data];
  assume I#[headerAddNw#data] == R#[headerAddNw#data];
  assume 0 <= I#[headerAddNw#len];
  assume I#[headerAddNw#len] <= R#[headerAddNw#len];
  assume R#[headerAddNw#len] <= C#[headerAddNw#len];
  assume I#[headerAddNw#len] == R#[headerAddNw#len];
  assume (B#[headerAddNw#input] == 4) && (B#[headerAddNw#data] == 9) && (B#[headerAddNw#len] == 1);
  I#sub[headerAddNw#input] := R#[headerAddNw#input];
  I#sub[headerAddNw#St] := R#[headerAddNw#St];
  I#sub[headerAddNw#octet_count] := R#[headerAddNw#octet_count];
  I#sub[headerAddNw#octet_index] := R#[headerAddNw#octet_index];
  I#sub[headerAddNw#data] := C#[headerAddNw#data];
  I#sub[headerAddNw#len] := C#[headerAddNw#len];
  I#sub[headerAddNw#St] := C#[headerAddNw#St];
  I#sub[headerAddNw#octet_count] := C#[headerAddNw#octet_count];
  I#sub[headerAddNw#octet_index] := C#[headerAddNw#octet_index];
  assume (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assume I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assume ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assume AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assume ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assume ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1);
  assume (C#[headerAddNw#input] - I#[headerAddNw#input]) <= 4;
  assume (1 <= (C#[headerAddNw#input] - R#[headerAddNw#input])) && (1 <= (C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index])) && (1 <= (C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count])) && (1 <= (C#[headerAddNw#St] - R#[headerAddNw#St])) && (M#[headerAddNw#St][R#[headerAddNw#St]] == 0);
  pl_bits#bits_in := M#[headerAddNw#input][R#[headerAddNw#input]];
  R#[headerAddNw#input] := R#[headerAddNw#input] + 1;
  octet_index_in#octet_index := M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]];
  R#[headerAddNw#octet_index] := R#[headerAddNw#octet_index] + 1;
  octet_count_in#octet_count := M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]];
  R#[headerAddNw#octet_count] := R#[headerAddNw#octet_count] + 1;
  St_in#St := M#[headerAddNw#St][R#[headerAddNw#St]];
  R#[headerAddNw#St] := R#[headerAddNw#St] + 1;
  M#[headerAddNw#octet_index][C#[headerAddNw#octet_index]] := 0bv8;
  C#[headerAddNw#octet_index] := C#[headerAddNw#octet_index] + 1;
  M#[headerAddNw#octet_count][C#[headerAddNw#octet_count]] := AT#BvAdd8(AT#BvAdd8(pl_bits#bits_in, 5bv8), 1bv8);
  C#[headerAddNw#octet_count] := C#[headerAddNw#octet_count] + 1;
  M#[headerAddNw#St][C#[headerAddNw#St]] := 1;
  C#[headerAddNw#St] := C#[headerAddNw#St] + 1;
  M#[headerAddNw#len][C#[headerAddNw#len]] := AT#BvAdd8(AT#BvAdd8(pl_bits#bits_in, 5bv8), 1bv8);
  C#[headerAddNw#len] := C#[headerAddNw#len] + 1;
  assert {:msg "ZigBee.actor(146.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#30)"} (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assert {:msg "ZigBee.actor(147.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#31)"} I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assert {:msg "ZigBee.actor(150.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#32)"} ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assert {:msg "ZigBee.actor(153.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#33)"} AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(156.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#34)"} (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assert {:msg "ZigBee.actor(158.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#35)"} ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assert {:msg "ZigBee.actor(160.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#36)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(161.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#37)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assert {:msg "ZigBee.actor(162.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#38)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(164.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#39)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assert {:msg "ZigBee.actor(165.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#40)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assert {:msg "ZigBee.actor(167.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#41)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assert {:msg "ZigBee.actor(168.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#42)"} ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assert {:msg "ZigBee.actor(169.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#43)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assert {:msg "ZigBee.actor(171.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#44)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assert {:msg "ZigBee.actor(173.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#45)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assert {:msg "ZigBee.actor(174.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#46)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assert {:msg "ZigBee.actor(176.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#47)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assert {:msg "ZigBee.actor(177.15): Action at ZigBee.actor(67.2) ('get_data_len') for actor instance 'a' might not preserve the channel invariant (#48)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
}
procedure headerAddNw##headerAdd#send_header#10()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var headerAddNw#a: Actor;
  var headerAddNw#input: Chan (bv8);
  var headerAddNw#octet_count: Chan (bv8);
  var headerAddNw#octet_index: Chan (bv8);
  var headerAddNw#St: Chan (int);
  var headerAddNw#data: Chan (bv8);
  var headerAddNw#len: Chan (bv8);
  var AV#a#octet_count: bv8;
  var AV#a#octet_index: bv8;
  var AV#a#HEADER_LEN: bv8;
  var AV#a#Header: Map (bv8) (bv8);
  var AV#a#data_out: bv8;
  var octet_index_in#octet_index: bv8;
  var octet_count_in#octet_count: bv8;
  var St_in#St: int;
  assume (headerAddNw#input != headerAddNw#octet_count) && (headerAddNw#input != headerAddNw#octet_index) && (headerAddNw#input != headerAddNw#data) && (headerAddNw#input != headerAddNw#len) && (headerAddNw#octet_count != headerAddNw#octet_index) && (headerAddNw#octet_count != headerAddNw#data) && (headerAddNw#octet_count != headerAddNw#len) && (headerAddNw#octet_index != headerAddNw#data) && (headerAddNw#octet_index != headerAddNw#len) && (headerAddNw#data != headerAddNw#len);
  assume 0 <= I#[headerAddNw#input];
  assume I#[headerAddNw#input] <= R#[headerAddNw#input];
  assume R#[headerAddNw#input] <= C#[headerAddNw#input];
  assume 0 <= I#[headerAddNw#octet_count];
  assume I#[headerAddNw#octet_count] <= R#[headerAddNw#octet_count];
  assume R#[headerAddNw#octet_count] <= C#[headerAddNw#octet_count];
  assume 0 <= I#[headerAddNw#octet_index];
  assume I#[headerAddNw#octet_index] <= R#[headerAddNw#octet_index];
  assume R#[headerAddNw#octet_index] <= C#[headerAddNw#octet_index];
  assume 0 <= I#[headerAddNw#St];
  assume I#[headerAddNw#St] <= R#[headerAddNw#St];
  assume R#[headerAddNw#St] <= C#[headerAddNw#St];
  assume 0 <= I#[headerAddNw#data];
  assume I#[headerAddNw#data] <= R#[headerAddNw#data];
  assume R#[headerAddNw#data] <= C#[headerAddNw#data];
  assume I#[headerAddNw#data] == R#[headerAddNw#data];
  assume 0 <= I#[headerAddNw#len];
  assume I#[headerAddNw#len] <= R#[headerAddNw#len];
  assume R#[headerAddNw#len] <= C#[headerAddNw#len];
  assume I#[headerAddNw#len] == R#[headerAddNw#len];
  assume (B#[headerAddNw#input] == 4) && (B#[headerAddNw#data] == 9) && (B#[headerAddNw#len] == 1);
  I#sub[headerAddNw#input] := R#[headerAddNw#input];
  I#sub[headerAddNw#St] := R#[headerAddNw#St];
  I#sub[headerAddNw#octet_count] := R#[headerAddNw#octet_count];
  I#sub[headerAddNw#octet_index] := R#[headerAddNw#octet_index];
  I#sub[headerAddNw#data] := C#[headerAddNw#data];
  I#sub[headerAddNw#len] := C#[headerAddNw#len];
  I#sub[headerAddNw#St] := C#[headerAddNw#St];
  I#sub[headerAddNw#octet_count] := C#[headerAddNw#octet_count];
  I#sub[headerAddNw#octet_index] := C#[headerAddNw#octet_index];
  assume (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assume I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assume ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assume AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assume ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assume ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1);
  assume (C#[headerAddNw#input] - I#[headerAddNw#input]) <= 4;
  assume (1 <= (C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index])) && (1 <= (C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count])) && (1 <= (C#[headerAddNw#St] - R#[headerAddNw#St])) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8) && (M#[headerAddNw#St][R#[headerAddNw#St]] == 1);
  octet_index_in#octet_index := M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]];
  R#[headerAddNw#octet_index] := R#[headerAddNw#octet_index] + 1;
  octet_count_in#octet_count := M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]];
  R#[headerAddNw#octet_count] := R#[headerAddNw#octet_count] + 1;
  St_in#St := M#[headerAddNw#St][R#[headerAddNw#St]];
  R#[headerAddNw#St] := R#[headerAddNw#St] + 1;
  havoc AV#a#data_out;
  M#[headerAddNw#St][C#[headerAddNw#St]] := 1;
  C#[headerAddNw#St] := C#[headerAddNw#St] + 1;
  M#[headerAddNw#octet_index][C#[headerAddNw#octet_index]] := AT#BvAdd8(octet_index_in#octet_index, 1bv8);
  C#[headerAddNw#octet_index] := C#[headerAddNw#octet_index] + 1;
  M#[headerAddNw#octet_count][C#[headerAddNw#octet_count]] := octet_count_in#octet_count;
  C#[headerAddNw#octet_count] := C#[headerAddNw#octet_count] + 1;
  M#[headerAddNw#data][C#[headerAddNw#data]] := AV#a#data_out;
  C#[headerAddNw#data] := C#[headerAddNw#data] + 1;
  assert {:msg "ZigBee.actor(146.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#49)"} (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assert {:msg "ZigBee.actor(147.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#50)"} I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assert {:msg "ZigBee.actor(150.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#51)"} ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assert {:msg "ZigBee.actor(153.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#52)"} AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(156.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#53)"} (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assert {:msg "ZigBee.actor(158.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#54)"} ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assert {:msg "ZigBee.actor(160.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#55)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(161.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#56)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assert {:msg "ZigBee.actor(162.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#57)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(164.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#58)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assert {:msg "ZigBee.actor(165.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#59)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assert {:msg "ZigBee.actor(167.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#60)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assert {:msg "ZigBee.actor(168.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#61)"} ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assert {:msg "ZigBee.actor(169.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#62)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assert {:msg "ZigBee.actor(171.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#63)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assert {:msg "ZigBee.actor(173.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#64)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assert {:msg "ZigBee.actor(174.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#65)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assert {:msg "ZigBee.actor(176.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#66)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assert {:msg "ZigBee.actor(177.15): Action at ZigBee.actor(83.2) ('send_header') for actor instance 'a' might not preserve the channel invariant (#67)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
}
procedure headerAddNw##headerAdd#send_length#11()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var headerAddNw#a: Actor;
  var headerAddNw#input: Chan (bv8);
  var headerAddNw#octet_count: Chan (bv8);
  var headerAddNw#octet_index: Chan (bv8);
  var headerAddNw#St: Chan (int);
  var headerAddNw#data: Chan (bv8);
  var headerAddNw#len: Chan (bv8);
  var AV#a#octet_count: bv8;
  var AV#a#octet_index: bv8;
  var AV#a#HEADER_LEN: bv8;
  var AV#a#Header: Map (bv8) (bv8);
  var AV#a#data_out: bv8;
  var octet_index_in#octet_index: bv8;
  var octet_count_in#octet_count: bv8;
  var St_in#St: int;
  assume (headerAddNw#input != headerAddNw#octet_count) && (headerAddNw#input != headerAddNw#octet_index) && (headerAddNw#input != headerAddNw#data) && (headerAddNw#input != headerAddNw#len) && (headerAddNw#octet_count != headerAddNw#octet_index) && (headerAddNw#octet_count != headerAddNw#data) && (headerAddNw#octet_count != headerAddNw#len) && (headerAddNw#octet_index != headerAddNw#data) && (headerAddNw#octet_index != headerAddNw#len) && (headerAddNw#data != headerAddNw#len);
  assume 0 <= I#[headerAddNw#input];
  assume I#[headerAddNw#input] <= R#[headerAddNw#input];
  assume R#[headerAddNw#input] <= C#[headerAddNw#input];
  assume 0 <= I#[headerAddNw#octet_count];
  assume I#[headerAddNw#octet_count] <= R#[headerAddNw#octet_count];
  assume R#[headerAddNw#octet_count] <= C#[headerAddNw#octet_count];
  assume 0 <= I#[headerAddNw#octet_index];
  assume I#[headerAddNw#octet_index] <= R#[headerAddNw#octet_index];
  assume R#[headerAddNw#octet_index] <= C#[headerAddNw#octet_index];
  assume 0 <= I#[headerAddNw#St];
  assume I#[headerAddNw#St] <= R#[headerAddNw#St];
  assume R#[headerAddNw#St] <= C#[headerAddNw#St];
  assume 0 <= I#[headerAddNw#data];
  assume I#[headerAddNw#data] <= R#[headerAddNw#data];
  assume R#[headerAddNw#data] <= C#[headerAddNw#data];
  assume I#[headerAddNw#data] == R#[headerAddNw#data];
  assume 0 <= I#[headerAddNw#len];
  assume I#[headerAddNw#len] <= R#[headerAddNw#len];
  assume R#[headerAddNw#len] <= C#[headerAddNw#len];
  assume I#[headerAddNw#len] == R#[headerAddNw#len];
  assume (B#[headerAddNw#input] == 4) && (B#[headerAddNw#data] == 9) && (B#[headerAddNw#len] == 1);
  I#sub[headerAddNw#input] := R#[headerAddNw#input];
  I#sub[headerAddNw#St] := R#[headerAddNw#St];
  I#sub[headerAddNw#octet_count] := R#[headerAddNw#octet_count];
  I#sub[headerAddNw#octet_index] := R#[headerAddNw#octet_index];
  I#sub[headerAddNw#data] := C#[headerAddNw#data];
  I#sub[headerAddNw#len] := C#[headerAddNw#len];
  I#sub[headerAddNw#St] := C#[headerAddNw#St];
  I#sub[headerAddNw#octet_count] := C#[headerAddNw#octet_count];
  I#sub[headerAddNw#octet_index] := C#[headerAddNw#octet_index];
  assume (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assume I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assume ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assume AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assume ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assume ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1);
  assume (C#[headerAddNw#input] - I#[headerAddNw#input]) <= 4;
  assume (1 <= (C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index])) && (1 <= (C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count])) && (1 <= (C#[headerAddNw#St] - R#[headerAddNw#St])) && (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == 5bv8) && (M#[headerAddNw#St][R#[headerAddNw#St]] == 1);
  octet_index_in#octet_index := M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]];
  R#[headerAddNw#octet_index] := R#[headerAddNw#octet_index] + 1;
  octet_count_in#octet_count := M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]];
  R#[headerAddNw#octet_count] := R#[headerAddNw#octet_count] + 1;
  St_in#St := M#[headerAddNw#St][R#[headerAddNw#St]];
  R#[headerAddNw#St] := R#[headerAddNw#St] + 1;
  M#[headerAddNw#St][C#[headerAddNw#St]] := 2;
  C#[headerAddNw#St] := C#[headerAddNw#St] + 1;
  M#[headerAddNw#octet_index][C#[headerAddNw#octet_index]] := AT#BvAdd8(octet_index_in#octet_index, 1bv8);
  C#[headerAddNw#octet_index] := C#[headerAddNw#octet_index] + 1;
  M#[headerAddNw#octet_count][C#[headerAddNw#octet_count]] := octet_count_in#octet_count;
  C#[headerAddNw#octet_count] := C#[headerAddNw#octet_count] + 1;
  M#[headerAddNw#data][C#[headerAddNw#data]] := AT#BvSub8(AT#BvSub8(octet_count_in#octet_count, 5bv8), 1bv8);
  C#[headerAddNw#data] := C#[headerAddNw#data] + 1;
  assert {:msg "ZigBee.actor(146.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#68)"} (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assert {:msg "ZigBee.actor(147.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#69)"} I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assert {:msg "ZigBee.actor(150.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#70)"} ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assert {:msg "ZigBee.actor(153.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#71)"} AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(156.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#72)"} (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assert {:msg "ZigBee.actor(158.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#73)"} ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assert {:msg "ZigBee.actor(160.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#74)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(161.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#75)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assert {:msg "ZigBee.actor(162.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#76)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(164.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#77)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assert {:msg "ZigBee.actor(165.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#78)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assert {:msg "ZigBee.actor(167.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#79)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assert {:msg "ZigBee.actor(168.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#80)"} ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assert {:msg "ZigBee.actor(169.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#81)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assert {:msg "ZigBee.actor(171.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#82)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assert {:msg "ZigBee.actor(173.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#83)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assert {:msg "ZigBee.actor(174.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#84)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assert {:msg "ZigBee.actor(176.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#85)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assert {:msg "ZigBee.actor(177.15): Action at ZigBee.actor(101.2) ('send_length') for actor instance 'a' might not preserve the channel invariant (#86)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
}
procedure headerAddNw##headerAdd#send_payload_octet#12()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var headerAddNw#a: Actor;
  var headerAddNw#input: Chan (bv8);
  var headerAddNw#octet_count: Chan (bv8);
  var headerAddNw#octet_index: Chan (bv8);
  var headerAddNw#St: Chan (int);
  var headerAddNw#data: Chan (bv8);
  var headerAddNw#len: Chan (bv8);
  var AV#a#octet_count: bv8;
  var AV#a#octet_index: bv8;
  var AV#a#HEADER_LEN: bv8;
  var AV#a#Header: Map (bv8) (bv8);
  var AV#a#data_out: bv8;
  var pl_bits#bits_in: bv8;
  var octet_index_in#octet_index: bv8;
  var octet_count_in#octet_count: bv8;
  var St_in#St: int;
  assume (headerAddNw#input != headerAddNw#octet_count) && (headerAddNw#input != headerAddNw#octet_index) && (headerAddNw#input != headerAddNw#data) && (headerAddNw#input != headerAddNw#len) && (headerAddNw#octet_count != headerAddNw#octet_index) && (headerAddNw#octet_count != headerAddNw#data) && (headerAddNw#octet_count != headerAddNw#len) && (headerAddNw#octet_index != headerAddNw#data) && (headerAddNw#octet_index != headerAddNw#len) && (headerAddNw#data != headerAddNw#len);
  assume 0 <= I#[headerAddNw#input];
  assume I#[headerAddNw#input] <= R#[headerAddNw#input];
  assume R#[headerAddNw#input] <= C#[headerAddNw#input];
  assume 0 <= I#[headerAddNw#octet_count];
  assume I#[headerAddNw#octet_count] <= R#[headerAddNw#octet_count];
  assume R#[headerAddNw#octet_count] <= C#[headerAddNw#octet_count];
  assume 0 <= I#[headerAddNw#octet_index];
  assume I#[headerAddNw#octet_index] <= R#[headerAddNw#octet_index];
  assume R#[headerAddNw#octet_index] <= C#[headerAddNw#octet_index];
  assume 0 <= I#[headerAddNw#St];
  assume I#[headerAddNw#St] <= R#[headerAddNw#St];
  assume R#[headerAddNw#St] <= C#[headerAddNw#St];
  assume 0 <= I#[headerAddNw#data];
  assume I#[headerAddNw#data] <= R#[headerAddNw#data];
  assume R#[headerAddNw#data] <= C#[headerAddNw#data];
  assume I#[headerAddNw#data] == R#[headerAddNw#data];
  assume 0 <= I#[headerAddNw#len];
  assume I#[headerAddNw#len] <= R#[headerAddNw#len];
  assume R#[headerAddNw#len] <= C#[headerAddNw#len];
  assume I#[headerAddNw#len] == R#[headerAddNw#len];
  assume (B#[headerAddNw#input] == 4) && (B#[headerAddNw#data] == 9) && (B#[headerAddNw#len] == 1);
  I#sub[headerAddNw#input] := R#[headerAddNw#input];
  I#sub[headerAddNw#St] := R#[headerAddNw#St];
  I#sub[headerAddNw#octet_count] := R#[headerAddNw#octet_count];
  I#sub[headerAddNw#octet_index] := R#[headerAddNw#octet_index];
  I#sub[headerAddNw#data] := C#[headerAddNw#data];
  I#sub[headerAddNw#len] := C#[headerAddNw#len];
  I#sub[headerAddNw#St] := C#[headerAddNw#St];
  I#sub[headerAddNw#octet_count] := C#[headerAddNw#octet_count];
  I#sub[headerAddNw#octet_index] := C#[headerAddNw#octet_index];
  assume (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assume I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assume ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assume AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assume ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assume ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1);
  assume (C#[headerAddNw#input] - I#[headerAddNw#input]) <= 4;
  assume (1 <= (C#[headerAddNw#input] - R#[headerAddNw#input])) && (1 <= (C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index])) && (1 <= (C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count])) && (1 <= (C#[headerAddNw#St] - R#[headerAddNw#St])) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] == 2);
  pl_bits#bits_in := M#[headerAddNw#input][R#[headerAddNw#input]];
  R#[headerAddNw#input] := R#[headerAddNw#input] + 1;
  octet_index_in#octet_index := M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]];
  R#[headerAddNw#octet_index] := R#[headerAddNw#octet_index] + 1;
  octet_count_in#octet_count := M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]];
  R#[headerAddNw#octet_count] := R#[headerAddNw#octet_count] + 1;
  St_in#St := M#[headerAddNw#St][R#[headerAddNw#St]];
  R#[headerAddNw#St] := R#[headerAddNw#St] + 1;
  M#[headerAddNw#St][C#[headerAddNw#St]] := (if AT#BvAdd8(octet_index_in#octet_index, 1bv8) == octet_count_in#octet_count then 0 else 2);
  C#[headerAddNw#St] := C#[headerAddNw#St] + 1;
  M#[headerAddNw#octet_index][C#[headerAddNw#octet_index]] := AT#BvAdd8(octet_index_in#octet_index, 1bv8);
  C#[headerAddNw#octet_index] := C#[headerAddNw#octet_index] + 1;
  M#[headerAddNw#octet_count][C#[headerAddNw#octet_count]] := octet_count_in#octet_count;
  C#[headerAddNw#octet_count] := C#[headerAddNw#octet_count] + 1;
  M#[headerAddNw#data][C#[headerAddNw#data]] := pl_bits#bits_in;
  C#[headerAddNw#data] := C#[headerAddNw#data] + 1;
  assert {:msg "ZigBee.actor(146.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#87)"} (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assert {:msg "ZigBee.actor(147.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#88)"} I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assert {:msg "ZigBee.actor(150.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#89)"} ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assert {:msg "ZigBee.actor(153.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#90)"} AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(156.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#91)"} (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assert {:msg "ZigBee.actor(158.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#92)"} ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assert {:msg "ZigBee.actor(160.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#93)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(161.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#94)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assert {:msg "ZigBee.actor(162.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#95)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(164.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#96)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assert {:msg "ZigBee.actor(165.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#97)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assert {:msg "ZigBee.actor(167.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#98)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assert {:msg "ZigBee.actor(168.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#99)"} ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assert {:msg "ZigBee.actor(169.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#100)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assert {:msg "ZigBee.actor(171.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#101)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assert {:msg "ZigBee.actor(173.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#102)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assert {:msg "ZigBee.actor(174.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#103)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assert {:msg "ZigBee.actor(176.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#104)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assert {:msg "ZigBee.actor(177.15): Action at ZigBee.actor(117.2) ('send_payload_octet') for actor instance 'a' might not preserve the channel invariant (#105)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
}
procedure headerAddNw#anon$2#input#pl_bits#13()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var headerAddNw#a: Actor;
  var headerAddNw#input: Chan (bv8);
  var headerAddNw#octet_count: Chan (bv8);
  var headerAddNw#octet_index: Chan (bv8);
  var headerAddNw#St: Chan (int);
  var headerAddNw#data: Chan (bv8);
  var headerAddNw#len: Chan (bv8);
  var AV#a#octet_count: bv8;
  var AV#a#octet_index: bv8;
  var AV#a#HEADER_LEN: bv8;
  var AV#a#Header: Map (bv8) (bv8);
  var AV#a#data_out: bv8;
  assume (headerAddNw#input != headerAddNw#octet_count) && (headerAddNw#input != headerAddNw#octet_index) && (headerAddNw#input != headerAddNw#data) && (headerAddNw#input != headerAddNw#len) && (headerAddNw#octet_count != headerAddNw#octet_index) && (headerAddNw#octet_count != headerAddNw#data) && (headerAddNw#octet_count != headerAddNw#len) && (headerAddNw#octet_index != headerAddNw#data) && (headerAddNw#octet_index != headerAddNw#len) && (headerAddNw#data != headerAddNw#len);
  assume 0 <= I#[headerAddNw#input];
  assume I#[headerAddNw#input] <= R#[headerAddNw#input];
  assume R#[headerAddNw#input] <= C#[headerAddNw#input];
  assume 0 <= I#[headerAddNw#octet_count];
  assume I#[headerAddNw#octet_count] <= R#[headerAddNw#octet_count];
  assume R#[headerAddNw#octet_count] <= C#[headerAddNw#octet_count];
  assume 0 <= I#[headerAddNw#octet_index];
  assume I#[headerAddNw#octet_index] <= R#[headerAddNw#octet_index];
  assume R#[headerAddNw#octet_index] <= C#[headerAddNw#octet_index];
  assume 0 <= I#[headerAddNw#St];
  assume I#[headerAddNw#St] <= R#[headerAddNw#St];
  assume R#[headerAddNw#St] <= C#[headerAddNw#St];
  assume 0 <= I#[headerAddNw#data];
  assume I#[headerAddNw#data] <= R#[headerAddNw#data];
  assume R#[headerAddNw#data] <= C#[headerAddNw#data];
  assume I#[headerAddNw#data] == R#[headerAddNw#data];
  assume 0 <= I#[headerAddNw#len];
  assume I#[headerAddNw#len] <= R#[headerAddNw#len];
  assume R#[headerAddNw#len] <= C#[headerAddNw#len];
  assume I#[headerAddNw#len] == R#[headerAddNw#len];
  assume (B#[headerAddNw#input] == 4) && (B#[headerAddNw#data] == 9) && (B#[headerAddNw#len] == 1);
  assume (B#[headerAddNw#input] == 4) && (B#[headerAddNw#data] == 9) && (B#[headerAddNw#len] == 1);
  assume (C#[headerAddNw#input] - I#[headerAddNw#input]) < 4;
  assume (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assume I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assume ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assume AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assume ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assume ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1);
  assume (C#[headerAddNw#input] - I#[headerAddNw#input]) <= 4;
  C#[headerAddNw#input] := C#[headerAddNw#input] + 1;
  assume AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1);
  assert {:msg "ZigBee.actor(146.15): Channel invariant might be falsified by network input (#106)"} (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assert {:msg "ZigBee.actor(147.15): Channel invariant might be falsified by network input (#107)"} I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assert {:msg "ZigBee.actor(150.15): Channel invariant might be falsified by network input (#108)"} ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assert {:msg "ZigBee.actor(153.15): Channel invariant might be falsified by network input (#109)"} AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(156.15): Channel invariant might be falsified by network input (#110)"} (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assert {:msg "ZigBee.actor(158.15): Channel invariant might be falsified by network input (#111)"} ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assert {:msg "ZigBee.actor(160.15): Channel invariant might be falsified by network input (#112)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(161.15): Channel invariant might be falsified by network input (#113)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assert {:msg "ZigBee.actor(162.15): Channel invariant might be falsified by network input (#114)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(164.15): Channel invariant might be falsified by network input (#115)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assert {:msg "ZigBee.actor(165.15): Channel invariant might be falsified by network input (#116)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assert {:msg "ZigBee.actor(167.15): Channel invariant might be falsified by network input (#117)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assert {:msg "ZigBee.actor(168.15): Channel invariant might be falsified by network input (#118)"} ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assert {:msg "ZigBee.actor(169.15): Channel invariant might be falsified by network input (#119)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assert {:msg "ZigBee.actor(171.15): Channel invariant might be falsified by network input (#120)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assert {:msg "ZigBee.actor(173.15): Channel invariant might be falsified by network input (#121)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assert {:msg "ZigBee.actor(174.15): Channel invariant might be falsified by network input (#122)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assert {:msg "ZigBee.actor(176.15): Channel invariant might be falsified by network input (#123)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assert {:msg "ZigBee.actor(177.15): Channel invariant might be falsified by network input (#124)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
}
procedure headerAddNw#anon$2#exit#14()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var headerAddNw#a: Actor;
  var headerAddNw#input: Chan (bv8);
  var headerAddNw#octet_count: Chan (bv8);
  var headerAddNw#octet_index: Chan (bv8);
  var headerAddNw#St: Chan (int);
  var headerAddNw#data: Chan (bv8);
  var headerAddNw#len: Chan (bv8);
  var AV#a#octet_count: bv8;
  var AV#a#octet_index: bv8;
  var AV#a#HEADER_LEN: bv8;
  var AV#a#Header: Map (bv8) (bv8);
  var AV#a#data_out: bv8;
  assume (headerAddNw#input != headerAddNw#octet_count) && (headerAddNw#input != headerAddNw#octet_index) && (headerAddNw#input != headerAddNw#data) && (headerAddNw#input != headerAddNw#len) && (headerAddNw#octet_count != headerAddNw#octet_index) && (headerAddNw#octet_count != headerAddNw#data) && (headerAddNw#octet_count != headerAddNw#len) && (headerAddNw#octet_index != headerAddNw#data) && (headerAddNw#octet_index != headerAddNw#len) && (headerAddNw#data != headerAddNw#len);
  assume 0 <= I#[headerAddNw#input];
  assume I#[headerAddNw#input] <= R#[headerAddNw#input];
  assume R#[headerAddNw#input] <= C#[headerAddNw#input];
  assume 0 <= I#[headerAddNw#octet_count];
  assume I#[headerAddNw#octet_count] <= R#[headerAddNw#octet_count];
  assume R#[headerAddNw#octet_count] <= C#[headerAddNw#octet_count];
  assume 0 <= I#[headerAddNw#octet_index];
  assume I#[headerAddNw#octet_index] <= R#[headerAddNw#octet_index];
  assume R#[headerAddNw#octet_index] <= C#[headerAddNw#octet_index];
  assume 0 <= I#[headerAddNw#St];
  assume I#[headerAddNw#St] <= R#[headerAddNw#St];
  assume R#[headerAddNw#St] <= C#[headerAddNw#St];
  assume 0 <= I#[headerAddNw#data];
  assume I#[headerAddNw#data] <= R#[headerAddNw#data];
  assume R#[headerAddNw#data] <= C#[headerAddNw#data];
  assume I#[headerAddNw#data] == R#[headerAddNw#data];
  assume 0 <= I#[headerAddNw#len];
  assume I#[headerAddNw#len] <= R#[headerAddNw#len];
  assume R#[headerAddNw#len] <= C#[headerAddNw#len];
  assume I#[headerAddNw#len] == R#[headerAddNw#len];
  assume (B#[headerAddNw#input] == 4) && (B#[headerAddNw#data] == 9) && (B#[headerAddNw#len] == 1);
  assume (B#[headerAddNw#input] == 4) && (B#[headerAddNw#data] == 9) && (B#[headerAddNw#len] == 1);
  assume (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assume I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assume ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assume AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assume ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assume ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assume (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assume ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assume AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1);
  assume (C#[headerAddNw#input] - I#[headerAddNw#input]) <= 4;
  assume (C#[headerAddNw#input] - I#[headerAddNw#input]) == 4;
  assume AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1);
  assume !((1 <= (C#[headerAddNw#input] - R#[headerAddNw#input])) && (1 <= (C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index])) && (1 <= (C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count])) && (1 <= (C#[headerAddNw#St] - R#[headerAddNw#St])) && (M#[headerAddNw#St][R#[headerAddNw#St]] == 0));
  assume !((1 <= (C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index])) && (1 <= (C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count])) && (1 <= (C#[headerAddNw#St] - R#[headerAddNw#St])) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8) && (M#[headerAddNw#St][R#[headerAddNw#St]] == 1));
  assume !((1 <= (C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index])) && (1 <= (C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count])) && (1 <= (C#[headerAddNw#St] - R#[headerAddNw#St])) && (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == 5bv8) && (M#[headerAddNw#St][R#[headerAddNw#St]] == 1));
  assume !((1 <= (C#[headerAddNw#input] - R#[headerAddNw#input])) && (1 <= (C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index])) && (1 <= (C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count])) && (1 <= (C#[headerAddNw#St] - R#[headerAddNw#St])) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] == 2));
  assert {:msg "ZigBee.actor(137.3): The correct number of tokens might not be produced on output 'data' (#125)"} (C#[headerAddNw#data] - I#[headerAddNw#data]) == 9;
  assert {:msg "ZigBee.actor(137.3): The correct number of tokens might not be produced on output 'len' (#126)"} (C#[headerAddNw#len] - I#[headerAddNw#len]) == 1;
  assert {:msg "ZigBee.actor(139.13): Network action postcondition might not hold (#127)"} M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8);
  R#[headerAddNw#data] := R#[headerAddNw#data] + 9;
  R#[headerAddNw#len] := R#[headerAddNw#len] + 1;
  I# := R#;
  assert {:msg "ZigBee.actor(146.15): The network might not preserve the channel invariant (#128)"} (9 * I#[headerAddNw#input]) == (4 * I#[headerAddNw#data]);
  assert {:msg "ZigBee.actor(147.15): The network might not preserve the channel invariant (#129)"} I#[headerAddNw#input] == (4 * I#[headerAddNw#len]);
  assert {:msg "ZigBee.actor(150.15): The network might not preserve the channel invariant (#130)"} ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assert {:msg "ZigBee.actor(153.15): The network might not preserve the channel invariant (#131)"} AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(156.15): The network might not preserve the channel invariant (#132)"} (0 <= M#[headerAddNw#St][R#[headerAddNw#St]]) && (M#[headerAddNw#St][R#[headerAddNw#St]] <= 2);
  assert {:msg "ZigBee.actor(158.15): The network might not preserve the channel invariant (#133)"} ((C#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (AT#Bv2Int8(M#[headerAddNw#input][I#[headerAddNw#input]]) == (B#[headerAddNw#input] - 1));
  assert {:msg "ZigBee.actor(160.15): The network might not preserve the channel invariant (#134)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) ==> (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(161.15): The network might not preserve the channel invariant (#135)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> AT#BvUle8(0bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUle8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], 5bv8);
  assert {:msg "ZigBee.actor(162.15): The network might not preserve the channel invariant (#136)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> AT#BvUle8(6bv8, M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]) && AT#BvUlt8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]], M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "ZigBee.actor(164.15): The network might not preserve the channel invariant (#137)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == 0);
  assert {:msg "ZigBee.actor(165.15): The network might not preserve the channel invariant (#138)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]));
  assert {:msg "ZigBee.actor(167.15): The network might not preserve the channel invariant (#139)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 1) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 1);
  assert {:msg "ZigBee.actor(168.15): The network might not preserve the channel invariant (#140)"} ((M#[headerAddNw#St][R#[headerAddNw#St]] == 1) || (M#[headerAddNw#St][R#[headerAddNw#St]] == 2)) ==> ((C#[headerAddNw#data] - I#[headerAddNw#data]) == AT#Bv2Int8(M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]]));
  assert {:msg "ZigBee.actor(169.15): The network might not preserve the channel invariant (#141)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 2) ==> ((R#[headerAddNw#input] - I#[headerAddNw#input]) == ((C#[headerAddNw#data] - I#[headerAddNw#data]) - 5));
  assert {:msg "ZigBee.actor(171.15): The network might not preserve the channel invariant (#142)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) <==> (((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) || ((R#[headerAddNw#input] - I#[headerAddNw#input]) == B#[headerAddNw#input]));
  assert {:msg "ZigBee.actor(173.15): The network might not preserve the channel invariant (#143)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) == 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 0);
  assert {:msg "ZigBee.actor(174.15): The network might not preserve the channel invariant (#144)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assert {:msg "ZigBee.actor(176.15): The network might not preserve the channel invariant (#145)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> ((C#[headerAddNw#len] - I#[headerAddNw#len]) == 1);
  assert {:msg "ZigBee.actor(177.15): The network might not preserve the channel invariant (#146)"} ((R#[headerAddNw#input] - I#[headerAddNw#input]) > 0) ==> (M#[headerAddNw#len][I#[headerAddNw#len]] == AT#BvAdd8(M#[headerAddNw#input][I#[headerAddNw#input]], 6bv8));
  assert {:msg "ZigBee.actor(143.13): The network might not preserve the network invariant (#147)"} ((C#[headerAddNw#octet_count] - R#[headerAddNw#octet_count]) == 1) && ((C#[headerAddNw#octet_index] - R#[headerAddNw#octet_index]) == 1) && ((C#[headerAddNw#St] - R#[headerAddNw#St]) == 1);
  assert {:msg "ZigBee.actor(144.13): The network might not preserve the network invariant (#148)"} (M#[headerAddNw#St][R#[headerAddNw#St]] == 0) && (M#[headerAddNw#octet_index][R#[headerAddNw#octet_index]] == M#[headerAddNw#octet_count][R#[headerAddNw#octet_count]]);
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel input (#149)"} (C#[headerAddNw#input] - R#[headerAddNw#input]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel data (#150)"} (C#[headerAddNw#data] - R#[headerAddNw#data]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel len (#151)"} (C#[headerAddNw#len] - R#[headerAddNw#len]) == 0;
}
function pulseShape#mul8(x: bv8, y: bv8) returns (out: bv8);
procedure pulseShape#init#15()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var symb: Chan (bv8);
  var len: Chan (bv8);
  var body_iterations_in: Chan (bv14);
  var body_index_in: Chan (bv14);
  var St_in: Chan (int);
  var done: Chan (bool);
  var hsp: Chan (bv8);
  var body_iterations_out: Chan (bv14);
  var body_index_out: Chan (bv14);
  var St_out: Chan (int);
  var symb_mem: bv8;
  var body_iterations: bv8;
  var body_index: bv8;
  var FILT_COEFF0: bv8;
  var FILT_COEFF1: bv8;
  var FILT_COEFF2: bv8;
  var FILT_COEFF3: bv8;
  var FILT_COEFF4: bv8;
  var hsps: Map (int) (bv8);
  assume (symb != len) && (symb != hsp) && (len != hsp) && (body_iterations_in != body_index_in) && (body_iterations_in != body_iterations_out) && (body_iterations_in != body_index_out) && (body_index_in != body_iterations_out) && (body_index_in != body_index_out) && (St_in != St_out) && (body_iterations_out != body_index_out);
  assume FILT_COEFF0 == 0bv8;
  assume FILT_COEFF1 == 49bv8;
  assume FILT_COEFF2 == 90bv8;
  assume FILT_COEFF3 == 118bv8;
  assume FILT_COEFF4 == 127bv8;
  assume (I#[symb] == 0) && (R#[symb] == 0) && (C#[symb] == 0);
  assume (I#[len] == 0) && (R#[len] == 0) && (C#[len] == 0);
  assume (I#[body_iterations_in] == 0) && (R#[body_iterations_in] == 0) && (C#[body_iterations_in] == 0);
  assume (I#[body_index_in] == 0) && (R#[body_index_in] == 0) && (C#[body_index_in] == 0);
  assume (I#[St_in] == 0) && (R#[St_in] == 0) && (C#[St_in] == 0);
  assume (I#[done] == 0) && (R#[done] == 0) && (C#[done] == 0);
  assume (I#[hsp] == 0) && (R#[hsp] == 0) && (C#[hsp] == 0);
  assume (I#[body_iterations_out] == 0) && (R#[body_iterations_out] == 0) && (C#[body_iterations_out] == 0);
  assume (I#[body_index_out] == 0) && (R#[body_index_out] == 0) && (C#[body_index_out] == 0);
  assume (I#[St_out] == 0) && (R#[St_out] == 0) && (C#[St_out] == 0);
  M#[body_iterations_out][C#[body_iterations_out]] := 0bv14;
  C#[body_iterations_out] := C#[body_iterations_out] + 1;
  M#[body_index_out][C#[body_index_out]] := 0bv14;
  C#[body_index_out] := C#[body_index_out] + 1;
  M#[St_out][C#[St_out]] := 0;
  C#[St_out] := C#[St_out] + 1;
}
procedure pulseShape#init#16()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var symb: Chan (bv8);
  var len: Chan (bv8);
  var body_iterations_in: Chan (bv14);
  var body_index_in: Chan (bv14);
  var St_in: Chan (int);
  var done: Chan (bool);
  var hsp: Chan (bv8);
  var body_iterations_out: Chan (bv14);
  var body_index_out: Chan (bv14);
  var St_out: Chan (int);
  var symb_mem: bv8;
  var body_iterations: bv8;
  var body_index: bv8;
  var FILT_COEFF0: bv8;
  var FILT_COEFF1: bv8;
  var FILT_COEFF2: bv8;
  var FILT_COEFF3: bv8;
  var FILT_COEFF4: bv8;
  var hsps: Map (int) (bv8);
  var body_index_in#0: bv14;
  var body_iterations_in#0: bv14;
  var symb#0: bv8;
  var St_in#0: int;
  var len#0: bv8;
  var symb#1: bv8;
  assume (symb != len) && (symb != hsp) && (len != hsp) && (body_iterations_in != body_index_in) && (body_iterations_in != body_iterations_out) && (body_iterations_in != body_index_out) && (body_index_in != body_iterations_out) && (body_index_in != body_index_out) && (St_in != St_out) && (body_iterations_out != body_index_out);
  assume FILT_COEFF0 == 0bv8;
  assume FILT_COEFF1 == 49bv8;
  assume FILT_COEFF2 == 90bv8;
  assume FILT_COEFF3 == 118bv8;
  assume FILT_COEFF4 == 127bv8;
  assume (0 <= I#[symb]) && (I#[symb] <= R#[symb]) && (R#[symb] <= C#[symb]);
  assume (0 <= I#[len]) && (I#[len] <= R#[len]) && (R#[len] <= C#[len]);
  assume (0 <= I#[body_iterations_in]) && (I#[body_iterations_in] <= R#[body_iterations_in]) && (R#[body_iterations_in] <= C#[body_iterations_in]);
  assume (0 <= I#[body_index_in]) && (I#[body_index_in] <= R#[body_index_in]) && (R#[body_index_in] <= C#[body_index_in]);
  assume (0 <= I#[St_in]) && (I#[St_in] <= R#[St_in]) && (R#[St_in] <= C#[St_in]);
  assume (0 <= I#[done]) && (I#[done] <= R#[done]) && (R#[done] <= C#[done]);
  assume (0 <= I#[hsp]) && (I#[hsp] <= R#[hsp]) && (R#[hsp] <= C#[hsp]);
  assume (0 <= I#[body_iterations_out]) && (I#[body_iterations_out] <= R#[body_iterations_out]) && (R#[body_iterations_out] <= C#[body_iterations_out]);
  assume (0 <= I#[body_index_out]) && (I#[body_index_out] <= R#[body_index_out]) && (R#[body_index_out] <= C#[body_index_out]);
  assume (0 <= I#[St_out]) && (I#[St_out] <= R#[St_out]) && (R#[St_out] <= C#[St_out]);
  assume (1 <= (C#[len] - R#[len])) && (1 <= (C#[body_iterations_in] - R#[body_iterations_in])) && (1 <= (C#[body_index_in] - R#[body_index_in])) && (1 <= (C#[St_in] - R#[St_in]));
  len#0 := M#[len][R#[len]];
  R#[len] := R#[len] + 1;
  body_iterations_in#0 := M#[body_iterations_in][R#[body_iterations_in]];
  R#[body_iterations_in] := R#[body_iterations_in] + 1;
  body_index_in#0 := M#[body_index_in][R#[body_index_in]];
  R#[body_index_in] := R#[body_index_in] + 1;
  St_in#0 := M#[St_in][R#[St_in]];
  R#[St_in] := R#[St_in] + 1;
  assume St_in#0 == 0;
  symb_mem := 127bv8;
  M#[body_iterations_out][C#[body_iterations_out]] := AT#BvMul14(0bv6 ++ len#0, 32bv14);
  C#[body_iterations_out] := C#[body_iterations_out] + 1;
  M#[body_index_out][C#[body_index_out]] := 0bv14;
  C#[body_index_out] := C#[body_index_out] + 1;
  M#[St_out][C#[St_out]] := 1;
  C#[St_out] := C#[St_out] + 1;
}
procedure pulseShape#tx_body#17()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var symb: Chan (bv8);
  var len: Chan (bv8);
  var body_iterations_in: Chan (bv14);
  var body_index_in: Chan (bv14);
  var St_in: Chan (int);
  var done: Chan (bool);
  var hsp: Chan (bv8);
  var body_iterations_out: Chan (bv14);
  var body_index_out: Chan (bv14);
  var St_out: Chan (int);
  var symb_mem: bv8;
  var body_iterations: bv8;
  var body_index: bv8;
  var FILT_COEFF0: bv8;
  var FILT_COEFF1: bv8;
  var FILT_COEFF2: bv8;
  var FILT_COEFF3: bv8;
  var FILT_COEFF4: bv8;
  var hsps: Map (int) (bv8);
  var body_index_in#0: bv14;
  var body_iterations_in#0: bv14;
  var symb#0: bv8;
  var St_in#0: int;
  var len#0: bv8;
  var symb#1: bv8;
  assume (symb != len) && (symb != hsp) && (len != hsp) && (body_iterations_in != body_index_in) && (body_iterations_in != body_iterations_out) && (body_iterations_in != body_index_out) && (body_index_in != body_iterations_out) && (body_index_in != body_index_out) && (St_in != St_out) && (body_iterations_out != body_index_out);
  assume FILT_COEFF0 == 0bv8;
  assume FILT_COEFF1 == 49bv8;
  assume FILT_COEFF2 == 90bv8;
  assume FILT_COEFF3 == 118bv8;
  assume FILT_COEFF4 == 127bv8;
  assume (0 <= I#[symb]) && (I#[symb] <= R#[symb]) && (R#[symb] <= C#[symb]);
  assume (0 <= I#[len]) && (I#[len] <= R#[len]) && (R#[len] <= C#[len]);
  assume (0 <= I#[body_iterations_in]) && (I#[body_iterations_in] <= R#[body_iterations_in]) && (R#[body_iterations_in] <= C#[body_iterations_in]);
  assume (0 <= I#[body_index_in]) && (I#[body_index_in] <= R#[body_index_in]) && (R#[body_index_in] <= C#[body_index_in]);
  assume (0 <= I#[St_in]) && (I#[St_in] <= R#[St_in]) && (R#[St_in] <= C#[St_in]);
  assume (0 <= I#[done]) && (I#[done] <= R#[done]) && (R#[done] <= C#[done]);
  assume (0 <= I#[hsp]) && (I#[hsp] <= R#[hsp]) && (R#[hsp] <= C#[hsp]);
  assume (0 <= I#[body_iterations_out]) && (I#[body_iterations_out] <= R#[body_iterations_out]) && (R#[body_iterations_out] <= C#[body_iterations_out]);
  assume (0 <= I#[body_index_out]) && (I#[body_index_out] <= R#[body_index_out]) && (R#[body_index_out] <= C#[body_index_out]);
  assume (0 <= I#[St_out]) && (I#[St_out] <= R#[St_out]) && (R#[St_out] <= C#[St_out]);
  assume (2 <= (C#[symb] - R#[symb])) && (1 <= (C#[body_iterations_in] - R#[body_iterations_in])) && (1 <= (C#[body_index_in] - R#[body_index_in])) && (1 <= (C#[St_in] - R#[St_in]));
  symb#0 := M#[symb][R#[symb]];
  R#[symb] := R#[symb] + 1;
  symb#1 := M#[symb][R#[symb]];
  R#[symb] := R#[symb] + 1;
  body_iterations_in#0 := M#[body_iterations_in][R#[body_iterations_in]];
  R#[body_iterations_in] := R#[body_iterations_in] + 1;
  body_index_in#0 := M#[body_index_in][R#[body_index_in]];
  R#[body_index_in] := R#[body_index_in] + 1;
  St_in#0 := M#[St_in][R#[St_in]];
  R#[St_in] := R#[St_in] + 1;
  assume (St_in#0 == 1) && AT#BvUlt14(body_index_in#0, body_iterations_in#0);
  hsps := Map#Store(hsps, 0, pulseShape#mul8(FILT_COEFF0, symb#0));
  hsps := Map#Store(hsps, 1, pulseShape#mul8(FILT_COEFF4, symb_mem));
  hsps := Map#Store(hsps, 2, pulseShape#mul8(FILT_COEFF1, symb#0));
  hsps := Map#Store(hsps, 3, pulseShape#mul8(FILT_COEFF3, symb_mem));
  hsps := Map#Store(hsps, 4, pulseShape#mul8(FILT_COEFF2, symb#0));
  hsps := Map#Store(hsps, 5, pulseShape#mul8(FILT_COEFF2, symb_mem));
  hsps := Map#Store(hsps, 6, pulseShape#mul8(FILT_COEFF3, symb#0));
  hsps := Map#Store(hsps, 7, pulseShape#mul8(FILT_COEFF1, symb_mem));
  hsps := Map#Store(hsps, 8, pulseShape#mul8(FILT_COEFF4, symb#0));
  hsps := Map#Store(hsps, 9, pulseShape#mul8(FILT_COEFF0, symb#1));
  hsps := Map#Store(hsps, 10, pulseShape#mul8(FILT_COEFF3, symb#0));
  hsps := Map#Store(hsps, 11, pulseShape#mul8(FILT_COEFF1, symb#1));
  hsps := Map#Store(hsps, 12, pulseShape#mul8(FILT_COEFF2, symb#0));
  hsps := Map#Store(hsps, 13, pulseShape#mul8(FILT_COEFF2, symb#1));
  hsps := Map#Store(hsps, 14, pulseShape#mul8(FILT_COEFF1, symb#0));
  hsps := Map#Store(hsps, 15, pulseShape#mul8(FILT_COEFF3, symb#1));
  symb_mem := symb#1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 0);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 1);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 2);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 3);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 4);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 5);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 6);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 7);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 8);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 9);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 10);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 11);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 12);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 13);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 14);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 15);
  C#[hsp] := C#[hsp] + 1;
  M#[body_iterations_out][C#[body_iterations_out]] := body_iterations_in#0;
  C#[body_iterations_out] := C#[body_iterations_out] + 1;
  M#[body_index_out][C#[body_index_out]] := AT#BvAdd14(body_index_in#0, 1bv14);
  C#[body_index_out] := C#[body_index_out] + 1;
  M#[St_out][C#[St_out]] := 1;
  C#[St_out] := C#[St_out] + 1;
}
procedure pulseShape#tx_tail#18()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var symb: Chan (bv8);
  var len: Chan (bv8);
  var body_iterations_in: Chan (bv14);
  var body_index_in: Chan (bv14);
  var St_in: Chan (int);
  var done: Chan (bool);
  var hsp: Chan (bv8);
  var body_iterations_out: Chan (bv14);
  var body_index_out: Chan (bv14);
  var St_out: Chan (int);
  var symb_mem: bv8;
  var body_iterations: bv8;
  var body_index: bv8;
  var FILT_COEFF0: bv8;
  var FILT_COEFF1: bv8;
  var FILT_COEFF2: bv8;
  var FILT_COEFF3: bv8;
  var FILT_COEFF4: bv8;
  var hsps: Map (int) (bv8);
  var body_index_in#0: bv14;
  var body_iterations_in#0: bv14;
  var symb#0: bv8;
  var St_in#0: int;
  var len#0: bv8;
  var symb#1: bv8;
  assume (symb != len) && (symb != hsp) && (len != hsp) && (body_iterations_in != body_index_in) && (body_iterations_in != body_iterations_out) && (body_iterations_in != body_index_out) && (body_index_in != body_iterations_out) && (body_index_in != body_index_out) && (St_in != St_out) && (body_iterations_out != body_index_out);
  assume FILT_COEFF0 == 0bv8;
  assume FILT_COEFF1 == 49bv8;
  assume FILT_COEFF2 == 90bv8;
  assume FILT_COEFF3 == 118bv8;
  assume FILT_COEFF4 == 127bv8;
  assume (0 <= I#[symb]) && (I#[symb] <= R#[symb]) && (R#[symb] <= C#[symb]);
  assume (0 <= I#[len]) && (I#[len] <= R#[len]) && (R#[len] <= C#[len]);
  assume (0 <= I#[body_iterations_in]) && (I#[body_iterations_in] <= R#[body_iterations_in]) && (R#[body_iterations_in] <= C#[body_iterations_in]);
  assume (0 <= I#[body_index_in]) && (I#[body_index_in] <= R#[body_index_in]) && (R#[body_index_in] <= C#[body_index_in]);
  assume (0 <= I#[St_in]) && (I#[St_in] <= R#[St_in]) && (R#[St_in] <= C#[St_in]);
  assume (0 <= I#[done]) && (I#[done] <= R#[done]) && (R#[done] <= C#[done]);
  assume (0 <= I#[hsp]) && (I#[hsp] <= R#[hsp]) && (R#[hsp] <= C#[hsp]);
  assume (0 <= I#[body_iterations_out]) && (I#[body_iterations_out] <= R#[body_iterations_out]) && (R#[body_iterations_out] <= C#[body_iterations_out]);
  assume (0 <= I#[body_index_out]) && (I#[body_index_out] <= R#[body_index_out]) && (R#[body_index_out] <= C#[body_index_out]);
  assume (0 <= I#[St_out]) && (I#[St_out] <= R#[St_out]) && (R#[St_out] <= C#[St_out]);
  assume (1 <= (C#[body_iterations_in] - R#[body_iterations_in])) && (1 <= (C#[body_index_in] - R#[body_index_in])) && (1 <= (C#[St_in] - R#[St_in]));
  body_iterations_in#0 := M#[body_iterations_in][R#[body_iterations_in]];
  R#[body_iterations_in] := R#[body_iterations_in] + 1;
  body_index_in#0 := M#[body_index_in][R#[body_index_in]];
  R#[body_index_in] := R#[body_index_in] + 1;
  St_in#0 := M#[St_in][R#[St_in]];
  R#[St_in] := R#[St_in] + 1;
  assume (St_in#0 == 1) && (body_index_in#0 == body_iterations_in#0);
  hsps := Map#Store(hsps, 0, pulseShape#mul8(FILT_COEFF0, 127bv8));
  hsps := Map#Store(hsps, 1, pulseShape#mul8(FILT_COEFF4, symb_mem));
  hsps := Map#Store(hsps, 2, pulseShape#mul8(FILT_COEFF1, 127bv8));
  hsps := Map#Store(hsps, 3, pulseShape#mul8(FILT_COEFF3, symb_mem));
  hsps := Map#Store(hsps, 4, pulseShape#mul8(FILT_COEFF2, 127bv8));
  hsps := Map#Store(hsps, 5, pulseShape#mul8(FILT_COEFF2, symb_mem));
  hsps := Map#Store(hsps, 6, pulseShape#mul8(FILT_COEFF3, 127bv8));
  hsps := Map#Store(hsps, 7, pulseShape#mul8(FILT_COEFF1, symb_mem));
  M#[hsp][C#[hsp]] := Map#Select(hsps, 0);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 1);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 2);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 3);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 4);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 5);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 6);
  C#[hsp] := C#[hsp] + 1;
  M#[hsp][C#[hsp]] := Map#Select(hsps, 7);
  C#[hsp] := C#[hsp] + 1;
  M#[done][C#[done]] := true;
  C#[done] := C#[done] + 1;
  M#[body_iterations_out][C#[body_iterations_out]] := body_iterations_in#0;
  C#[body_iterations_out] := C#[body_iterations_out] + 1;
  M#[body_index_out][C#[body_index_out]] := body_index_in#0;
  C#[body_index_out] := C#[body_index_out] + 1;
  M#[St_out][C#[St_out]] := 0;
  C#[St_out] := C#[St_out] + 1;
}
procedure pulseShape##GuardWD#19()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var symb: Chan (bv8);
  var len: Chan (bv8);
  var body_iterations_in: Chan (bv14);
  var body_index_in: Chan (bv14);
  var St_in: Chan (int);
  var done: Chan (bool);
  var hsp: Chan (bv8);
  var body_iterations_out: Chan (bv14);
  var body_index_out: Chan (bv14);
  var St_out: Chan (int);
  var symb_mem: bv8;
  var body_iterations: bv8;
  var body_index: bv8;
  var FILT_COEFF0: bv8;
  var FILT_COEFF1: bv8;
  var FILT_COEFF2: bv8;
  var FILT_COEFF3: bv8;
  var FILT_COEFF4: bv8;
  var hsps: Map (int) (bv8);
  var body_index_in#0: bv14;
  var len#0: bv8;
  var St_in#0: int;
  var symb#1: bv8;
  var symb#0: bv8;
  var body_iterations_in#0: bv14;
  assume (symb != len) && (symb != hsp) && (len != hsp) && (body_iterations_in != body_index_in) && (body_iterations_in != body_iterations_out) && (body_iterations_in != body_index_out) && (body_index_in != body_iterations_out) && (body_index_in != body_index_out) && (St_in != St_out) && (body_iterations_out != body_index_out);
  assert {:msg "ZigBee.actor(195.1): The actions 'init' and 'tx_body' of actor 'pulseShape' might not have mutually exclusive guards (#152)"} !(true && (1 <= (C#[len] - R#[len])) && (1 <= (C#[body_iterations_in] - R#[body_iterations_in])) && (1 <= (C#[body_index_in] - R#[body_index_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[St_in][R#[St_in]] == 0) && true && (2 <= (C#[symb] - R#[symb])) && (1 <= (C#[body_iterations_in] - R#[body_iterations_in])) && (1 <= (C#[body_index_in] - R#[body_index_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[St_in][R#[St_in]] == 1) && AT#BvUlt14(M#[body_index_in][R#[body_index_in]], M#[body_iterations_in][R#[body_iterations_in]]));
  assert {:msg "ZigBee.actor(195.1): The actions 'init' and 'tx_tail' of actor 'pulseShape' might not have mutually exclusive guards (#153)"} !(true && (1 <= (C#[len] - R#[len])) && (1 <= (C#[body_iterations_in] - R#[body_iterations_in])) && (1 <= (C#[body_index_in] - R#[body_index_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[St_in][R#[St_in]] == 0) && true && (1 <= (C#[body_iterations_in] - R#[body_iterations_in])) && (1 <= (C#[body_index_in] - R#[body_index_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[St_in][R#[St_in]] == 1) && (M#[body_index_in][R#[body_index_in]] == M#[body_iterations_in][R#[body_iterations_in]]));
  assert {:msg "ZigBee.actor(195.1): The actions 'tx_body' and 'tx_tail' of actor 'pulseShape' might not have mutually exclusive guards (#154)"} !(true && (2 <= (C#[symb] - R#[symb])) && (1 <= (C#[body_iterations_in] - R#[body_iterations_in])) && (1 <= (C#[body_index_in] - R#[body_index_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[St_in][R#[St_in]] == 1) && AT#BvUlt14(M#[body_index_in][R#[body_index_in]], M#[body_iterations_in][R#[body_iterations_in]]) && true && (1 <= (C#[body_iterations_in] - R#[body_iterations_in])) && (1 <= (C#[body_index_in] - R#[body_index_in])) && (1 <= (C#[St_in] - R#[St_in])) && (M#[St_in][R#[St_in]] == 1) && (M#[body_index_in][R#[body_index_in]] == M#[body_iterations_in][R#[body_iterations_in]]));
}
procedure pulseShapeNw#init#20()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pulseShapeNw#a: Actor;
  var pulseShapeNw#in_symb: Chan (bv8);
  var pulseShapeNw#in_len: Chan (bv8);
  var pulseShapeNw#body_iterations: Chan (bv14);
  var pulseShapeNw#body_index: Chan (bv14);
  var pulseShapeNw#St: Chan (int);
  var pulseShapeNw#out_hsp: Chan (bv8);
  var pulseShapeNw#out_done: Chan (bool);
  var AV#a#symb_mem: bv8;
  var AV#a#body_iterations: bv8;
  var AV#a#body_index: bv8;
  var AV#a#FILT_COEFF0: bv8;
  var AV#a#FILT_COEFF1: bv8;
  var AV#a#FILT_COEFF2: bv8;
  var AV#a#FILT_COEFF3: bv8;
  var AV#a#FILT_COEFF4: bv8;
  var AV#a#hsps: Map (int) (bv8);
  assume (pulseShapeNw#in_symb != pulseShapeNw#in_len) && (pulseShapeNw#in_symb != pulseShapeNw#out_hsp) && (pulseShapeNw#in_len != pulseShapeNw#out_hsp) && (pulseShapeNw#body_iterations != pulseShapeNw#body_index);
  assume 0 <= I#[pulseShapeNw#in_symb];
  assume I#[pulseShapeNw#in_symb] <= R#[pulseShapeNw#in_symb];
  assume R#[pulseShapeNw#in_symb] <= C#[pulseShapeNw#in_symb];
  assume 0 <= I#[pulseShapeNw#in_len];
  assume I#[pulseShapeNw#in_len] <= R#[pulseShapeNw#in_len];
  assume R#[pulseShapeNw#in_len] <= C#[pulseShapeNw#in_len];
  assume 0 <= I#[pulseShapeNw#body_iterations];
  assume I#[pulseShapeNw#body_iterations] <= R#[pulseShapeNw#body_iterations];
  assume R#[pulseShapeNw#body_iterations] <= C#[pulseShapeNw#body_iterations];
  assume 0 <= I#[pulseShapeNw#body_index];
  assume I#[pulseShapeNw#body_index] <= R#[pulseShapeNw#body_index];
  assume R#[pulseShapeNw#body_index] <= C#[pulseShapeNw#body_index];
  assume 0 <= I#[pulseShapeNw#St];
  assume I#[pulseShapeNw#St] <= R#[pulseShapeNw#St];
  assume R#[pulseShapeNw#St] <= C#[pulseShapeNw#St];
  assume 0 <= I#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] <= R#[pulseShapeNw#out_hsp];
  assume R#[pulseShapeNw#out_hsp] <= C#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] == R#[pulseShapeNw#out_hsp];
  assume 0 <= I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] <= R#[pulseShapeNw#out_done];
  assume R#[pulseShapeNw#out_done] <= C#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] == R#[pulseShapeNw#out_done];
  assume (B#[pulseShapeNw#in_symb] == 576) && (B#[pulseShapeNw#in_len] == 1) && (B#[pulseShapeNw#out_done] == 1) && (B#[pulseShapeNw#out_hsp] == 4616);
  assume C#[pulseShapeNw#in_symb] == 0;
  assume R#[pulseShapeNw#in_symb] == 0;
  assume C#[pulseShapeNw#in_len] == 0;
  assume R#[pulseShapeNw#in_len] == 0;
  assume C#[pulseShapeNw#body_iterations] == 0;
  assume R#[pulseShapeNw#body_iterations] == 0;
  assume C#[pulseShapeNw#body_index] == 0;
  assume R#[pulseShapeNw#body_index] == 0;
  assume C#[pulseShapeNw#St] == 0;
  assume R#[pulseShapeNw#St] == 0;
  assume C#[pulseShapeNw#out_hsp] == 0;
  assume R#[pulseShapeNw#out_hsp] == 0;
  assume C#[pulseShapeNw#out_done] == 0;
  assume R#[pulseShapeNw#out_done] == 0;
  M#[pulseShapeNw#body_iterations][C#[pulseShapeNw#body_iterations]] := 0bv14;
  C#[pulseShapeNw#body_iterations] := C#[pulseShapeNw#body_iterations] + 1;
  M#[pulseShapeNw#body_index][C#[pulseShapeNw#body_index]] := 0bv14;
  C#[pulseShapeNw#body_index] := C#[pulseShapeNw#body_index] + 1;
  M#[pulseShapeNw#St][C#[pulseShapeNw#St]] := 0;
  C#[pulseShapeNw#St] := C#[pulseShapeNw#St] + 1;
  assert {:msg "ZigBee.actor(334.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#155)"} I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assert {:msg "ZigBee.actor(335.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#156)"} I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assert {:msg "ZigBee.actor(336.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#157)"} I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assert {:msg "ZigBee.actor(341.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#158)"} ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assert {:msg "ZigBee.actor(344.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#159)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assert {:msg "ZigBee.actor(345.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#160)"} AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assert {:msg "ZigBee.actor(347.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#161)"} ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assert {:msg "ZigBee.actor(348.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#162)"} ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assert {:msg "ZigBee.actor(354.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#163)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assert {:msg "ZigBee.actor(362.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#164)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assert {:msg "ZigBee.actor(369.15): Initialization of network 'pulseShapeNw' might not establish the channel invariant (#165)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
  I# := R#;
  assert {:msg "ZigBee.actor(339.13): Initialization of network 'pulseShapeNw' might not establish the network invariant (#166)"} ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assert {:msg "ZigBee.actor(340.13): Initialization of network 'pulseShapeNw' might not establish the network invariant (#167)"} M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0;
  assert {:msg "Initialization of network 'pulseShapeNw' might not establish the network invariant: Unread tokens might be left on channel in_symb (#168)"} (C#[pulseShapeNw#in_symb] - R#[pulseShapeNw#in_symb]) == 0;
  assert {:msg "Initialization of network 'pulseShapeNw' might not establish the network invariant: Unread tokens might be left on channel in_len (#169)"} (C#[pulseShapeNw#in_len] - R#[pulseShapeNw#in_len]) == 0;
  assert {:msg "Initialization of network 'pulseShapeNw' might not establish the network invariant: Unread tokens might be left on channel out_hsp (#170)"} (C#[pulseShapeNw#out_hsp] - R#[pulseShapeNw#out_hsp]) == 0;
  assert {:msg "Initialization of network 'pulseShapeNw' might not establish the network invariant: Unread tokens might be left on channel out_done (#171)"} (C#[pulseShapeNw#out_done] - R#[pulseShapeNw#out_done]) == 0;
}
procedure pulseShapeNw##pulseShape#init#21()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pulseShapeNw#a: Actor;
  var pulseShapeNw#in_symb: Chan (bv8);
  var pulseShapeNw#in_len: Chan (bv8);
  var pulseShapeNw#body_iterations: Chan (bv14);
  var pulseShapeNw#body_index: Chan (bv14);
  var pulseShapeNw#St: Chan (int);
  var pulseShapeNw#out_hsp: Chan (bv8);
  var pulseShapeNw#out_done: Chan (bool);
  var AV#a#symb_mem: bv8;
  var AV#a#body_iterations: bv8;
  var AV#a#body_index: bv8;
  var AV#a#FILT_COEFF0: bv8;
  var AV#a#FILT_COEFF1: bv8;
  var AV#a#FILT_COEFF2: bv8;
  var AV#a#FILT_COEFF3: bv8;
  var AV#a#FILT_COEFF4: bv8;
  var AV#a#hsps: Map (int) (bv8);
  var len#len_in: bv8;
  var body_iterations_in#body_iterations: bv14;
  var body_index_in#body_index: bv14;
  var St_in#St: int;
  assume (pulseShapeNw#in_symb != pulseShapeNw#in_len) && (pulseShapeNw#in_symb != pulseShapeNw#out_hsp) && (pulseShapeNw#in_len != pulseShapeNw#out_hsp) && (pulseShapeNw#body_iterations != pulseShapeNw#body_index);
  assume 0 <= I#[pulseShapeNw#in_symb];
  assume I#[pulseShapeNw#in_symb] <= R#[pulseShapeNw#in_symb];
  assume R#[pulseShapeNw#in_symb] <= C#[pulseShapeNw#in_symb];
  assume 0 <= I#[pulseShapeNw#in_len];
  assume I#[pulseShapeNw#in_len] <= R#[pulseShapeNw#in_len];
  assume R#[pulseShapeNw#in_len] <= C#[pulseShapeNw#in_len];
  assume 0 <= I#[pulseShapeNw#body_iterations];
  assume I#[pulseShapeNw#body_iterations] <= R#[pulseShapeNw#body_iterations];
  assume R#[pulseShapeNw#body_iterations] <= C#[pulseShapeNw#body_iterations];
  assume 0 <= I#[pulseShapeNw#body_index];
  assume I#[pulseShapeNw#body_index] <= R#[pulseShapeNw#body_index];
  assume R#[pulseShapeNw#body_index] <= C#[pulseShapeNw#body_index];
  assume 0 <= I#[pulseShapeNw#St];
  assume I#[pulseShapeNw#St] <= R#[pulseShapeNw#St];
  assume R#[pulseShapeNw#St] <= C#[pulseShapeNw#St];
  assume 0 <= I#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] <= R#[pulseShapeNw#out_hsp];
  assume R#[pulseShapeNw#out_hsp] <= C#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] == R#[pulseShapeNw#out_hsp];
  assume 0 <= I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] <= R#[pulseShapeNw#out_done];
  assume R#[pulseShapeNw#out_done] <= C#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] == R#[pulseShapeNw#out_done];
  assume (B#[pulseShapeNw#in_symb] == 576) && (B#[pulseShapeNw#in_len] == 1) && (B#[pulseShapeNw#out_done] == 1) && (B#[pulseShapeNw#out_hsp] == 4616);
  I#sub[pulseShapeNw#in_symb] := R#[pulseShapeNw#in_symb];
  I#sub[pulseShapeNw#in_len] := R#[pulseShapeNw#in_len];
  I#sub[pulseShapeNw#body_iterations] := R#[pulseShapeNw#body_iterations];
  I#sub[pulseShapeNw#body_index] := R#[pulseShapeNw#body_index];
  I#sub[pulseShapeNw#St] := R#[pulseShapeNw#St];
  I#sub[pulseShapeNw#out_done] := C#[pulseShapeNw#out_done];
  I#sub[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp];
  I#sub[pulseShapeNw#body_iterations] := C#[pulseShapeNw#body_iterations];
  I#sub[pulseShapeNw#body_index] := C#[pulseShapeNw#body_index];
  I#sub[pulseShapeNw#St] := C#[pulseShapeNw#St];
  assume I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assume I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assume ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assume AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assume ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assume ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
  assume M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]] == 9bv8;
  assume ((C#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) <= 576) && ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) <= 1);
  assume (1 <= (C#[pulseShapeNw#in_len] - R#[pulseShapeNw#in_len])) && (1 <= (C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations])) && (1 <= (C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index])) && (1 <= (C#[pulseShapeNw#St] - R#[pulseShapeNw#St])) && (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0);
  len#len_in := M#[pulseShapeNw#in_len][R#[pulseShapeNw#in_len]];
  R#[pulseShapeNw#in_len] := R#[pulseShapeNw#in_len] + 1;
  body_iterations_in#body_iterations := M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]];
  R#[pulseShapeNw#body_iterations] := R#[pulseShapeNw#body_iterations] + 1;
  body_index_in#body_index := M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]];
  R#[pulseShapeNw#body_index] := R#[pulseShapeNw#body_index] + 1;
  St_in#St := M#[pulseShapeNw#St][R#[pulseShapeNw#St]];
  R#[pulseShapeNw#St] := R#[pulseShapeNw#St] + 1;
  havoc AV#a#symb_mem;
  M#[pulseShapeNw#body_iterations][C#[pulseShapeNw#body_iterations]] := AT#BvMul14(0bv6 ++ len#len_in, 32bv14);
  C#[pulseShapeNw#body_iterations] := C#[pulseShapeNw#body_iterations] + 1;
  M#[pulseShapeNw#body_index][C#[pulseShapeNw#body_index]] := 0bv14;
  C#[pulseShapeNw#body_index] := C#[pulseShapeNw#body_index] + 1;
  M#[pulseShapeNw#St][C#[pulseShapeNw#St]] := 1;
  C#[pulseShapeNw#St] := C#[pulseShapeNw#St] + 1;
  assert {:msg "ZigBee.actor(334.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#172)"} I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assert {:msg "ZigBee.actor(335.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#173)"} I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assert {:msg "ZigBee.actor(336.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#174)"} I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assert {:msg "ZigBee.actor(341.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#175)"} ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assert {:msg "ZigBee.actor(344.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#176)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assert {:msg "ZigBee.actor(345.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#177)"} AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assert {:msg "ZigBee.actor(347.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#178)"} ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assert {:msg "ZigBee.actor(348.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#179)"} ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assert {:msg "ZigBee.actor(354.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#180)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assert {:msg "ZigBee.actor(362.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#181)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assert {:msg "ZigBee.actor(369.15): Action at ZigBee.actor(238.2) ('init') for actor instance 'a' might not preserve the channel invariant (#182)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
}
procedure pulseShapeNw##pulseShape#tx_body#22()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pulseShapeNw#a: Actor;
  var pulseShapeNw#in_symb: Chan (bv8);
  var pulseShapeNw#in_len: Chan (bv8);
  var pulseShapeNw#body_iterations: Chan (bv14);
  var pulseShapeNw#body_index: Chan (bv14);
  var pulseShapeNw#St: Chan (int);
  var pulseShapeNw#out_hsp: Chan (bv8);
  var pulseShapeNw#out_done: Chan (bool);
  var AV#a#symb_mem: bv8;
  var AV#a#body_iterations: bv8;
  var AV#a#body_index: bv8;
  var AV#a#FILT_COEFF0: bv8;
  var AV#a#FILT_COEFF1: bv8;
  var AV#a#FILT_COEFF2: bv8;
  var AV#a#FILT_COEFF3: bv8;
  var AV#a#FILT_COEFF4: bv8;
  var AV#a#hsps: Map (int) (bv8);
  var symb#symb_1: bv8;
  var symb#symb_2: bv8;
  var body_iterations_in#body_iterations: bv14;
  var body_index_in#body_index: bv14;
  var St_in#St: int;
  assume (pulseShapeNw#in_symb != pulseShapeNw#in_len) && (pulseShapeNw#in_symb != pulseShapeNw#out_hsp) && (pulseShapeNw#in_len != pulseShapeNw#out_hsp) && (pulseShapeNw#body_iterations != pulseShapeNw#body_index);
  assume 0 <= I#[pulseShapeNw#in_symb];
  assume I#[pulseShapeNw#in_symb] <= R#[pulseShapeNw#in_symb];
  assume R#[pulseShapeNw#in_symb] <= C#[pulseShapeNw#in_symb];
  assume 0 <= I#[pulseShapeNw#in_len];
  assume I#[pulseShapeNw#in_len] <= R#[pulseShapeNw#in_len];
  assume R#[pulseShapeNw#in_len] <= C#[pulseShapeNw#in_len];
  assume 0 <= I#[pulseShapeNw#body_iterations];
  assume I#[pulseShapeNw#body_iterations] <= R#[pulseShapeNw#body_iterations];
  assume R#[pulseShapeNw#body_iterations] <= C#[pulseShapeNw#body_iterations];
  assume 0 <= I#[pulseShapeNw#body_index];
  assume I#[pulseShapeNw#body_index] <= R#[pulseShapeNw#body_index];
  assume R#[pulseShapeNw#body_index] <= C#[pulseShapeNw#body_index];
  assume 0 <= I#[pulseShapeNw#St];
  assume I#[pulseShapeNw#St] <= R#[pulseShapeNw#St];
  assume R#[pulseShapeNw#St] <= C#[pulseShapeNw#St];
  assume 0 <= I#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] <= R#[pulseShapeNw#out_hsp];
  assume R#[pulseShapeNw#out_hsp] <= C#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] == R#[pulseShapeNw#out_hsp];
  assume 0 <= I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] <= R#[pulseShapeNw#out_done];
  assume R#[pulseShapeNw#out_done] <= C#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] == R#[pulseShapeNw#out_done];
  assume (B#[pulseShapeNw#in_symb] == 576) && (B#[pulseShapeNw#in_len] == 1) && (B#[pulseShapeNw#out_done] == 1) && (B#[pulseShapeNw#out_hsp] == 4616);
  I#sub[pulseShapeNw#in_symb] := R#[pulseShapeNw#in_symb];
  I#sub[pulseShapeNw#in_len] := R#[pulseShapeNw#in_len];
  I#sub[pulseShapeNw#body_iterations] := R#[pulseShapeNw#body_iterations];
  I#sub[pulseShapeNw#body_index] := R#[pulseShapeNw#body_index];
  I#sub[pulseShapeNw#St] := R#[pulseShapeNw#St];
  I#sub[pulseShapeNw#out_done] := C#[pulseShapeNw#out_done];
  I#sub[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp];
  I#sub[pulseShapeNw#body_iterations] := C#[pulseShapeNw#body_iterations];
  I#sub[pulseShapeNw#body_index] := C#[pulseShapeNw#body_index];
  I#sub[pulseShapeNw#St] := C#[pulseShapeNw#St];
  assume I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assume I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assume ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assume AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assume ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assume ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
  assume M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]] == 9bv8;
  assume ((C#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) <= 576) && ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) <= 1);
  assume (2 <= (C#[pulseShapeNw#in_symb] - R#[pulseShapeNw#in_symb])) && (1 <= (C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations])) && (1 <= (C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index])) && (1 <= (C#[pulseShapeNw#St] - R#[pulseShapeNw#St])) && (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) && AT#BvUlt14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  symb#symb_1 := M#[pulseShapeNw#in_symb][R#[pulseShapeNw#in_symb]];
  R#[pulseShapeNw#in_symb] := R#[pulseShapeNw#in_symb] + 1;
  symb#symb_2 := M#[pulseShapeNw#in_symb][R#[pulseShapeNw#in_symb]];
  R#[pulseShapeNw#in_symb] := R#[pulseShapeNw#in_symb] + 1;
  body_iterations_in#body_iterations := M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]];
  R#[pulseShapeNw#body_iterations] := R#[pulseShapeNw#body_iterations] + 1;
  body_index_in#body_index := M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]];
  R#[pulseShapeNw#body_index] := R#[pulseShapeNw#body_index] + 1;
  St_in#St := M#[pulseShapeNw#St][R#[pulseShapeNw#St]];
  R#[pulseShapeNw#St] := R#[pulseShapeNw#St] + 1;
  havoc AV#a#symb_mem;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 0);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 1);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 2);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 3);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 4);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 5);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 6);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 7);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 8);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 9);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 10);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 11);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 12);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 13);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 14);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 15);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#body_iterations][C#[pulseShapeNw#body_iterations]] := body_iterations_in#body_iterations;
  C#[pulseShapeNw#body_iterations] := C#[pulseShapeNw#body_iterations] + 1;
  M#[pulseShapeNw#body_index][C#[pulseShapeNw#body_index]] := AT#BvAdd14(body_index_in#body_index, 1bv14);
  C#[pulseShapeNw#body_index] := C#[pulseShapeNw#body_index] + 1;
  M#[pulseShapeNw#St][C#[pulseShapeNw#St]] := 1;
  C#[pulseShapeNw#St] := C#[pulseShapeNw#St] + 1;
  assert {:msg "ZigBee.actor(334.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#183)"} I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assert {:msg "ZigBee.actor(335.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#184)"} I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assert {:msg "ZigBee.actor(336.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#185)"} I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assert {:msg "ZigBee.actor(341.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#186)"} ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assert {:msg "ZigBee.actor(344.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#187)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assert {:msg "ZigBee.actor(345.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#188)"} AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assert {:msg "ZigBee.actor(347.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#189)"} ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assert {:msg "ZigBee.actor(348.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#190)"} ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assert {:msg "ZigBee.actor(354.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#191)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assert {:msg "ZigBee.actor(362.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#192)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assert {:msg "ZigBee.actor(369.15): Action at ZigBee.actor(254.2) ('tx_body') for actor instance 'a' might not preserve the channel invariant (#193)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
}
procedure pulseShapeNw##pulseShape#tx_tail#23()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pulseShapeNw#a: Actor;
  var pulseShapeNw#in_symb: Chan (bv8);
  var pulseShapeNw#in_len: Chan (bv8);
  var pulseShapeNw#body_iterations: Chan (bv14);
  var pulseShapeNw#body_index: Chan (bv14);
  var pulseShapeNw#St: Chan (int);
  var pulseShapeNw#out_hsp: Chan (bv8);
  var pulseShapeNw#out_done: Chan (bool);
  var AV#a#symb_mem: bv8;
  var AV#a#body_iterations: bv8;
  var AV#a#body_index: bv8;
  var AV#a#FILT_COEFF0: bv8;
  var AV#a#FILT_COEFF1: bv8;
  var AV#a#FILT_COEFF2: bv8;
  var AV#a#FILT_COEFF3: bv8;
  var AV#a#FILT_COEFF4: bv8;
  var AV#a#hsps: Map (int) (bv8);
  var body_iterations_in#body_iterations: bv14;
  var body_index_in#body_index: bv14;
  var St_in#St: int;
  assume (pulseShapeNw#in_symb != pulseShapeNw#in_len) && (pulseShapeNw#in_symb != pulseShapeNw#out_hsp) && (pulseShapeNw#in_len != pulseShapeNw#out_hsp) && (pulseShapeNw#body_iterations != pulseShapeNw#body_index);
  assume 0 <= I#[pulseShapeNw#in_symb];
  assume I#[pulseShapeNw#in_symb] <= R#[pulseShapeNw#in_symb];
  assume R#[pulseShapeNw#in_symb] <= C#[pulseShapeNw#in_symb];
  assume 0 <= I#[pulseShapeNw#in_len];
  assume I#[pulseShapeNw#in_len] <= R#[pulseShapeNw#in_len];
  assume R#[pulseShapeNw#in_len] <= C#[pulseShapeNw#in_len];
  assume 0 <= I#[pulseShapeNw#body_iterations];
  assume I#[pulseShapeNw#body_iterations] <= R#[pulseShapeNw#body_iterations];
  assume R#[pulseShapeNw#body_iterations] <= C#[pulseShapeNw#body_iterations];
  assume 0 <= I#[pulseShapeNw#body_index];
  assume I#[pulseShapeNw#body_index] <= R#[pulseShapeNw#body_index];
  assume R#[pulseShapeNw#body_index] <= C#[pulseShapeNw#body_index];
  assume 0 <= I#[pulseShapeNw#St];
  assume I#[pulseShapeNw#St] <= R#[pulseShapeNw#St];
  assume R#[pulseShapeNw#St] <= C#[pulseShapeNw#St];
  assume 0 <= I#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] <= R#[pulseShapeNw#out_hsp];
  assume R#[pulseShapeNw#out_hsp] <= C#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] == R#[pulseShapeNw#out_hsp];
  assume 0 <= I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] <= R#[pulseShapeNw#out_done];
  assume R#[pulseShapeNw#out_done] <= C#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] == R#[pulseShapeNw#out_done];
  assume (B#[pulseShapeNw#in_symb] == 576) && (B#[pulseShapeNw#in_len] == 1) && (B#[pulseShapeNw#out_done] == 1) && (B#[pulseShapeNw#out_hsp] == 4616);
  I#sub[pulseShapeNw#in_symb] := R#[pulseShapeNw#in_symb];
  I#sub[pulseShapeNw#in_len] := R#[pulseShapeNw#in_len];
  I#sub[pulseShapeNw#body_iterations] := R#[pulseShapeNw#body_iterations];
  I#sub[pulseShapeNw#body_index] := R#[pulseShapeNw#body_index];
  I#sub[pulseShapeNw#St] := R#[pulseShapeNw#St];
  I#sub[pulseShapeNw#out_done] := C#[pulseShapeNw#out_done];
  I#sub[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp];
  I#sub[pulseShapeNw#body_iterations] := C#[pulseShapeNw#body_iterations];
  I#sub[pulseShapeNw#body_index] := C#[pulseShapeNw#body_index];
  I#sub[pulseShapeNw#St] := C#[pulseShapeNw#St];
  assume I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assume I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assume ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assume AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assume ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assume ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
  assume M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]] == 9bv8;
  assume ((C#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) <= 576) && ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) <= 1);
  assume (1 <= (C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations])) && (1 <= (C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index])) && (1 <= (C#[pulseShapeNw#St] - R#[pulseShapeNw#St])) && (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) && (M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]] == M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  body_iterations_in#body_iterations := M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]];
  R#[pulseShapeNw#body_iterations] := R#[pulseShapeNw#body_iterations] + 1;
  body_index_in#body_index := M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]];
  R#[pulseShapeNw#body_index] := R#[pulseShapeNw#body_index] + 1;
  St_in#St := M#[pulseShapeNw#St][R#[pulseShapeNw#St]];
  R#[pulseShapeNw#St] := R#[pulseShapeNw#St] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 0);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 1);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 2);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 3);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 4);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 5);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 6);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_hsp][C#[pulseShapeNw#out_hsp]] := Map#Select(AV#a#hsps, 7);
  C#[pulseShapeNw#out_hsp] := C#[pulseShapeNw#out_hsp] + 1;
  M#[pulseShapeNw#out_done][C#[pulseShapeNw#out_done]] := true;
  C#[pulseShapeNw#out_done] := C#[pulseShapeNw#out_done] + 1;
  M#[pulseShapeNw#body_iterations][C#[pulseShapeNw#body_iterations]] := body_iterations_in#body_iterations;
  C#[pulseShapeNw#body_iterations] := C#[pulseShapeNw#body_iterations] + 1;
  M#[pulseShapeNw#body_index][C#[pulseShapeNw#body_index]] := body_index_in#body_index;
  C#[pulseShapeNw#body_index] := C#[pulseShapeNw#body_index] + 1;
  M#[pulseShapeNw#St][C#[pulseShapeNw#St]] := 0;
  C#[pulseShapeNw#St] := C#[pulseShapeNw#St] + 1;
  assert {:msg "ZigBee.actor(334.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#194)"} I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assert {:msg "ZigBee.actor(335.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#195)"} I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assert {:msg "ZigBee.actor(336.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#196)"} I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assert {:msg "ZigBee.actor(341.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#197)"} ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assert {:msg "ZigBee.actor(344.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#198)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assert {:msg "ZigBee.actor(345.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#199)"} AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assert {:msg "ZigBee.actor(347.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#200)"} ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assert {:msg "ZigBee.actor(348.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#201)"} ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assert {:msg "ZigBee.actor(354.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#202)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assert {:msg "ZigBee.actor(362.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#203)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assert {:msg "ZigBee.actor(369.15): Action at ZigBee.actor(298.2) ('tx_tail') for actor instance 'a' might not preserve the channel invariant (#204)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
}
procedure pulseShapeNw#anon$4#input#symb#24()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pulseShapeNw#a: Actor;
  var pulseShapeNw#in_symb: Chan (bv8);
  var pulseShapeNw#in_len: Chan (bv8);
  var pulseShapeNw#body_iterations: Chan (bv14);
  var pulseShapeNw#body_index: Chan (bv14);
  var pulseShapeNw#St: Chan (int);
  var pulseShapeNw#out_hsp: Chan (bv8);
  var pulseShapeNw#out_done: Chan (bool);
  var AV#a#symb_mem: bv8;
  var AV#a#body_iterations: bv8;
  var AV#a#body_index: bv8;
  var AV#a#FILT_COEFF0: bv8;
  var AV#a#FILT_COEFF1: bv8;
  var AV#a#FILT_COEFF2: bv8;
  var AV#a#FILT_COEFF3: bv8;
  var AV#a#FILT_COEFF4: bv8;
  var AV#a#hsps: Map (int) (bv8);
  assume (pulseShapeNw#in_symb != pulseShapeNw#in_len) && (pulseShapeNw#in_symb != pulseShapeNw#out_hsp) && (pulseShapeNw#in_len != pulseShapeNw#out_hsp) && (pulseShapeNw#body_iterations != pulseShapeNw#body_index);
  assume 0 <= I#[pulseShapeNw#in_symb];
  assume I#[pulseShapeNw#in_symb] <= R#[pulseShapeNw#in_symb];
  assume R#[pulseShapeNw#in_symb] <= C#[pulseShapeNw#in_symb];
  assume 0 <= I#[pulseShapeNw#in_len];
  assume I#[pulseShapeNw#in_len] <= R#[pulseShapeNw#in_len];
  assume R#[pulseShapeNw#in_len] <= C#[pulseShapeNw#in_len];
  assume 0 <= I#[pulseShapeNw#body_iterations];
  assume I#[pulseShapeNw#body_iterations] <= R#[pulseShapeNw#body_iterations];
  assume R#[pulseShapeNw#body_iterations] <= C#[pulseShapeNw#body_iterations];
  assume 0 <= I#[pulseShapeNw#body_index];
  assume I#[pulseShapeNw#body_index] <= R#[pulseShapeNw#body_index];
  assume R#[pulseShapeNw#body_index] <= C#[pulseShapeNw#body_index];
  assume 0 <= I#[pulseShapeNw#St];
  assume I#[pulseShapeNw#St] <= R#[pulseShapeNw#St];
  assume R#[pulseShapeNw#St] <= C#[pulseShapeNw#St];
  assume 0 <= I#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] <= R#[pulseShapeNw#out_hsp];
  assume R#[pulseShapeNw#out_hsp] <= C#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] == R#[pulseShapeNw#out_hsp];
  assume 0 <= I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] <= R#[pulseShapeNw#out_done];
  assume R#[pulseShapeNw#out_done] <= C#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] == R#[pulseShapeNw#out_done];
  assume (B#[pulseShapeNw#in_symb] == 576) && (B#[pulseShapeNw#in_len] == 1) && (B#[pulseShapeNw#out_done] == 1) && (B#[pulseShapeNw#out_hsp] == 4616);
  assume (B#[pulseShapeNw#in_symb] == 576) && (B#[pulseShapeNw#in_len] == 1) && (B#[pulseShapeNw#out_done] == 1) && (B#[pulseShapeNw#out_hsp] == 4616);
  assume (C#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) < 576;
  assume I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assume I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assume ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assume AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assume ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assume ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
  assume M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]] == 9bv8;
  assume ((C#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) <= 576) && ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) <= 1);
  C#[pulseShapeNw#in_symb] := C#[pulseShapeNw#in_symb] + 1;
  assume M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]] == 9bv8;
  assert {:msg "ZigBee.actor(334.15): Channel invariant might be falsified by network input (#205)"} I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assert {:msg "ZigBee.actor(335.15): Channel invariant might be falsified by network input (#206)"} I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assert {:msg "ZigBee.actor(336.15): Channel invariant might be falsified by network input (#207)"} I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assert {:msg "ZigBee.actor(341.15): Channel invariant might be falsified by network input (#208)"} ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assert {:msg "ZigBee.actor(344.15): Channel invariant might be falsified by network input (#209)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assert {:msg "ZigBee.actor(345.15): Channel invariant might be falsified by network input (#210)"} AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assert {:msg "ZigBee.actor(347.15): Channel invariant might be falsified by network input (#211)"} ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assert {:msg "ZigBee.actor(348.15): Channel invariant might be falsified by network input (#212)"} ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assert {:msg "ZigBee.actor(354.15): Channel invariant might be falsified by network input (#213)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assert {:msg "ZigBee.actor(362.15): Channel invariant might be falsified by network input (#214)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assert {:msg "ZigBee.actor(369.15): Channel invariant might be falsified by network input (#215)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
}
procedure pulseShapeNw#anon$4#input#len#25()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pulseShapeNw#a: Actor;
  var pulseShapeNw#in_symb: Chan (bv8);
  var pulseShapeNw#in_len: Chan (bv8);
  var pulseShapeNw#body_iterations: Chan (bv14);
  var pulseShapeNw#body_index: Chan (bv14);
  var pulseShapeNw#St: Chan (int);
  var pulseShapeNw#out_hsp: Chan (bv8);
  var pulseShapeNw#out_done: Chan (bool);
  var AV#a#symb_mem: bv8;
  var AV#a#body_iterations: bv8;
  var AV#a#body_index: bv8;
  var AV#a#FILT_COEFF0: bv8;
  var AV#a#FILT_COEFF1: bv8;
  var AV#a#FILT_COEFF2: bv8;
  var AV#a#FILT_COEFF3: bv8;
  var AV#a#FILT_COEFF4: bv8;
  var AV#a#hsps: Map (int) (bv8);
  assume (pulseShapeNw#in_symb != pulseShapeNw#in_len) && (pulseShapeNw#in_symb != pulseShapeNw#out_hsp) && (pulseShapeNw#in_len != pulseShapeNw#out_hsp) && (pulseShapeNw#body_iterations != pulseShapeNw#body_index);
  assume 0 <= I#[pulseShapeNw#in_symb];
  assume I#[pulseShapeNw#in_symb] <= R#[pulseShapeNw#in_symb];
  assume R#[pulseShapeNw#in_symb] <= C#[pulseShapeNw#in_symb];
  assume 0 <= I#[pulseShapeNw#in_len];
  assume I#[pulseShapeNw#in_len] <= R#[pulseShapeNw#in_len];
  assume R#[pulseShapeNw#in_len] <= C#[pulseShapeNw#in_len];
  assume 0 <= I#[pulseShapeNw#body_iterations];
  assume I#[pulseShapeNw#body_iterations] <= R#[pulseShapeNw#body_iterations];
  assume R#[pulseShapeNw#body_iterations] <= C#[pulseShapeNw#body_iterations];
  assume 0 <= I#[pulseShapeNw#body_index];
  assume I#[pulseShapeNw#body_index] <= R#[pulseShapeNw#body_index];
  assume R#[pulseShapeNw#body_index] <= C#[pulseShapeNw#body_index];
  assume 0 <= I#[pulseShapeNw#St];
  assume I#[pulseShapeNw#St] <= R#[pulseShapeNw#St];
  assume R#[pulseShapeNw#St] <= C#[pulseShapeNw#St];
  assume 0 <= I#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] <= R#[pulseShapeNw#out_hsp];
  assume R#[pulseShapeNw#out_hsp] <= C#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] == R#[pulseShapeNw#out_hsp];
  assume 0 <= I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] <= R#[pulseShapeNw#out_done];
  assume R#[pulseShapeNw#out_done] <= C#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] == R#[pulseShapeNw#out_done];
  assume (B#[pulseShapeNw#in_symb] == 576) && (B#[pulseShapeNw#in_len] == 1) && (B#[pulseShapeNw#out_done] == 1) && (B#[pulseShapeNw#out_hsp] == 4616);
  assume (B#[pulseShapeNw#in_symb] == 576) && (B#[pulseShapeNw#in_len] == 1) && (B#[pulseShapeNw#out_done] == 1) && (B#[pulseShapeNw#out_hsp] == 4616);
  assume (C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) < 1;
  assume I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assume I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assume ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assume AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assume ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assume ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
  assume M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]] == 9bv8;
  assume ((C#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) <= 576) && ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) <= 1);
  C#[pulseShapeNw#in_len] := C#[pulseShapeNw#in_len] + 1;
  assume M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]] == 9bv8;
  assert {:msg "ZigBee.actor(334.15): Channel invariant might be falsified by network input (#216)"} I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assert {:msg "ZigBee.actor(335.15): Channel invariant might be falsified by network input (#217)"} I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assert {:msg "ZigBee.actor(336.15): Channel invariant might be falsified by network input (#218)"} I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assert {:msg "ZigBee.actor(341.15): Channel invariant might be falsified by network input (#219)"} ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assert {:msg "ZigBee.actor(344.15): Channel invariant might be falsified by network input (#220)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assert {:msg "ZigBee.actor(345.15): Channel invariant might be falsified by network input (#221)"} AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assert {:msg "ZigBee.actor(347.15): Channel invariant might be falsified by network input (#222)"} ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assert {:msg "ZigBee.actor(348.15): Channel invariant might be falsified by network input (#223)"} ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assert {:msg "ZigBee.actor(354.15): Channel invariant might be falsified by network input (#224)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assert {:msg "ZigBee.actor(362.15): Channel invariant might be falsified by network input (#225)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assert {:msg "ZigBee.actor(369.15): Channel invariant might be falsified by network input (#226)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
}
procedure pulseShapeNw#anon$4#exit#26()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var pulseShapeNw#a: Actor;
  var pulseShapeNw#in_symb: Chan (bv8);
  var pulseShapeNw#in_len: Chan (bv8);
  var pulseShapeNw#body_iterations: Chan (bv14);
  var pulseShapeNw#body_index: Chan (bv14);
  var pulseShapeNw#St: Chan (int);
  var pulseShapeNw#out_hsp: Chan (bv8);
  var pulseShapeNw#out_done: Chan (bool);
  var AV#a#symb_mem: bv8;
  var AV#a#body_iterations: bv8;
  var AV#a#body_index: bv8;
  var AV#a#FILT_COEFF0: bv8;
  var AV#a#FILT_COEFF1: bv8;
  var AV#a#FILT_COEFF2: bv8;
  var AV#a#FILT_COEFF3: bv8;
  var AV#a#FILT_COEFF4: bv8;
  var AV#a#hsps: Map (int) (bv8);
  assume (pulseShapeNw#in_symb != pulseShapeNw#in_len) && (pulseShapeNw#in_symb != pulseShapeNw#out_hsp) && (pulseShapeNw#in_len != pulseShapeNw#out_hsp) && (pulseShapeNw#body_iterations != pulseShapeNw#body_index);
  assume 0 <= I#[pulseShapeNw#in_symb];
  assume I#[pulseShapeNw#in_symb] <= R#[pulseShapeNw#in_symb];
  assume R#[pulseShapeNw#in_symb] <= C#[pulseShapeNw#in_symb];
  assume 0 <= I#[pulseShapeNw#in_len];
  assume I#[pulseShapeNw#in_len] <= R#[pulseShapeNw#in_len];
  assume R#[pulseShapeNw#in_len] <= C#[pulseShapeNw#in_len];
  assume 0 <= I#[pulseShapeNw#body_iterations];
  assume I#[pulseShapeNw#body_iterations] <= R#[pulseShapeNw#body_iterations];
  assume R#[pulseShapeNw#body_iterations] <= C#[pulseShapeNw#body_iterations];
  assume 0 <= I#[pulseShapeNw#body_index];
  assume I#[pulseShapeNw#body_index] <= R#[pulseShapeNw#body_index];
  assume R#[pulseShapeNw#body_index] <= C#[pulseShapeNw#body_index];
  assume 0 <= I#[pulseShapeNw#St];
  assume I#[pulseShapeNw#St] <= R#[pulseShapeNw#St];
  assume R#[pulseShapeNw#St] <= C#[pulseShapeNw#St];
  assume 0 <= I#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] <= R#[pulseShapeNw#out_hsp];
  assume R#[pulseShapeNw#out_hsp] <= C#[pulseShapeNw#out_hsp];
  assume I#[pulseShapeNw#out_hsp] == R#[pulseShapeNw#out_hsp];
  assume 0 <= I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] <= R#[pulseShapeNw#out_done];
  assume R#[pulseShapeNw#out_done] <= C#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_done] == R#[pulseShapeNw#out_done];
  assume (B#[pulseShapeNw#in_symb] == 576) && (B#[pulseShapeNw#in_len] == 1) && (B#[pulseShapeNw#out_done] == 1) && (B#[pulseShapeNw#out_hsp] == 4616);
  assume (B#[pulseShapeNw#in_symb] == 576) && (B#[pulseShapeNw#in_len] == 1) && (B#[pulseShapeNw#out_done] == 1) && (B#[pulseShapeNw#out_hsp] == 4616);
  assume I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assume I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assume I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assume ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assume AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assume ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assume ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assume (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
  assume M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]] == 9bv8;
  assume ((C#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) <= 576) && ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) <= 1);
  assume (C#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 576;
  assume (C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1;
  assume M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]] == 9bv8;
  assume !((1 <= (C#[pulseShapeNw#in_len] - R#[pulseShapeNw#in_len])) && (1 <= (C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations])) && (1 <= (C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index])) && (1 <= (C#[pulseShapeNw#St] - R#[pulseShapeNw#St])) && (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0));
  assume !((2 <= (C#[pulseShapeNw#in_symb] - R#[pulseShapeNw#in_symb])) && (1 <= (C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations])) && (1 <= (C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index])) && (1 <= (C#[pulseShapeNw#St] - R#[pulseShapeNw#St])) && (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) && AT#BvUlt14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]));
  assume !((1 <= (C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations])) && (1 <= (C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index])) && (1 <= (C#[pulseShapeNw#St] - R#[pulseShapeNw#St])) && (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) && (M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]] == M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]));
  assert {:msg "ZigBee.actor(330.3): The correct number of tokens might not be produced on output 'done' (#227)"} (C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1;
  assert {:msg "ZigBee.actor(330.3): The correct number of tokens might not be produced on output 'hsp' (#228)"} (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 4616;
  R#[pulseShapeNw#out_hsp] := R#[pulseShapeNw#out_hsp] + 4616;
  R#[pulseShapeNw#out_done] := R#[pulseShapeNw#out_done] + 1;
  I# := R#;
  assert {:msg "ZigBee.actor(334.15): The network might not preserve the channel invariant (#229)"} I#[pulseShapeNw#in_symb] == (576 * I#[pulseShapeNw#out_done]);
  assert {:msg "ZigBee.actor(335.15): The network might not preserve the channel invariant (#230)"} I#[pulseShapeNw#in_len] == I#[pulseShapeNw#out_done];
  assert {:msg "ZigBee.actor(336.15): The network might not preserve the channel invariant (#231)"} I#[pulseShapeNw#out_hsp] == (4616 * I#[pulseShapeNw#in_len]);
  assert {:msg "ZigBee.actor(341.15): The network might not preserve the channel invariant (#232)"} ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assert {:msg "ZigBee.actor(344.15): The network might not preserve the channel invariant (#233)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) || (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1);
  assert {:msg "ZigBee.actor(345.15): The network might not preserve the channel invariant (#234)"} AT#BvSle14(0bv14, M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]) && AT#BvUle14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]], M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]);
  assert {:msg "ZigBee.actor(347.15): The network might not preserve the channel invariant (#235)"} ((C#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (B#[pulseShapeNw#in_symb] == (64 * AT#Bv2Int8(M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]])));
  assert {:msg "ZigBee.actor(348.15): The network might not preserve the channel invariant (#236)"} ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> (M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]] == AT#BvMul14(0bv6 ++ M#[pulseShapeNw#in_len][I#[pulseShapeNw#in_len]], 32bv14)) && ((2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) == B#[pulseShapeNw#in_symb]) && ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]])));
  assert {:msg "ZigBee.actor(354.15): The network might not preserve the channel invariant (#237)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == (16 * AT#Bv2Int14(M#[pulseShapeNw#body_index][R#[pulseShapeNw#body_index]]))) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * (C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1);
  assert {:msg "ZigBee.actor(362.15): The network might not preserve the channel invariant (#238)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 1) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == (2 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]]))) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == ((16 * AT#Bv2Int14(M#[pulseShapeNw#body_iterations][R#[pulseShapeNw#body_iterations]])) + 8)) && ((16 * (R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb])) == (2 * ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) - 8))) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 1);
  assert {:msg "ZigBee.actor(369.15): The network might not preserve the channel invariant (#239)"} (M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0) && ((R#[pulseShapeNw#in_len] - I#[pulseShapeNw#in_len]) == 0) ==> ((R#[pulseShapeNw#in_symb] - I#[pulseShapeNw#in_symb]) == 0) && ((C#[pulseShapeNw#out_hsp] - I#[pulseShapeNw#out_hsp]) == 0) && ((C#[pulseShapeNw#out_done] - I#[pulseShapeNw#out_done]) == 0);
  assert {:msg "ZigBee.actor(339.13): The network might not preserve the network invariant (#240)"} ((C#[pulseShapeNw#body_iterations] - R#[pulseShapeNw#body_iterations]) == 1) && ((C#[pulseShapeNw#body_index] - R#[pulseShapeNw#body_index]) == 1) && ((C#[pulseShapeNw#St] - R#[pulseShapeNw#St]) == 1);
  assert {:msg "ZigBee.actor(340.13): The network might not preserve the network invariant (#241)"} M#[pulseShapeNw#St][R#[pulseShapeNw#St]] == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel in_symb (#242)"} (C#[pulseShapeNw#in_symb] - R#[pulseShapeNw#in_symb]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel in_len (#243)"} (C#[pulseShapeNw#in_len] - R#[pulseShapeNw#in_len]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel out_hsp (#244)"} (C#[pulseShapeNw#out_hsp] - R#[pulseShapeNw#out_hsp]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel out_done (#245)"} (C#[pulseShapeNw#out_done] - R#[pulseShapeNw#out_done]) == 0;
}
function qpskMod#q7_map(bit: bv32) returns (out: bv8);
procedure qpskMod#init#27()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var chip: Chan (bv32);
  var symb: Chan (bv8);
  var IQ: Map (int) (bv8);
  assume true;
  assume (I#[chip] == 0) && (R#[chip] == 0) && (C#[chip] == 0);
  assume (I#[symb] == 0) && (R#[symb] == 0) && (C#[symb] == 0);
}
procedure qpskMod#anon$5#28()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var chip: Chan (bv32);
  var symb: Chan (bv8);
  var IQ: Map (int) (bv8);
  var chip#0: bv32;
  assume true;
  assume (0 <= I#[chip]) && (I#[chip] <= R#[chip]) && (R#[chip] <= C#[chip]);
  assume (0 <= I#[symb]) && (I#[symb] <= R#[symb]) && (R#[symb] <= C#[symb]);
  assume (32 * R#[chip]) == C#[symb];
  assume 1 <= (C#[chip] - R#[chip]);
  chip#0 := M#[chip][R#[chip]];
  R#[chip] := R#[chip] + 1;
  assume true;
  IQ := Map#Store(IQ, 0, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 0bv32), 1bv32)));
  IQ := Map#Store(IQ, 1, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 1bv32), 1bv32)));
  IQ := Map#Store(IQ, 2, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 2bv32), 1bv32)));
  IQ := Map#Store(IQ, 3, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 3bv32), 1bv32)));
  IQ := Map#Store(IQ, 4, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 4bv32), 1bv32)));
  IQ := Map#Store(IQ, 5, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 5bv32), 1bv32)));
  IQ := Map#Store(IQ, 6, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 6bv32), 1bv32)));
  IQ := Map#Store(IQ, 7, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 7bv32), 1bv32)));
  IQ := Map#Store(IQ, 8, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 8bv32), 1bv32)));
  IQ := Map#Store(IQ, 9, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 9bv32), 1bv32)));
  IQ := Map#Store(IQ, 10, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 10bv32), 1bv32)));
  IQ := Map#Store(IQ, 11, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 11bv32), 1bv32)));
  IQ := Map#Store(IQ, 12, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 12bv32), 1bv32)));
  IQ := Map#Store(IQ, 13, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 13bv32), 1bv32)));
  IQ := Map#Store(IQ, 14, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 14bv32), 1bv32)));
  IQ := Map#Store(IQ, 15, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 15bv32), 1bv32)));
  IQ := Map#Store(IQ, 16, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 16bv32), 1bv32)));
  IQ := Map#Store(IQ, 17, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 17bv32), 1bv32)));
  IQ := Map#Store(IQ, 18, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 18bv32), 1bv32)));
  IQ := Map#Store(IQ, 19, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 19bv32), 1bv32)));
  IQ := Map#Store(IQ, 20, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 20bv32), 1bv32)));
  IQ := Map#Store(IQ, 21, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 21bv32), 1bv32)));
  IQ := Map#Store(IQ, 22, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 22bv32), 1bv32)));
  IQ := Map#Store(IQ, 23, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 23bv32), 1bv32)));
  IQ := Map#Store(IQ, 24, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 24bv32), 1bv32)));
  IQ := Map#Store(IQ, 25, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 25bv32), 1bv32)));
  IQ := Map#Store(IQ, 26, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 26bv32), 1bv32)));
  IQ := Map#Store(IQ, 27, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 27bv32), 1bv32)));
  IQ := Map#Store(IQ, 28, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 28bv32), 1bv32)));
  IQ := Map#Store(IQ, 29, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 29bv32), 1bv32)));
  IQ := Map#Store(IQ, 30, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 30bv32), 1bv32)));
  IQ := Map#Store(IQ, 31, qpskMod#q7_map(AT#BvAnd32(AT#BvLshr32(chip#0, 31bv32), 1bv32)));
  M#[symb][C#[symb]] := Map#Select(IQ, 0);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 1);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 2);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 3);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 4);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 5);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 6);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 7);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 8);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 9);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 10);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 11);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 12);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 13);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 14);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 15);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 16);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 17);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 18);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 19);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 20);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 21);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 22);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 23);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 24);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 25);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 26);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 27);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 28);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 29);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 30);
  C#[symb] := C#[symb] + 1;
  M#[symb][C#[symb]] := Map#Select(IQ, 31);
  C#[symb] := C#[symb] + 1;
}
procedure ZigBee#init#29()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var ZigBee#ha: Actor;
  var ZigBee#cm: Actor;
  var ZigBee#qm: Actor;
  var ZigBee#ps: Actor;
  var ZigBee#ch_pl_bits: Chan (bv8);
  var ZigBee#ch_data: Chan (bv8);
  var ZigBee#ch_chip: Chan (bv32);
  var ZigBee#ch_symb: Chan (bv8);
  var ZigBee#ch_len: Chan (bv8);
  var ZigBee#ch_done: Chan (bool);
  var ZigBee#ch_hsp: Chan (bv8);
  var AV#cm#Chip_map_table: Map (bv8) (bv32);
  var AV#cm#lsn: bv8;
  var AV#cm#msn: bv8;
  var AV#qm#IQ: Map (int) (bv8);
  assume (ZigBee#ha != ZigBee#cm) && (ZigBee#ha != ZigBee#qm) && (ZigBee#ha != ZigBee#ps) && (ZigBee#cm != ZigBee#qm) && (ZigBee#cm != ZigBee#ps) && (ZigBee#qm != ZigBee#ps);
  assume (ZigBee#ch_pl_bits != ZigBee#ch_data) && (ZigBee#ch_pl_bits != ZigBee#ch_symb) && (ZigBee#ch_pl_bits != ZigBee#ch_len) && (ZigBee#ch_pl_bits != ZigBee#ch_hsp) && (ZigBee#ch_data != ZigBee#ch_symb) && (ZigBee#ch_data != ZigBee#ch_len) && (ZigBee#ch_data != ZigBee#ch_hsp) && (ZigBee#ch_symb != ZigBee#ch_len) && (ZigBee#ch_symb != ZigBee#ch_hsp) && (ZigBee#ch_len != ZigBee#ch_hsp);
  assume 0 <= I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_pl_bits] <= R#[ZigBee#ch_pl_bits];
  assume R#[ZigBee#ch_pl_bits] <= C#[ZigBee#ch_pl_bits];
  assume 0 <= I#[ZigBee#ch_data];
  assume I#[ZigBee#ch_data] <= R#[ZigBee#ch_data];
  assume R#[ZigBee#ch_data] <= C#[ZigBee#ch_data];
  assume 0 <= I#[ZigBee#ch_chip];
  assume I#[ZigBee#ch_chip] <= R#[ZigBee#ch_chip];
  assume R#[ZigBee#ch_chip] <= C#[ZigBee#ch_chip];
  assume 0 <= I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_symb] <= R#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] <= C#[ZigBee#ch_symb];
  assume 0 <= I#[ZigBee#ch_len];
  assume I#[ZigBee#ch_len] <= R#[ZigBee#ch_len];
  assume R#[ZigBee#ch_len] <= C#[ZigBee#ch_len];
  assume 0 <= I#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] <= R#[ZigBee#ch_done];
  assume R#[ZigBee#ch_done] <= C#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] == R#[ZigBee#ch_done];
  assume 0 <= I#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] <= R#[ZigBee#ch_hsp];
  assume R#[ZigBee#ch_hsp] <= C#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] == R#[ZigBee#ch_hsp];
  assume (B#[ZigBee#ch_pl_bits] == 4) && (B#[ZigBee#ch_done] == 1) && (B#[ZigBee#ch_hsp] == 4616);
  assume C#[ZigBee#ch_pl_bits] == 0;
  assume R#[ZigBee#ch_pl_bits] == 0;
  assume C#[ZigBee#ch_data] == 0;
  assume R#[ZigBee#ch_data] == 0;
  assume C#[ZigBee#ch_chip] == 0;
  assume R#[ZigBee#ch_chip] == 0;
  assume C#[ZigBee#ch_symb] == 0;
  assume R#[ZigBee#ch_symb] == 0;
  assume C#[ZigBee#ch_len] == 0;
  assume R#[ZigBee#ch_len] == 0;
  assume C#[ZigBee#ch_done] == 0;
  assume R#[ZigBee#ch_done] == 0;
  assume C#[ZigBee#ch_hsp] == 0;
  assume R#[ZigBee#ch_hsp] == 0;
  assert {:msg "ZigBee.actor(457.15): Initialization of network 'ZigBee' might not establish the channel invariant (#246)"} ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assert {:msg "ZigBee.actor(458.15): Initialization of network 'ZigBee' might not establish the channel invariant (#247)"} ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
  I# := R#;
  assert {:msg "Initialization of network 'ZigBee' might not establish the network invariant: Unread tokens might be left on channel ch_pl_bits (#248)"} (C#[ZigBee#ch_pl_bits] - R#[ZigBee#ch_pl_bits]) == 0;
  assert {:msg "Initialization of network 'ZigBee' might not establish the network invariant: Unread tokens might be left on channel ch_data (#249)"} (C#[ZigBee#ch_data] - R#[ZigBee#ch_data]) == 0;
  assert {:msg "Initialization of network 'ZigBee' might not establish the network invariant: Unread tokens might be left on channel ch_chip (#250)"} (C#[ZigBee#ch_chip] - R#[ZigBee#ch_chip]) == 0;
  assert {:msg "Initialization of network 'ZigBee' might not establish the network invariant: Unread tokens might be left on channel ch_symb (#251)"} (C#[ZigBee#ch_symb] - R#[ZigBee#ch_symb]) == 0;
  assert {:msg "Initialization of network 'ZigBee' might not establish the network invariant: Unread tokens might be left on channel ch_len (#252)"} (C#[ZigBee#ch_len] - R#[ZigBee#ch_len]) == 0;
  assert {:msg "Initialization of network 'ZigBee' might not establish the network invariant: Unread tokens might be left on channel ch_done (#253)"} (C#[ZigBee#ch_done] - R#[ZigBee#ch_done]) == 0;
  assert {:msg "Initialization of network 'ZigBee' might not establish the network invariant: Unread tokens might be left on channel ch_hsp (#254)"} (C#[ZigBee#ch_hsp] - R#[ZigBee#ch_hsp]) == 0;
}
procedure ZigBee##headerAddNw#anon$2#30()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var ZigBee#ha: Actor;
  var ZigBee#cm: Actor;
  var ZigBee#qm: Actor;
  var ZigBee#ps: Actor;
  var ZigBee#ch_pl_bits: Chan (bv8);
  var ZigBee#ch_data: Chan (bv8);
  var ZigBee#ch_chip: Chan (bv32);
  var ZigBee#ch_symb: Chan (bv8);
  var ZigBee#ch_len: Chan (bv8);
  var ZigBee#ch_done: Chan (bool);
  var ZigBee#ch_hsp: Chan (bv8);
  var AV#cm#Chip_map_table: Map (bv8) (bv32);
  var AV#cm#lsn: bv8;
  var AV#cm#msn: bv8;
  var AV#qm#IQ: Map (int) (bv8);
  assume (ZigBee#ha != ZigBee#cm) && (ZigBee#ha != ZigBee#qm) && (ZigBee#ha != ZigBee#ps) && (ZigBee#cm != ZigBee#qm) && (ZigBee#cm != ZigBee#ps) && (ZigBee#qm != ZigBee#ps);
  assume (ZigBee#ch_pl_bits != ZigBee#ch_data) && (ZigBee#ch_pl_bits != ZigBee#ch_symb) && (ZigBee#ch_pl_bits != ZigBee#ch_len) && (ZigBee#ch_pl_bits != ZigBee#ch_hsp) && (ZigBee#ch_data != ZigBee#ch_symb) && (ZigBee#ch_data != ZigBee#ch_len) && (ZigBee#ch_data != ZigBee#ch_hsp) && (ZigBee#ch_symb != ZigBee#ch_len) && (ZigBee#ch_symb != ZigBee#ch_hsp) && (ZigBee#ch_len != ZigBee#ch_hsp);
  assume 0 <= I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_pl_bits] <= R#[ZigBee#ch_pl_bits];
  assume R#[ZigBee#ch_pl_bits] <= C#[ZigBee#ch_pl_bits];
  assume 0 <= I#[ZigBee#ch_data];
  assume I#[ZigBee#ch_data] <= R#[ZigBee#ch_data];
  assume R#[ZigBee#ch_data] <= C#[ZigBee#ch_data];
  assume 0 <= I#[ZigBee#ch_chip];
  assume I#[ZigBee#ch_chip] <= R#[ZigBee#ch_chip];
  assume R#[ZigBee#ch_chip] <= C#[ZigBee#ch_chip];
  assume 0 <= I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_symb] <= R#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] <= C#[ZigBee#ch_symb];
  assume 0 <= I#[ZigBee#ch_len];
  assume I#[ZigBee#ch_len] <= R#[ZigBee#ch_len];
  assume R#[ZigBee#ch_len] <= C#[ZigBee#ch_len];
  assume 0 <= I#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] <= R#[ZigBee#ch_done];
  assume R#[ZigBee#ch_done] <= C#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] == R#[ZigBee#ch_done];
  assume 0 <= I#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] <= R#[ZigBee#ch_hsp];
  assume R#[ZigBee#ch_hsp] <= C#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] == R#[ZigBee#ch_hsp];
  assume (B#[ZigBee#ch_pl_bits] == 4) && (B#[ZigBee#ch_done] == 1) && (B#[ZigBee#ch_hsp] == 4616);
  I#sub[ZigBee#ch_pl_bits] := R#[ZigBee#ch_pl_bits];
  I#sub[ZigBee#ch_data] := C#[ZigBee#ch_data];
  I#sub[ZigBee#ch_len] := C#[ZigBee#ch_len];
  assume ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assume ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
  assume (4 * I#[ZigBee#ch_data]) == (9 * I#[ZigBee#ch_pl_bits]);
  assume (4 * I#[ZigBee#ch_len]) == I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_chip] == (2 * I#[ZigBee#ch_data]);
  assume I#[ZigBee#ch_symb] == (32 * I#[ZigBee#ch_chip]);
  assume (576 * I#[ZigBee#ch_done]) == I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_done] == I#[ZigBee#ch_len];
  assume (576 * I#[ZigBee#ch_hsp]) == (4616 * I#[ZigBee#ch_symb]);
  assume I#[ZigBee#ch_hsp] == (4616 * I#[ZigBee#ch_len]);
  assume M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8;
  assume (C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) <= 4;
  assume (9 * R#[ZigBee#ch_pl_bits]) == (4 * C#[ZigBee#ch_data]);
  assume R#[ZigBee#ch_pl_bits] == (4 * C#[ZigBee#ch_len]);
  assume (2 * R#[ZigBee#ch_data]) == C#[ZigBee#ch_chip];
  assume (32 * R#[ZigBee#ch_chip]) == C#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] == (576 * C#[ZigBee#ch_done]);
  assume R#[ZigBee#ch_len] == C#[ZigBee#ch_done];
  assume (4616 * R#[ZigBee#ch_symb]) == (576 * C#[ZigBee#ch_hsp]);
  assume (4616 * R#[ZigBee#ch_len]) == C#[ZigBee#ch_hsp];
  assume 4 <= (C#[ZigBee#ch_pl_bits] - R#[ZigBee#ch_pl_bits]);
  R#[ZigBee#ch_pl_bits] := R#[ZigBee#ch_pl_bits] + 4;
  assert {:msg "ZigBee.actor(138.14): Precondition might not hold for instance at ZigBee.actor(461.5) (#255)"} AT#Bv2Int8(M#[ZigBee#ch_pl_bits][I#sub[ZigBee#ch_pl_bits]]) == (B#[ZigBee#ch_pl_bits] - 1);
  C#[ZigBee#ch_data] := C#[ZigBee#ch_data] + 9;
  C#[ZigBee#ch_len] := C#[ZigBee#ch_len] + 1;
  assume M#[ZigBee#ch_len][I#sub[ZigBee#ch_len]] == AT#BvAdd8(M#[ZigBee#ch_pl_bits][I#sub[ZigBee#ch_pl_bits]], 6bv8);
  assert {:msg "ZigBee.actor(457.15): Action at ZigBee.actor(137.3) ('anon$2') for actor instance 'ha' might not preserve the channel invariant (#256)"} ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assert {:msg "ZigBee.actor(458.15): Action at ZigBee.actor(137.3) ('anon$2') for actor instance 'ha' might not preserve the channel invariant (#257)"} ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
}
procedure ZigBee##chipMapper#anon$0#31()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var ZigBee#ha: Actor;
  var ZigBee#cm: Actor;
  var ZigBee#qm: Actor;
  var ZigBee#ps: Actor;
  var ZigBee#ch_pl_bits: Chan (bv8);
  var ZigBee#ch_data: Chan (bv8);
  var ZigBee#ch_chip: Chan (bv32);
  var ZigBee#ch_symb: Chan (bv8);
  var ZigBee#ch_len: Chan (bv8);
  var ZigBee#ch_done: Chan (bool);
  var ZigBee#ch_hsp: Chan (bv8);
  var AV#cm#Chip_map_table: Map (bv8) (bv32);
  var AV#cm#lsn: bv8;
  var AV#cm#msn: bv8;
  var AV#qm#IQ: Map (int) (bv8);
  var data#data_in: bv8;
  assume (ZigBee#ha != ZigBee#cm) && (ZigBee#ha != ZigBee#qm) && (ZigBee#ha != ZigBee#ps) && (ZigBee#cm != ZigBee#qm) && (ZigBee#cm != ZigBee#ps) && (ZigBee#qm != ZigBee#ps);
  assume (ZigBee#ch_pl_bits != ZigBee#ch_data) && (ZigBee#ch_pl_bits != ZigBee#ch_symb) && (ZigBee#ch_pl_bits != ZigBee#ch_len) && (ZigBee#ch_pl_bits != ZigBee#ch_hsp) && (ZigBee#ch_data != ZigBee#ch_symb) && (ZigBee#ch_data != ZigBee#ch_len) && (ZigBee#ch_data != ZigBee#ch_hsp) && (ZigBee#ch_symb != ZigBee#ch_len) && (ZigBee#ch_symb != ZigBee#ch_hsp) && (ZigBee#ch_len != ZigBee#ch_hsp);
  assume 0 <= I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_pl_bits] <= R#[ZigBee#ch_pl_bits];
  assume R#[ZigBee#ch_pl_bits] <= C#[ZigBee#ch_pl_bits];
  assume 0 <= I#[ZigBee#ch_data];
  assume I#[ZigBee#ch_data] <= R#[ZigBee#ch_data];
  assume R#[ZigBee#ch_data] <= C#[ZigBee#ch_data];
  assume 0 <= I#[ZigBee#ch_chip];
  assume I#[ZigBee#ch_chip] <= R#[ZigBee#ch_chip];
  assume R#[ZigBee#ch_chip] <= C#[ZigBee#ch_chip];
  assume 0 <= I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_symb] <= R#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] <= C#[ZigBee#ch_symb];
  assume 0 <= I#[ZigBee#ch_len];
  assume I#[ZigBee#ch_len] <= R#[ZigBee#ch_len];
  assume R#[ZigBee#ch_len] <= C#[ZigBee#ch_len];
  assume 0 <= I#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] <= R#[ZigBee#ch_done];
  assume R#[ZigBee#ch_done] <= C#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] == R#[ZigBee#ch_done];
  assume 0 <= I#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] <= R#[ZigBee#ch_hsp];
  assume R#[ZigBee#ch_hsp] <= C#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] == R#[ZigBee#ch_hsp];
  assume (B#[ZigBee#ch_pl_bits] == 4) && (B#[ZigBee#ch_done] == 1) && (B#[ZigBee#ch_hsp] == 4616);
  I#sub[ZigBee#ch_data] := R#[ZigBee#ch_data];
  I#sub[ZigBee#ch_chip] := C#[ZigBee#ch_chip];
  assume ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assume ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
  assume (4 * I#[ZigBee#ch_data]) == (9 * I#[ZigBee#ch_pl_bits]);
  assume (4 * I#[ZigBee#ch_len]) == I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_chip] == (2 * I#[ZigBee#ch_data]);
  assume I#[ZigBee#ch_symb] == (32 * I#[ZigBee#ch_chip]);
  assume (576 * I#[ZigBee#ch_done]) == I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_done] == I#[ZigBee#ch_len];
  assume (576 * I#[ZigBee#ch_hsp]) == (4616 * I#[ZigBee#ch_symb]);
  assume I#[ZigBee#ch_hsp] == (4616 * I#[ZigBee#ch_len]);
  assume M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8;
  assume (C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) <= 4;
  assume (9 * R#[ZigBee#ch_pl_bits]) == (4 * C#[ZigBee#ch_data]);
  assume R#[ZigBee#ch_pl_bits] == (4 * C#[ZigBee#ch_len]);
  assume (2 * R#[ZigBee#ch_data]) == C#[ZigBee#ch_chip];
  assume (32 * R#[ZigBee#ch_chip]) == C#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] == (576 * C#[ZigBee#ch_done]);
  assume R#[ZigBee#ch_len] == C#[ZigBee#ch_done];
  assume (4616 * R#[ZigBee#ch_symb]) == (576 * C#[ZigBee#ch_hsp]);
  assume (4616 * R#[ZigBee#ch_len]) == C#[ZigBee#ch_hsp];
  assume 1 <= (C#[ZigBee#ch_data] - R#[ZigBee#ch_data]);
  data#data_in := M#[ZigBee#ch_data][R#[ZigBee#ch_data]];
  R#[ZigBee#ch_data] := R#[ZigBee#ch_data] + 1;
  havoc AV#cm#lsn;
  havoc AV#cm#msn;
  M#[ZigBee#ch_chip][C#[ZigBee#ch_chip]] := Map#Select(AV#cm#Chip_map_table, AV#cm#lsn);
  C#[ZigBee#ch_chip] := C#[ZigBee#ch_chip] + 1;
  M#[ZigBee#ch_chip][C#[ZigBee#ch_chip]] := Map#Select(AV#cm#Chip_map_table, AV#cm#msn);
  C#[ZigBee#ch_chip] := C#[ZigBee#ch_chip] + 1;
  assert {:msg "ZigBee.actor(457.15): Action at ZigBee.actor(23.2) ('anon$0') for actor instance 'cm' might not preserve the channel invariant (#258)"} ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assert {:msg "ZigBee.actor(458.15): Action at ZigBee.actor(23.2) ('anon$0') for actor instance 'cm' might not preserve the channel invariant (#259)"} ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
}
procedure ZigBee##qpskMod#anon$5#32()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var ZigBee#ha: Actor;
  var ZigBee#cm: Actor;
  var ZigBee#qm: Actor;
  var ZigBee#ps: Actor;
  var ZigBee#ch_pl_bits: Chan (bv8);
  var ZigBee#ch_data: Chan (bv8);
  var ZigBee#ch_chip: Chan (bv32);
  var ZigBee#ch_symb: Chan (bv8);
  var ZigBee#ch_len: Chan (bv8);
  var ZigBee#ch_done: Chan (bool);
  var ZigBee#ch_hsp: Chan (bv8);
  var AV#cm#Chip_map_table: Map (bv8) (bv32);
  var AV#cm#lsn: bv8;
  var AV#cm#msn: bv8;
  var AV#qm#IQ: Map (int) (bv8);
  var chip#c_in: bv32;
  assume (ZigBee#ha != ZigBee#cm) && (ZigBee#ha != ZigBee#qm) && (ZigBee#ha != ZigBee#ps) && (ZigBee#cm != ZigBee#qm) && (ZigBee#cm != ZigBee#ps) && (ZigBee#qm != ZigBee#ps);
  assume (ZigBee#ch_pl_bits != ZigBee#ch_data) && (ZigBee#ch_pl_bits != ZigBee#ch_symb) && (ZigBee#ch_pl_bits != ZigBee#ch_len) && (ZigBee#ch_pl_bits != ZigBee#ch_hsp) && (ZigBee#ch_data != ZigBee#ch_symb) && (ZigBee#ch_data != ZigBee#ch_len) && (ZigBee#ch_data != ZigBee#ch_hsp) && (ZigBee#ch_symb != ZigBee#ch_len) && (ZigBee#ch_symb != ZigBee#ch_hsp) && (ZigBee#ch_len != ZigBee#ch_hsp);
  assume 0 <= I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_pl_bits] <= R#[ZigBee#ch_pl_bits];
  assume R#[ZigBee#ch_pl_bits] <= C#[ZigBee#ch_pl_bits];
  assume 0 <= I#[ZigBee#ch_data];
  assume I#[ZigBee#ch_data] <= R#[ZigBee#ch_data];
  assume R#[ZigBee#ch_data] <= C#[ZigBee#ch_data];
  assume 0 <= I#[ZigBee#ch_chip];
  assume I#[ZigBee#ch_chip] <= R#[ZigBee#ch_chip];
  assume R#[ZigBee#ch_chip] <= C#[ZigBee#ch_chip];
  assume 0 <= I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_symb] <= R#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] <= C#[ZigBee#ch_symb];
  assume 0 <= I#[ZigBee#ch_len];
  assume I#[ZigBee#ch_len] <= R#[ZigBee#ch_len];
  assume R#[ZigBee#ch_len] <= C#[ZigBee#ch_len];
  assume 0 <= I#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] <= R#[ZigBee#ch_done];
  assume R#[ZigBee#ch_done] <= C#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] == R#[ZigBee#ch_done];
  assume 0 <= I#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] <= R#[ZigBee#ch_hsp];
  assume R#[ZigBee#ch_hsp] <= C#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] == R#[ZigBee#ch_hsp];
  assume (B#[ZigBee#ch_pl_bits] == 4) && (B#[ZigBee#ch_done] == 1) && (B#[ZigBee#ch_hsp] == 4616);
  I#sub[ZigBee#ch_chip] := R#[ZigBee#ch_chip];
  I#sub[ZigBee#ch_symb] := C#[ZigBee#ch_symb];
  assume ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assume ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
  assume (4 * I#[ZigBee#ch_data]) == (9 * I#[ZigBee#ch_pl_bits]);
  assume (4 * I#[ZigBee#ch_len]) == I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_chip] == (2 * I#[ZigBee#ch_data]);
  assume I#[ZigBee#ch_symb] == (32 * I#[ZigBee#ch_chip]);
  assume (576 * I#[ZigBee#ch_done]) == I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_done] == I#[ZigBee#ch_len];
  assume (576 * I#[ZigBee#ch_hsp]) == (4616 * I#[ZigBee#ch_symb]);
  assume I#[ZigBee#ch_hsp] == (4616 * I#[ZigBee#ch_len]);
  assume M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8;
  assume (C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) <= 4;
  assume (9 * R#[ZigBee#ch_pl_bits]) == (4 * C#[ZigBee#ch_data]);
  assume R#[ZigBee#ch_pl_bits] == (4 * C#[ZigBee#ch_len]);
  assume (2 * R#[ZigBee#ch_data]) == C#[ZigBee#ch_chip];
  assume (32 * R#[ZigBee#ch_chip]) == C#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] == (576 * C#[ZigBee#ch_done]);
  assume R#[ZigBee#ch_len] == C#[ZigBee#ch_done];
  assume (4616 * R#[ZigBee#ch_symb]) == (576 * C#[ZigBee#ch_hsp]);
  assume (4616 * R#[ZigBee#ch_len]) == C#[ZigBee#ch_hsp];
  assume 1 <= (C#[ZigBee#ch_chip] - R#[ZigBee#ch_chip]);
  chip#c_in := M#[ZigBee#ch_chip][R#[ZigBee#ch_chip]];
  R#[ZigBee#ch_chip] := R#[ZigBee#ch_chip] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 0);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 1);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 2);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 3);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 4);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 5);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 6);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 7);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 8);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 9);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 10);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 11);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 12);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 13);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 14);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 15);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 16);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 17);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 18);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 19);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 20);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 21);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 22);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 23);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 24);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 25);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 26);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 27);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 28);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 29);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 30);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  M#[ZigBee#ch_symb][C#[ZigBee#ch_symb]] := Map#Select(AV#qm#IQ, 31);
  C#[ZigBee#ch_symb] := C#[ZigBee#ch_symb] + 1;
  assert {:msg "ZigBee.actor(457.15): Action at ZigBee.actor(408.2) ('anon$5') for actor instance 'qm' might not preserve the channel invariant (#260)"} ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assert {:msg "ZigBee.actor(458.15): Action at ZigBee.actor(408.2) ('anon$5') for actor instance 'qm' might not preserve the channel invariant (#261)"} ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
}
procedure ZigBee##pulseShapeNw#anon$4#33()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var ZigBee#ha: Actor;
  var ZigBee#cm: Actor;
  var ZigBee#qm: Actor;
  var ZigBee#ps: Actor;
  var ZigBee#ch_pl_bits: Chan (bv8);
  var ZigBee#ch_data: Chan (bv8);
  var ZigBee#ch_chip: Chan (bv32);
  var ZigBee#ch_symb: Chan (bv8);
  var ZigBee#ch_len: Chan (bv8);
  var ZigBee#ch_done: Chan (bool);
  var ZigBee#ch_hsp: Chan (bv8);
  var AV#cm#Chip_map_table: Map (bv8) (bv32);
  var AV#cm#lsn: bv8;
  var AV#cm#msn: bv8;
  var AV#qm#IQ: Map (int) (bv8);
  assume (ZigBee#ha != ZigBee#cm) && (ZigBee#ha != ZigBee#qm) && (ZigBee#ha != ZigBee#ps) && (ZigBee#cm != ZigBee#qm) && (ZigBee#cm != ZigBee#ps) && (ZigBee#qm != ZigBee#ps);
  assume (ZigBee#ch_pl_bits != ZigBee#ch_data) && (ZigBee#ch_pl_bits != ZigBee#ch_symb) && (ZigBee#ch_pl_bits != ZigBee#ch_len) && (ZigBee#ch_pl_bits != ZigBee#ch_hsp) && (ZigBee#ch_data != ZigBee#ch_symb) && (ZigBee#ch_data != ZigBee#ch_len) && (ZigBee#ch_data != ZigBee#ch_hsp) && (ZigBee#ch_symb != ZigBee#ch_len) && (ZigBee#ch_symb != ZigBee#ch_hsp) && (ZigBee#ch_len != ZigBee#ch_hsp);
  assume 0 <= I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_pl_bits] <= R#[ZigBee#ch_pl_bits];
  assume R#[ZigBee#ch_pl_bits] <= C#[ZigBee#ch_pl_bits];
  assume 0 <= I#[ZigBee#ch_data];
  assume I#[ZigBee#ch_data] <= R#[ZigBee#ch_data];
  assume R#[ZigBee#ch_data] <= C#[ZigBee#ch_data];
  assume 0 <= I#[ZigBee#ch_chip];
  assume I#[ZigBee#ch_chip] <= R#[ZigBee#ch_chip];
  assume R#[ZigBee#ch_chip] <= C#[ZigBee#ch_chip];
  assume 0 <= I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_symb] <= R#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] <= C#[ZigBee#ch_symb];
  assume 0 <= I#[ZigBee#ch_len];
  assume I#[ZigBee#ch_len] <= R#[ZigBee#ch_len];
  assume R#[ZigBee#ch_len] <= C#[ZigBee#ch_len];
  assume 0 <= I#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] <= R#[ZigBee#ch_done];
  assume R#[ZigBee#ch_done] <= C#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] == R#[ZigBee#ch_done];
  assume 0 <= I#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] <= R#[ZigBee#ch_hsp];
  assume R#[ZigBee#ch_hsp] <= C#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] == R#[ZigBee#ch_hsp];
  assume (B#[ZigBee#ch_pl_bits] == 4) && (B#[ZigBee#ch_done] == 1) && (B#[ZigBee#ch_hsp] == 4616);
  I#sub[ZigBee#ch_symb] := R#[ZigBee#ch_symb];
  I#sub[ZigBee#ch_len] := R#[ZigBee#ch_len];
  I#sub[ZigBee#ch_done] := C#[ZigBee#ch_done];
  I#sub[ZigBee#ch_hsp] := C#[ZigBee#ch_hsp];
  assume ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assume ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
  assume (4 * I#[ZigBee#ch_data]) == (9 * I#[ZigBee#ch_pl_bits]);
  assume (4 * I#[ZigBee#ch_len]) == I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_chip] == (2 * I#[ZigBee#ch_data]);
  assume I#[ZigBee#ch_symb] == (32 * I#[ZigBee#ch_chip]);
  assume (576 * I#[ZigBee#ch_done]) == I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_done] == I#[ZigBee#ch_len];
  assume (576 * I#[ZigBee#ch_hsp]) == (4616 * I#[ZigBee#ch_symb]);
  assume I#[ZigBee#ch_hsp] == (4616 * I#[ZigBee#ch_len]);
  assume M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8;
  assume (C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) <= 4;
  assume (9 * R#[ZigBee#ch_pl_bits]) == (4 * C#[ZigBee#ch_data]);
  assume R#[ZigBee#ch_pl_bits] == (4 * C#[ZigBee#ch_len]);
  assume (2 * R#[ZigBee#ch_data]) == C#[ZigBee#ch_chip];
  assume (32 * R#[ZigBee#ch_chip]) == C#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] == (576 * C#[ZigBee#ch_done]);
  assume R#[ZigBee#ch_len] == C#[ZigBee#ch_done];
  assume (4616 * R#[ZigBee#ch_symb]) == (576 * C#[ZigBee#ch_hsp]);
  assume (4616 * R#[ZigBee#ch_len]) == C#[ZigBee#ch_hsp];
  assume (576 <= (C#[ZigBee#ch_symb] - R#[ZigBee#ch_symb])) && (1 <= (C#[ZigBee#ch_len] - R#[ZigBee#ch_len]));
  R#[ZigBee#ch_symb] := R#[ZigBee#ch_symb] + 576;
  R#[ZigBee#ch_len] := R#[ZigBee#ch_len] + 1;
  assert {:msg "ZigBee.actor(331.14): Precondition might not hold for instance at ZigBee.actor(464.5) (#262)"} M#[ZigBee#ch_len][I#sub[ZigBee#ch_len]] == 9bv8;
  C#[ZigBee#ch_done] := C#[ZigBee#ch_done] + 1;
  C#[ZigBee#ch_hsp] := C#[ZigBee#ch_hsp] + 4616;
  assert {:msg "ZigBee.actor(457.15): Action at ZigBee.actor(330.3) ('anon$4') for actor instance 'ps' might not preserve the channel invariant (#263)"} ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assert {:msg "ZigBee.actor(458.15): Action at ZigBee.actor(330.3) ('anon$4') for actor instance 'ps' might not preserve the channel invariant (#264)"} ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
}
procedure ZigBee#anon$6#input#pl_bits#34()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var ZigBee#ha: Actor;
  var ZigBee#cm: Actor;
  var ZigBee#qm: Actor;
  var ZigBee#ps: Actor;
  var ZigBee#ch_pl_bits: Chan (bv8);
  var ZigBee#ch_data: Chan (bv8);
  var ZigBee#ch_chip: Chan (bv32);
  var ZigBee#ch_symb: Chan (bv8);
  var ZigBee#ch_len: Chan (bv8);
  var ZigBee#ch_done: Chan (bool);
  var ZigBee#ch_hsp: Chan (bv8);
  var AV#cm#Chip_map_table: Map (bv8) (bv32);
  var AV#cm#lsn: bv8;
  var AV#cm#msn: bv8;
  var AV#qm#IQ: Map (int) (bv8);
  assume (ZigBee#ha != ZigBee#cm) && (ZigBee#ha != ZigBee#qm) && (ZigBee#ha != ZigBee#ps) && (ZigBee#cm != ZigBee#qm) && (ZigBee#cm != ZigBee#ps) && (ZigBee#qm != ZigBee#ps);
  assume (ZigBee#ch_pl_bits != ZigBee#ch_data) && (ZigBee#ch_pl_bits != ZigBee#ch_symb) && (ZigBee#ch_pl_bits != ZigBee#ch_len) && (ZigBee#ch_pl_bits != ZigBee#ch_hsp) && (ZigBee#ch_data != ZigBee#ch_symb) && (ZigBee#ch_data != ZigBee#ch_len) && (ZigBee#ch_data != ZigBee#ch_hsp) && (ZigBee#ch_symb != ZigBee#ch_len) && (ZigBee#ch_symb != ZigBee#ch_hsp) && (ZigBee#ch_len != ZigBee#ch_hsp);
  assume 0 <= I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_pl_bits] <= R#[ZigBee#ch_pl_bits];
  assume R#[ZigBee#ch_pl_bits] <= C#[ZigBee#ch_pl_bits];
  assume 0 <= I#[ZigBee#ch_data];
  assume I#[ZigBee#ch_data] <= R#[ZigBee#ch_data];
  assume R#[ZigBee#ch_data] <= C#[ZigBee#ch_data];
  assume 0 <= I#[ZigBee#ch_chip];
  assume I#[ZigBee#ch_chip] <= R#[ZigBee#ch_chip];
  assume R#[ZigBee#ch_chip] <= C#[ZigBee#ch_chip];
  assume 0 <= I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_symb] <= R#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] <= C#[ZigBee#ch_symb];
  assume 0 <= I#[ZigBee#ch_len];
  assume I#[ZigBee#ch_len] <= R#[ZigBee#ch_len];
  assume R#[ZigBee#ch_len] <= C#[ZigBee#ch_len];
  assume 0 <= I#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] <= R#[ZigBee#ch_done];
  assume R#[ZigBee#ch_done] <= C#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] == R#[ZigBee#ch_done];
  assume 0 <= I#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] <= R#[ZigBee#ch_hsp];
  assume R#[ZigBee#ch_hsp] <= C#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] == R#[ZigBee#ch_hsp];
  assume (B#[ZigBee#ch_pl_bits] == 4) && (B#[ZigBee#ch_done] == 1) && (B#[ZigBee#ch_hsp] == 4616);
  assume (B#[ZigBee#ch_pl_bits] == 4) && (B#[ZigBee#ch_done] == 1) && (B#[ZigBee#ch_hsp] == 4616);
  assume (C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) < 4;
  assume ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assume ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
  assume (4 * I#[ZigBee#ch_data]) == (9 * I#[ZigBee#ch_pl_bits]);
  assume (4 * I#[ZigBee#ch_len]) == I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_chip] == (2 * I#[ZigBee#ch_data]);
  assume I#[ZigBee#ch_symb] == (32 * I#[ZigBee#ch_chip]);
  assume (576 * I#[ZigBee#ch_done]) == I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_done] == I#[ZigBee#ch_len];
  assume (576 * I#[ZigBee#ch_hsp]) == (4616 * I#[ZigBee#ch_symb]);
  assume I#[ZigBee#ch_hsp] == (4616 * I#[ZigBee#ch_len]);
  assume M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8;
  assume (C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) <= 4;
  assume (9 * R#[ZigBee#ch_pl_bits]) == (4 * C#[ZigBee#ch_data]);
  assume R#[ZigBee#ch_pl_bits] == (4 * C#[ZigBee#ch_len]);
  assume (2 * R#[ZigBee#ch_data]) == C#[ZigBee#ch_chip];
  assume (32 * R#[ZigBee#ch_chip]) == C#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] == (576 * C#[ZigBee#ch_done]);
  assume R#[ZigBee#ch_len] == C#[ZigBee#ch_done];
  assume (4616 * R#[ZigBee#ch_symb]) == (576 * C#[ZigBee#ch_hsp]);
  assume (4616 * R#[ZigBee#ch_len]) == C#[ZigBee#ch_hsp];
  C#[ZigBee#ch_pl_bits] := C#[ZigBee#ch_pl_bits] + 1;
  assume M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8;
  assert {:msg "ZigBee.actor(457.15): Channel invariant might be falsified by network input (#265)"} ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assert {:msg "ZigBee.actor(458.15): Channel invariant might be falsified by network input (#266)"} ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
}
procedure ZigBee#anon$6#exit#35()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var ZigBee#ha: Actor;
  var ZigBee#cm: Actor;
  var ZigBee#qm: Actor;
  var ZigBee#ps: Actor;
  var ZigBee#ch_pl_bits: Chan (bv8);
  var ZigBee#ch_data: Chan (bv8);
  var ZigBee#ch_chip: Chan (bv32);
  var ZigBee#ch_symb: Chan (bv8);
  var ZigBee#ch_len: Chan (bv8);
  var ZigBee#ch_done: Chan (bool);
  var ZigBee#ch_hsp: Chan (bv8);
  var AV#cm#Chip_map_table: Map (bv8) (bv32);
  var AV#cm#lsn: bv8;
  var AV#cm#msn: bv8;
  var AV#qm#IQ: Map (int) (bv8);
  assume (ZigBee#ha != ZigBee#cm) && (ZigBee#ha != ZigBee#qm) && (ZigBee#ha != ZigBee#ps) && (ZigBee#cm != ZigBee#qm) && (ZigBee#cm != ZigBee#ps) && (ZigBee#qm != ZigBee#ps);
  assume (ZigBee#ch_pl_bits != ZigBee#ch_data) && (ZigBee#ch_pl_bits != ZigBee#ch_symb) && (ZigBee#ch_pl_bits != ZigBee#ch_len) && (ZigBee#ch_pl_bits != ZigBee#ch_hsp) && (ZigBee#ch_data != ZigBee#ch_symb) && (ZigBee#ch_data != ZigBee#ch_len) && (ZigBee#ch_data != ZigBee#ch_hsp) && (ZigBee#ch_symb != ZigBee#ch_len) && (ZigBee#ch_symb != ZigBee#ch_hsp) && (ZigBee#ch_len != ZigBee#ch_hsp);
  assume 0 <= I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_pl_bits] <= R#[ZigBee#ch_pl_bits];
  assume R#[ZigBee#ch_pl_bits] <= C#[ZigBee#ch_pl_bits];
  assume 0 <= I#[ZigBee#ch_data];
  assume I#[ZigBee#ch_data] <= R#[ZigBee#ch_data];
  assume R#[ZigBee#ch_data] <= C#[ZigBee#ch_data];
  assume 0 <= I#[ZigBee#ch_chip];
  assume I#[ZigBee#ch_chip] <= R#[ZigBee#ch_chip];
  assume R#[ZigBee#ch_chip] <= C#[ZigBee#ch_chip];
  assume 0 <= I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_symb] <= R#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] <= C#[ZigBee#ch_symb];
  assume 0 <= I#[ZigBee#ch_len];
  assume I#[ZigBee#ch_len] <= R#[ZigBee#ch_len];
  assume R#[ZigBee#ch_len] <= C#[ZigBee#ch_len];
  assume 0 <= I#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] <= R#[ZigBee#ch_done];
  assume R#[ZigBee#ch_done] <= C#[ZigBee#ch_done];
  assume I#[ZigBee#ch_done] == R#[ZigBee#ch_done];
  assume 0 <= I#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] <= R#[ZigBee#ch_hsp];
  assume R#[ZigBee#ch_hsp] <= C#[ZigBee#ch_hsp];
  assume I#[ZigBee#ch_hsp] == R#[ZigBee#ch_hsp];
  assume (B#[ZigBee#ch_pl_bits] == 4) && (B#[ZigBee#ch_done] == 1) && (B#[ZigBee#ch_hsp] == 4616);
  assume (B#[ZigBee#ch_pl_bits] == 4) && (B#[ZigBee#ch_done] == 1) && (B#[ZigBee#ch_hsp] == 4616);
  assume ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assume ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
  assume (4 * I#[ZigBee#ch_data]) == (9 * I#[ZigBee#ch_pl_bits]);
  assume (4 * I#[ZigBee#ch_len]) == I#[ZigBee#ch_pl_bits];
  assume I#[ZigBee#ch_chip] == (2 * I#[ZigBee#ch_data]);
  assume I#[ZigBee#ch_symb] == (32 * I#[ZigBee#ch_chip]);
  assume (576 * I#[ZigBee#ch_done]) == I#[ZigBee#ch_symb];
  assume I#[ZigBee#ch_done] == I#[ZigBee#ch_len];
  assume (576 * I#[ZigBee#ch_hsp]) == (4616 * I#[ZigBee#ch_symb]);
  assume I#[ZigBee#ch_hsp] == (4616 * I#[ZigBee#ch_len]);
  assume M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8;
  assume (C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) <= 4;
  assume (9 * R#[ZigBee#ch_pl_bits]) == (4 * C#[ZigBee#ch_data]);
  assume R#[ZigBee#ch_pl_bits] == (4 * C#[ZigBee#ch_len]);
  assume (2 * R#[ZigBee#ch_data]) == C#[ZigBee#ch_chip];
  assume (32 * R#[ZigBee#ch_chip]) == C#[ZigBee#ch_symb];
  assume R#[ZigBee#ch_symb] == (576 * C#[ZigBee#ch_done]);
  assume R#[ZigBee#ch_len] == C#[ZigBee#ch_done];
  assume (4616 * R#[ZigBee#ch_symb]) == (576 * C#[ZigBee#ch_hsp]);
  assume (4616 * R#[ZigBee#ch_len]) == C#[ZigBee#ch_hsp];
  assume (C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) == 4;
  assume M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8;
  assume !(4 <= (C#[ZigBee#ch_pl_bits] - R#[ZigBee#ch_pl_bits]));
  assume !(1 <= (C#[ZigBee#ch_data] - R#[ZigBee#ch_data]));
  assume !(1 <= (C#[ZigBee#ch_chip] - R#[ZigBee#ch_chip]));
  assume !((576 <= (C#[ZigBee#ch_symb] - R#[ZigBee#ch_symb])) && (1 <= (C#[ZigBee#ch_len] - R#[ZigBee#ch_len])));
  assert {:msg "ZigBee.actor(453.3): The correct number of tokens might not be produced on output 'done' (#267)"} (C#[ZigBee#ch_done] - I#[ZigBee#ch_done]) == 1;
  assert {:msg "ZigBee.actor(453.3): The correct number of tokens might not be produced on output 'hsp' (#268)"} (C#[ZigBee#ch_hsp] - I#[ZigBee#ch_hsp]) == 4616;
  R#[ZigBee#ch_done] := R#[ZigBee#ch_done] + 1;
  R#[ZigBee#ch_hsp] := R#[ZigBee#ch_hsp] + 4616;
  I# := R#;
  assert {:msg "ZigBee.actor(457.15): The network might not preserve the channel invariant (#269)"} ((C#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_pl_bits][I#[ZigBee#ch_pl_bits]] == 3bv8);
  assert {:msg "ZigBee.actor(458.15): The network might not preserve the channel invariant (#270)"} ((R#[ZigBee#ch_pl_bits] - I#[ZigBee#ch_pl_bits]) > 0) ==> (M#[ZigBee#ch_len][I#[ZigBee#ch_len]] == AT#BvAdd8(3bv8, 6bv8));
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel ch_pl_bits (#271)"} (C#[ZigBee#ch_pl_bits] - R#[ZigBee#ch_pl_bits]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel ch_data (#272)"} (C#[ZigBee#ch_data] - R#[ZigBee#ch_data]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel ch_chip (#273)"} (C#[ZigBee#ch_chip] - R#[ZigBee#ch_chip]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel ch_symb (#274)"} (C#[ZigBee#ch_symb] - R#[ZigBee#ch_symb]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel ch_len (#275)"} (C#[ZigBee#ch_len] - R#[ZigBee#ch_len]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel ch_done (#276)"} (C#[ZigBee#ch_done] - R#[ZigBee#ch_done]) == 0;
  assert {:msg "The network might not preserve the network invariant: Unread tokens might be left on channel ch_hsp (#277)"} (C#[ZigBee#ch_hsp] - R#[ZigBee#ch_hsp]) == 0;
}
