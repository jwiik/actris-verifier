actor chipMapper()
// Inputs:
bv(size=8) data              // header and payload data samples as 8-bit unsigned
                                     // each sample contains two 4-bit symbols
// Outputs:
==> bv(size=32) chip          // packets of 32 chips
:
	                                 // 32-bit Pseudo-Noise (PN) sequence values
	/*Map(bv(size=8) -> bv(size=32)) Chip_map_table;*/
								/*[
								 0x744ac39b, 0x44ac39b7, 0x4ac39b74, 0xac39b744,
								 0xc39b744a, 0x39b744ac, 0x9b744ac3, 0xb744ac39,
								 0xdee06931, 0xee06931d, 0xe06931de, 0x6931dee,
								 0x6931dee0, 0x931dee06, 0x31dee069, 0x1dee0693];*/
	/*function Chip_map_table(bv(size=8) in) --> bv(size=32): 0x744ac39b end*/
	
	Map(bv(size=8) -> bv(size=32)) Chip_map_table;
	
	bv(size=8) lsn;
	bv(size=8) msn;
	
	// acquire a data sample and transmit two chip packets
	action data:[ data_in ] ==> chip:[ Chip_map_table[lsn], Chip_map_table[msn] ]
	do
        lsn := data_in & 0x0F;
        msn := (data_in >> 0x04) & 0x0F;
	end

end

actor headerAdd()
// Inputs: 
bv(size=8) pl_bits,   // payload bits from upper layer 
int St_in,
bv(size=8) octet_count_in,
bv(size=8) octet_index_in
// Outputs:
==> 
bv(size=8) data,      // header + payload data
bv(size=8) len,       // header + payload length
int St_out,
bv(size=8) octet_count_out,
bv(size=8) octet_index_out
:
    // variable to hold payload length
	bv(size=8) octet_count;
	
	// variable to count processed payload octets
	bv(size=8) octet_index;

	// static variable
	bv(size=8) HEADER_LEN //= 0x05;
	
	// the standard-defined header content
	Map(bv(size=8) -> bv(size=8)) Header; //= [0, 0, 0, 0, 167];
	
	bv(size=8) data_out;

	// init action
	// initializes the data source
	initialize ==> octet_index_out:[0x00], octet_count_out:[0x00], St_out:[0]
	end
	
	// get_data_len action
	// wait for packet to be available
	// send payload length information to pulse shaper
	get_data_len: action 
			pl_bits:[ bits_in ],
			octet_index_in: [octet_index], 
			octet_count_in: [octet_count],
			St_in:[St]
		==> 
			octet_index_out: [0x00], 
			octet_count_out: [bits_in + 0x05 + 0x01], 
			St_out: [1],  
			len: [bits_in + 0x05 + 0x01]
	guard 
	  St = 0
	end

	// send_header action
	// transmit one octet belonging to header
	send_header: action
			octet_index_in: [octet_index], 
			octet_count_in: [octet_count],
			St_in:[St] 
		==> 
			St_out: [1],
			octet_index_out: [octet_index + 0x01], 
			octet_count_out: [octet_count], 
			data:[ data_out ]
	guard
		octet_index < 0x05 &&
		St = 1
	do
		data_out := Header[octet_index];
	end

	// send_length action
	// transmit payload length in data as part of data frame
	send_length: action 
			octet_index_in: [octet_index], 
			octet_count_in: [octet_count],
			St_in:[St] 
		==> 
			St_out: [2],
			octet_index_out: [octet_index + 0x01], 
			octet_count_out: [octet_count], 
			data:[ octet_count - 0x05 - 0x01 ]
	guard 
		octet_index = 0x05 &&
		St = 1
	end

	// send_payload_octet
	// transmit one octet of the data coming from higher layer
	send_payload_octet: action 
			pl_bits:[ bits_in ],
			octet_index_in: [octet_index], 
			octet_count_in: [octet_count],
			St_in:[St] 
		==> 
			St_out: [if octet_index + 0x01 = octet_count then 0 else 2 end],
			octet_index_out: [octet_index + 0x01], 
			octet_count_out: [octet_count], 
			data:[ bits_in ]
	guard
		octet_index < octet_count &&
		St = 2
	end

end


network headerAddNw bv(size=8) pl_bits ==> bv(size=8) data, bv(size=8) len :

  contract pl_bits:4 ==> data:9, len:1
    requires bv2int(pl_bits[@]) = rate(pl_bits)-1
    ensures len[@] = pl_bits[@] + 0x06
  end
  
  // Feedback loop state variables
  invariant tokens(octet_count,1) && tokens(octet_index,1) && tokens(St,1)
  invariant St[next] = 0 && octet_index[next] = octet_count[next]
  
  chinvariant 9*@(pl_bits) = 4*@(data)
  chinvariant @(pl_bits) = 4*@(len)
  
  // We always have a token on feedback loops
  chinvariant tokens(octet_count,1) && tokens(octet_index,1) && tokens(St,1)
  
  // octet_index is between 0 and octet_count
  chinvariant 0x00 <= octet_index[next] && octet_index[next] <= octet_count[next]
  
  // There are three states: 0, 1 or 2
  chinvariant 0 <= St[next] && St[next] <= 2
  
  chinvariant tot@(input) > 0 ==> bv2int(input[@]) = rate(input)-1
  
  chinvariant St[next] = 0 ==> octet_index[next] = octet_count[next]
  chinvariant St[next] = 1 ==> 0x00 <= octet_index[next] && octet_index[next] <= 0x05
  chinvariant St[next] = 2 ==> 0x06 <= octet_index[next] && octet_index[next] < octet_count[next]
  
  chinvariant St[next] = 0 && rd@(input) = 0 ==> tot@(data) = 0
  chinvariant St[next] = 0 && rd@(input) > 0 ==> tot@(data) = bv2int(octet_count[next])
  
  chinvariant St[next] = 1 ==> rd@(input) = 1
  chinvariant St[next] = 1 || St[next] = 2 ==> tot@(data) = bv2int(octet_index[next])
  chinvariant St[next] = 2 ==> rd@(input) = tot@(data)-5

  chinvariant St[next] = 0 <==> (rd@(input) = 0 || rd@(input) = rate(input))
  
  chinvariant rd@(input) = 0 ==> tot@(len) = 0
  chinvariant rd@(input) > 0 ==> octet_count[next] = input[@] + 0x06
  
  chinvariant rd@(input) > 0 ==> tot@(len) = 1
  chinvariant rd@(input) > 0 ==> len[@] = input[@]+0x06
  
      
  entities
    a = headerAdd()
  end
  
  structure 
    input:  pl_bits --> a.pl_bits;
    octet_count:  a.octet_count_out --> a.octet_count_in;
    octet_index:  a.octet_index_out --> a.octet_index_in;
    St:     a.St_out --> a.St_in;
    data:   a.data --> data;
    len:    a.len --> len;
  end

end

actor pulseShape() 
// Inputs:
bv(size=8) symb,           // I-Q symbols from QPSK modulator 
bv(size=8) len,       		// Payload length
bv(size=14) body_iterations_in,
bv(size=14) body_index_in,
int St_in
// Outputs:
==> 
bool done,          // Flag to terminate
bv(size=8) hsp,             // Half-sine pulse samples
bv(size=14) body_iterations_out,
bv(size=14) body_index_out,
int St_out
:

	bv(size=8) symb_mem;     // Temporary storage for symbol values during transmission
                                    // the current hsp. range: [0...8] 
	bv(size=8) body_iterations;   // Number of times the "body" part of the transmission has to be repeated 
	bv(size=8) body_index;        // Number of times the "body" part of the transmission has been repeated

    bv(size=8) FILT_COEFF0 = 0x00;         // Static filter coefficients for half-sine pulse generation
    bv(size=8) FILT_COEFF1 = 0x31;
    bv(size=8) FILT_COEFF2 = 0x5a;
    bv(size=8) FILT_COEFF3 = 0x76;
    bv(size=8) FILT_COEFF4 = 0x7f;
    
    List(type: bv(size=8), size=16) hsps

	// fixed-point multiplication with shift
	function mul8( bv(size=8) x, bv(size=8) y ) --> bv(size=8) :
		(x * y) >> 7
	end
	
	initialize 
		==>
		body_iterations_out:[int2bv(0,14)],
		body_index_out:[int2bv(0,14)],
		St_out:[0]
	end

	// init action
	// Fired when payload length is known
	init: action 
			len:[len_in],
			body_iterations_in:[body_iterations],
			body_index_in:[body_index],
			St_in:[St]
		==>
			body_iterations_out:[bvconcat(int2bv(0,6),len_in) * int2bv(32,14)],
			body_index_out:[int2bv(0,14)],
			St_out:[1]
	guard St = 0
	do
		symb_mem := 0x7F;
	end

	// tx-body action
	// Consumes 2, produces 16 samples
	tx_body: action 
		symb:[ symb_1, symb_2 ],
		body_iterations_in:[body_iterations],
		body_index_in:[body_index],
		St_in:[St]
		==> 
		hsp:[ hsps[0],hsps[1],hsps[2],hsps[3],hsps[4],hsps[5],hsps[6],hsps[7],
			hsps[8],hsps[9],hsps[10],hsps[11],hsps[12],hsps[13],hsps[14],hsps[15] ],
		body_iterations_out:[body_iterations],
		body_index_out:[body_index + int2bv(1,14)],
		St_out:[1]
	guard
		St = 1 &&
		body_index < body_iterations
	do	
		hsps[0] := mul8(FILT_COEFF0, symb_1);
		hsps[1] := mul8(FILT_COEFF4, symb_mem);
	
		hsps[2] := mul8(FILT_COEFF1, symb_1);
		hsps[3] := mul8(FILT_COEFF3, symb_mem);
	
		hsps[4] := mul8(FILT_COEFF2, symb_1);
		hsps[5] := mul8(FILT_COEFF2, symb_mem);
	
		hsps[6] := mul8(FILT_COEFF3, symb_1);
		hsps[7] := mul8(FILT_COEFF1, symb_mem);
	
		hsps[8] := mul8(FILT_COEFF4, symb_1);
		hsps[9] := mul8(FILT_COEFF0, symb_2);
	
		hsps[10] := mul8(FILT_COEFF3, symb_1);
		hsps[11] := mul8(FILT_COEFF1, symb_2);
	
		hsps[12] := mul8(FILT_COEFF2, symb_1);
		hsps[13] := mul8(FILT_COEFF2, symb_2);
	
		hsps[14] := mul8(FILT_COEFF1, symb_1);
		hsps[15] := mul8(FILT_COEFF3, symb_2);
	
		symb_mem := symb_2;
	end

	// tx_tail action
	// Finalizes the transmission signal with the fixed 0x7F value
	tx_tail: action 
		body_iterations_in:[body_iterations],
		body_index_in:[body_index],
		St_in:[St]
		==> 
		hsp:[ hsps[0],hsps[1],hsps[2],hsps[3],hsps[4],hsps[5],hsps[6],hsps[7] ], 
		done: [ true ],
		body_iterations_out:[body_iterations],
		body_index_out:[body_index],
		St_out:[0]
	guard
		St = 1 &&
		body_index = body_iterations
	do
		hsps[0] := mul8(FILT_COEFF0, 0x7F);
		hsps[1] := mul8(FILT_COEFF4, symb_mem);
	
		hsps[2] := mul8(FILT_COEFF1, 0x7F);
		hsps[3] := mul8(FILT_COEFF3, symb_mem);
	
		hsps[4] := mul8(FILT_COEFF2, 0x7F);
		hsps[5] := mul8(FILT_COEFF2, symb_mem);
	
		hsps[6] := mul8(FILT_COEFF3, 0x7F);
		hsps[7] := mul8(FILT_COEFF1, symb_mem);
		
	end
	
end

network pulseShapeNw bv(size=8) symb, bv(size=8) len ==> bool done, bv(size=8) hsp :
  
  contract symb:576, len:1 ==> done:1, hsp:4616
    requires len[@] = 0x09
  end
  
  chinvariant @(symb) = 576*@(done)
  chinvariant @(len) = @(done)
  chinvariant @(hsp) = 4616*@(len)
  
  // Feedback loops
  invariant tokens(body_iterations,1) && tokens(body_index,1) && tokens(St,1)
  invariant St[next] = 0
  chinvariant tokens(body_iterations,1) && tokens(body_index,1) && tokens(St,1)
  
  // State is 0, 1 or, body_index between 0 and body_iterations
  chinvariant St[next] = 0 || St[next] = 1
  chinvariant int2bv(0,14) <= body_index[next] && body_index[next] <= body_iterations[next]
  
  chinvariant tot@(len) = 1 ==> rate(symb) = 64*bv2int(len[@])
  chinvariant rd@(len) = 1 ==> (
    body_iterations[next] = bvconcat(int2bv(0,6),len[@]) * int2bv(32,14) &&
    2*bv2int(body_iterations[next]) = rate(symb) &&
    rd@(symb)  = 2*bv2int(body_index[next])
  )
   
  chinvariant St[next] = 1 ==> (
    rd@(symb)  = 2*bv2int(body_index[next]) &&
    tot@(hsp)  = 16*bv2int(body_index[next]) &&
    16*rd@(symb) = 2*tot@(hsp) &&
    tot@(done) = 0 &&
    rd@(len)   = 1
  )

  chinvariant St[next] = 0 && rd@(len) = 1 ==> (
    rd@(symb)  = 2*bv2int(body_iterations[next]) &&
    tot@(hsp)  = 16*bv2int(body_iterations[next])+8 &&
    16*rd@(symb) = 2*(tot@(hsp)-8) &&
    tot@(done) = 1
  )

  chinvariant St[next] = 0 && rd@(len) = 0 ==> (
    rd@(symb)  = 0 &&
    tot@(hsp)  = 0 &&
    tot@(done) = 0
  )
  
  entities
    a = pulseShape()
  end
  
  structure 
    in_symb:  symb --> a.symb;
    in_len:   len --> a.len;
    body_iterations:  a.body_iterations_out --> a.body_iterations_in;
    body_index:  a.body_index_out --> a.body_index_in;
    St:     a.St_out --> a.St_in;
    out_hsp:   a.hsp --> hsp;
    out_done:    a.done --> done;
  end
  
end

actor qpskMod() 
// Inputs:
bv(size=32) chip              // Packets of 32 chips.
// Outputs:
==> 
bv(size=8) symb               // I-Q symbols. Range: [-128, 127]
:
	// mapping of chips to I-Q samples
	function q7_map( bv(size=32) bit ) --> bv(size=8) :
		255 * bit - 128	
	end
	
	//stream invariant 32*rd(chip) = tot(symb)
	
	List(type: bv(size=8), size=32) IQ;

	// transforms a chip to I-Q modulated samples and sends
	action 
		chip:[ c_in ] ==> 
		symb:[
			IQ[0],IQ[1],IQ[2],IQ[3],IQ[4],IQ[5],IQ[6],IQ[7],
			IQ[8],IQ[9],IQ[10],IQ[11],IQ[12],IQ[13],IQ[14],IQ[15],
			IQ[16],IQ[17],IQ[18],IQ[19],IQ[20],IQ[21],IQ[22],IQ[23],
			IQ[24],IQ[25],IQ[26],IQ[27],IQ[28],IQ[29],IQ[30],IQ[31]]
	do
		IQ[0] := q7_map((c_in >> 0x00000000) & 0x00000001);
		IQ[1] := q7_map((c_in >> 0x00000001) & 0x00000001);
		IQ[2] := q7_map((c_in >> 0x00000002) & 0x00000001);
		IQ[3] := q7_map((c_in >> 0x00000003) & 0x00000001);
		IQ[4] := q7_map((c_in >> 0x00000004) & 0x00000001);
		IQ[5] := q7_map((c_in >> 0x00000005) & 0x00000001);
		IQ[6] := q7_map((c_in >> 0x00000006) & 0x00000001);
		IQ[7] := q7_map((c_in >> 0x00000007) & 0x00000001);
		IQ[8] := q7_map((c_in >> 0x00000008) & 0x00000001);
		IQ[9] := q7_map((c_in >> 0x00000009) & 0x00000001);
		IQ[10] := q7_map((c_in >> 0x0000000A) & 0x00000001);
		IQ[11] := q7_map((c_in >> 0x0000000B) & 0x00000001);
		IQ[12] := q7_map((c_in >> 0x0000000C) & 0x00000001);
		IQ[13] := q7_map((c_in >> 0x0000000D) & 0x00000001);
		IQ[14] := q7_map((c_in >> 0x0000000E) & 0x00000001);
		IQ[15] := q7_map((c_in >> 0x0000000F) & 0x00000001);
		IQ[16] := q7_map((c_in >> 0x00000010) & 0x00000001);
		IQ[17] := q7_map((c_in >> 0x00000011) & 0x00000001);
		IQ[18] := q7_map((c_in >> 0x00000012) & 0x00000001);
		IQ[19] := q7_map((c_in >> 0x00000013) & 0x00000001);
		IQ[20] := q7_map((c_in >> 0x00000014) & 0x00000001);
		IQ[21] := q7_map((c_in >> 0x00000015) & 0x00000001);
		IQ[22] := q7_map((c_in >> 0x00000016) & 0x00000001);
		IQ[23] := q7_map((c_in >> 0x00000017) & 0x00000001);
		IQ[24] := q7_map((c_in >> 0x00000018) & 0x00000001);
		IQ[25] := q7_map((c_in >> 0x00000019) & 0x00000001);
		IQ[26] := q7_map((c_in >> 0x0000001A) & 0x00000001);
		IQ[27] := q7_map((c_in >> 0x0000001B) & 0x00000001);
		IQ[28] := q7_map((c_in >> 0x0000001C) & 0x00000001);
		IQ[29] := q7_map((c_in >> 0x0000001D) & 0x00000001);
		IQ[30] := q7_map((c_in >> 0x0000001E) & 0x00000001);
		IQ[31] := q7_map((c_in >> 0x0000001F) & 0x00000001);
	end
end

network ZigBee bv(size=8) pl_bits ==> bool done, bv(size=8) hsp:

  contract pl_bits:4 ==> done:1, hsp:4616
    requires pl_bits[@] = 0x03
  end
  
  chinvariant tot@(pl_bits) > 0 ==> pl_bits[@] = 0x03
  chinvariant rd@(pl_bits) > 0 ==> ch_len[@] = 0x03 + 0x06

  entities
    ha = headerAddNw();
    cm = chipMapper();
    qm = qpskMod();
    ps = pulseShapeNw();
  end
  
  structure
    ch_pl_bits: pl_bits --> ha.pl_bits;
    ch_data: ha.data --> cm.data;
    ch_chip: cm.chip --> qm.chip;
    ch_symb: qm.symb --> ps.symb;
    ch_len: ha.len --> ps.len;
    ch_done: ps.done --> done;
    ch_hsp: ps.hsp --> hsp;
  end

end