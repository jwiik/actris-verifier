actor chipMapper()
// Inputs:
bv(size=8) data              // header and payload data samples as 8-bit unsigned
                                     // each sample contains two 4-bit symbols
// Outputs:
==> bv(size=32) chip          // packets of 32 chips
:
	                                 // 32-bit Pseudo-Noise (PN) sequence values
	
	Map(bv(size=8) -> bv(size=32), size=16) Chip_map_table = 
								[int(size=8)]
								[0x744ac39b, 0x44ac39b7, 0x4ac39b74, 0xac39b744,
								 0xc39b744a, 0x39b744ac, 0x9b744ac3, 0xb744ac39,
								 0xdee06931, 0xee06931d, 0xe06931de, 0x6931dee0,
								 0x6931dee0, 0x931dee06, 0x31dee069, 0x1dee0693];
	
	bv(size=8) lsn;
	bv(size=8) msn;
	
	// acquire a data sample and transmit two chip packets
	action data:[ data_in ] ==> chip:[ Chip_map_table[lsn], Chip_map_table[msn] ]
	do
        lsn := data_in & 0x0F;
        msn := (data_in >> 0x04) & 0x0F;
	end

end

actor headerAdd()
// Inputs: 
bv(size=8) pl_bits   // payload bits from upper layer 
// Outputs:
==> 
bv(size=8) data,      // header + payload data
bv(size=9) len        // header + payload length
:
    Main: contract pl_bits:4 ==> data:9, len:1
      requires bv2int(pl_bits[@]) = 4-1
      ensures len[@] = bvresize(pl_bits[@],9) + int(6,9)
    end
    
    contract invariant state(s_idle)
    contract invariant octet_index = octet_count
    stream contract invariant 9*rd(pl_bits) = 4*tot(data)
    stream contract invariant rd(pl_bits) = 4*tot(len)
    
    action invariant 9*@(pl_bits) = 4*@(data)
    action invariant @(pl_bits) = 4*@(len)
    
    action invariant 0x00 <= octet_index && octet_index <= octet_count
    action invariant tot@(pl_bits) > 0 ==> bv2int(pl_bits[@]) = 4-1
    
    action invariant state(s_idle)    ==> octet_index = octet_count
    action invariant state(s_header)  ==> 0x00 <= octet_index && octet_index <= 0x05
    action invariant state(s_payload) ==> 0x06 <= octet_index && octet_index <= octet_count
  
    action invariant state(s_idle) && rd@(pl_bits) = 0 ==> tot@(data) = 0
    action invariant state(s_idle) && rd@(pl_bits) > 0 ==> tot@(data) = bv2int(octet_count)
  
    action invariant state(s_header) ==> rd@(pl_bits) = 1
    action invariant state(s_header) || state(s_payload) ==> tot@(data) = bv2int(octet_index)
    action invariant state(s_payload) ==> rd@(pl_bits) = tot@(data)-5

    action invariant state(s_idle) ==> (rd@(pl_bits) = 0 || rd@(pl_bits) = 4)
  
    action invariant rd@(pl_bits) = 0 ==> tot@(len) = 0
    action invariant rd@(pl_bits) > 0 ==> octet_count = pl_bits[@] + 0x06
  
    action invariant rd@(pl_bits) > 0 ==> tot@(len) = 1
    action invariant rd@(pl_bits) > 0 ==> len[@] = bvresize(pl_bits[@]+0x06,9)

    // variable to hold payload length
	bv(size=8) octet_count := 0x00;
	
	// variable to count processed payload octets
	bv(size=8) octet_index := 0x00;

	// static variable
	bv(size=8) HEADER_LEN = 0x05;
	
	// the standard-defined header content
	Map(bv(size=8) -> bv(size=8), size=5) Header = 
		[int(size=8)]
		[int(0,8), int(0,8), int(0,8), int(0,8), int(167,8)];
	
	bv(size=8) data_out;

	
	// get_data_len action
	// wait for packet to be available
	// send payload length information to pulse shaper
	get_data_len: action 
			pl_bits:[ bits_in ]
		==>   
			len: [bvresize(bits_in,9) + int(5,9) + int(1,9)]
	do
	  octet_index := 0x00;
	  octet_count := bits_in + 0x05 + 0x01;
	end

	// send_header action
	// transmit one octet belonging to header
	send_header: action
		==>  
			data:[ data_out ]
	guard
		octet_index < 0x05
	do
		data_out := Header[octet_index];
		octet_index := octet_index + 0x01;
	end

	// send_length action
	// transmit payload length in data as part of data frame
	send_length: action ==> data:[ octet_count - 0x05 - 0x01 ]
	guard 
		octet_index = 0x05
	do
		octet_index := octet_index + 0x01;
	end

	// send_payload_octet
	// transmit one octet of the data coming from higher layer
	send_payload_octet: action 
			pl_bits:[ bits_in ] ==> data:[ bits_in ]
	guard
		octet_index < octet_count
	do
		octet_index := octet_index + 0x01;
	end
	
	done: action ==>
	guard
		octet_index = octet_count
	end
	
	schedule fsm s_idle :
		s_idle ( get_data_len ) --> s_header;
		s_header ( send_header ) --> s_header;
		s_header ( send_length ) --> s_payload;
		s_payload ( send_payload_octet ) --> s_payload;
		s_payload ( done ) --> s_idle;
	end

	priority
		send_header > send_length;
		send_payload_octet > done;
	end
	
end




actor pulseShape() 
// Inputs:
bv(size=8) symb,           // I-Q symbols from QPSK modulator 
bv(size=9) len       		// Payload length
// Outputs:
==> 
bool done,          // Flag to terminate
bv(size=8) hsp             // Half-sine pulse samples
:

    contract symb:576, len:1 ==> done:1, hsp:4616
      requires len[@] = int(9,9)
    end

    contract invariant state(s_start)
    stream contract invariant rd(symb) = 576*tot(done)
    stream contract invariant rd(len) = tot(done)
    stream contract invariant tot(hsp) = 4616*rd(len)
    
    action invariant @(symb) = 576*@(done)
    action invariant @(len) = @(done)
    action invariant @(hsp) = 4616*@(len)
    
    action invariant int(0,14) <= body_index && body_index <= body_iterations
    
    action invariant tot@(len) = 1 ==> 576 = 64*bv2int(len[@])
    action invariant rd@(len) = 1 ==> (
      body_iterations = bvresize(len[@],14) * uint(32,14) &&
      2*bv2int(body_iterations) = 576 &&
      rd@(symb)  = 2*bv2int(body_index)
    )
   
    action invariant state(s_idle) ==> (
      rd@(symb)  = 2*bv2int(body_index) &&
      tot@(hsp)  = 16*bv2int(body_index) &&
      16*rd@(symb) = 2*tot@(hsp) &&
      tot@(done) = 0 &&
      rd@(len)   = 1
    )

    action invariant state(s_start) && rd@(len) = 1 ==> (
      rd@(symb)  = 2*bv2int(body_iterations) &&
      tot@(hsp)  = 16*bv2int(body_iterations)+8 &&
      16*rd@(symb) = 2*(tot@(hsp)-8) &&
      tot@(done) = 1
    )

    action invariant state(s_start) && rd@(len) = 0 ==> (
      rd@(symb)  = 0 &&
      tot@(hsp)  = 0 &&
      tot@(done) = 0
    )

	bv(size=8) symb_mem;     // Temporary storage for symbol values during transmission
                                    // the current hsp. range: [0...8] 
	bv(size=14) body_iterations := int(0,14);   // Number of times the "body" part of the transmission has to be repeated 
	bv(size=14) body_index := int(0,14);        // Number of times the "body" part of the transmission has been repeated

    bv(size=8) FILT_COEFF0 = 0x00;         // Static filter coefficients for half-sine pulse generation
    bv(size=8) FILT_COEFF1 = 0x31;
    bv(size=8) FILT_COEFF2 = 0x5a;
    bv(size=8) FILT_COEFF3 = 0x76;
    bv(size=8) FILT_COEFF4 = 0x7f;
    
    List(type: bv(size=8), size=16) hsps;

	// fixed-point multiplication with shift
	function mul8( bv(size=8) x, bv(size=8) y ) --> bv(size=8) :
		(x * y) >> int(7,8)
	end

	// init action
	// Fired when payload length is known
	init: action len:[len_in] ==>
	do
		symb_mem := 0x7F;
		body_iterations := bvresize(len_in,14) * int(32,14);
		body_index := int(0,14);
	end

	// tx-body action
	// Consumes 2, produces 16 samples
	tx_body: action 
		symb:[ symb_1, symb_2 ]
		==> 
		hsp:[ hsps[0],hsps[1],hsps[2],hsps[3],hsps[4],hsps[5],hsps[6],hsps[7],
			hsps[8],hsps[9],hsps[10],hsps[11],hsps[12],hsps[13],hsps[14],hsps[15] ]
	guard
		body_index < body_iterations
	do	
		hsps[0] := mul8(FILT_COEFF0, symb_1);
		hsps[1] := mul8(FILT_COEFF4, symb_mem);
	
		hsps[2] := mul8(FILT_COEFF1, symb_1);
		hsps[3] := mul8(FILT_COEFF3, symb_mem);
	
		hsps[4] := mul8(FILT_COEFF2, symb_1);
		hsps[5] := mul8(FILT_COEFF2, symb_mem);
	
		hsps[6] := mul8(FILT_COEFF3, symb_1);
		hsps[7] := mul8(FILT_COEFF1, symb_mem);
	
		hsps[8] := mul8(FILT_COEFF4, symb_1);
		hsps[9] := mul8(FILT_COEFF0, symb_2);
	
		hsps[10] := mul8(FILT_COEFF3, symb_1);
		hsps[11] := mul8(FILT_COEFF1, symb_2);
	
		hsps[12] := mul8(FILT_COEFF2, symb_1);
		hsps[13] := mul8(FILT_COEFF2, symb_2);
	
		hsps[14] := mul8(FILT_COEFF1, symb_1);
		hsps[15] := mul8(FILT_COEFF3, symb_2);
	
		symb_mem := symb_2;
		body_index := body_index + int(1,14);
	end

	// tx_tail action
	// Finalizes the transmission signal with the fixed 0x7F value
	tx_tail: action 
		==> 
		hsp:[ hsps[0],hsps[1],hsps[2],hsps[3],hsps[4],hsps[5],hsps[6],hsps[7] ], 
		done: [ true ]
	guard
		body_index = body_iterations
	do
		hsps[0] := mul8(FILT_COEFF0, 0x7F);
		hsps[1] := mul8(FILT_COEFF4, symb_mem);
	
		hsps[2] := mul8(FILT_COEFF1, 0x7F);
		hsps[3] := mul8(FILT_COEFF3, symb_mem);
	
		hsps[4] := mul8(FILT_COEFF2, 0x7F);
		hsps[5] := mul8(FILT_COEFF2, symb_mem);
	
		hsps[6] := mul8(FILT_COEFF3, 0x7F);
		hsps[7] := mul8(FILT_COEFF1, symb_mem);
		
	end
	
	
	schedule fsm s_start :
		s_start ( init ) --> s_idle;
		s_idle ( tx_body ) --> s_idle;
		s_idle ( tx_tail ) --> s_start;
	end
	
end



actor qpskMod() 
// Inputs:
bv(size=32) chip              // Packets of 32 chips.
// Outputs:
==> 
bv(size=8) symb               // I-Q symbols. Range: [-128, 127]
:
	// mapping of chips to I-Q samples
	function q7_map( bv(size=32) bit ) --> bv(size=8) :
		bvresize( (int(255,32) * bit - int(128,32)) , 8)	
	end
	
	//stream invariant 32*rd(chip) = tot(symb)
	
	List(type: bv(size=8), size=32) IQ;

	// transforms a chip to I-Q modulated samples and sends
	action 
		chip:[ c_in ] ==> 
		symb:[
			IQ[0],IQ[1],IQ[2],IQ[3],IQ[4],IQ[5],IQ[6],IQ[7],
			IQ[8],IQ[9],IQ[10],IQ[11],IQ[12],IQ[13],IQ[14],IQ[15],
			IQ[16],IQ[17],IQ[18],IQ[19],IQ[20],IQ[21],IQ[22],IQ[23],
			IQ[24],IQ[25],IQ[26],IQ[27],IQ[28],IQ[29],IQ[30],IQ[31]]
	do
		IQ[0] := q7_map((c_in >> 0x00000000) & 0x00000001);
		IQ[1] := q7_map((c_in >> 0x00000001) & 0x00000001);
		IQ[2] := q7_map((c_in >> 0x00000002) & 0x00000001);
		IQ[3] := q7_map((c_in >> 0x00000003) & 0x00000001);
		IQ[4] := q7_map((c_in >> 0x00000004) & 0x00000001);
		IQ[5] := q7_map((c_in >> 0x00000005) & 0x00000001);
		IQ[6] := q7_map((c_in >> 0x00000006) & 0x00000001);
		IQ[7] := q7_map((c_in >> 0x00000007) & 0x00000001);
		IQ[8] := q7_map((c_in >> 0x00000008) & 0x00000001);
		IQ[9] := q7_map((c_in >> 0x00000009) & 0x00000001);
		IQ[10] := q7_map((c_in >> 0x0000000A) & 0x00000001);
		IQ[11] := q7_map((c_in >> 0x0000000B) & 0x00000001);
		IQ[12] := q7_map((c_in >> 0x0000000C) & 0x00000001);
		IQ[13] := q7_map((c_in >> 0x0000000D) & 0x00000001);
		IQ[14] := q7_map((c_in >> 0x0000000E) & 0x00000001);
		IQ[15] := q7_map((c_in >> 0x0000000F) & 0x00000001);
		IQ[16] := q7_map((c_in >> 0x00000010) & 0x00000001);
		IQ[17] := q7_map((c_in >> 0x00000011) & 0x00000001);
		IQ[18] := q7_map((c_in >> 0x00000012) & 0x00000001);
		IQ[19] := q7_map((c_in >> 0x00000013) & 0x00000001);
		IQ[20] := q7_map((c_in >> 0x00000014) & 0x00000001);
		IQ[21] := q7_map((c_in >> 0x00000015) & 0x00000001);
		IQ[22] := q7_map((c_in >> 0x00000016) & 0x00000001);
		IQ[23] := q7_map((c_in >> 0x00000017) & 0x00000001);
		IQ[24] := q7_map((c_in >> 0x00000018) & 0x00000001);
		IQ[25] := q7_map((c_in >> 0x00000019) & 0x00000001);
		IQ[26] := q7_map((c_in >> 0x0000001A) & 0x00000001);
		IQ[27] := q7_map((c_in >> 0x0000001B) & 0x00000001);
		IQ[28] := q7_map((c_in >> 0x0000001C) & 0x00000001);
		IQ[29] := q7_map((c_in >> 0x0000001D) & 0x00000001);
		IQ[30] := q7_map((c_in >> 0x0000001E) & 0x00000001);
		IQ[31] := q7_map((c_in >> 0x0000001F) & 0x00000001);
	end
end

network ZigBee bv(size=8) pl_bits ==> bool done, bv(size=8) hsp:

  Main: contract pl_bits:4 ==> done:1, hsp:4616
    requires pl_bits[@] = 0x03
  end
  
  
  action invariant 4*@(done) = @(pl_bits)
  action invariant 4616*@(done) = @(hsp)
  
  action invariant @(ch_symb) = 576*@(ch_done)
  action invariant @(ch_len) = @(ch_done)
  action invariant @(ch_hsp) = 4616*@(ch_len)
  
  action invariant 9*@(ch_pl_bits) = 4*@(ch_data)
  action invariant @(ch_pl_bits) = 4*@(ch_len)
  
  action invariant rd(ch_symb) = 576*tot(ch_done)
  action invariant rd(ch_len) = tot(ch_done)
  action invariant tot(ch_hsp) = 4616*rd(ch_len)
  
  action invariant 9*rd(ch_pl_bits) = 4*tot(ch_data)
  action invariant rd(ch_pl_bits) = 4*tot(ch_len)
  
  action invariant tot@(pl_bits) > 0 ==> pl_bits[@] = int(3,8)
  action invariant rd@(pl_bits) > 0 ==> ch_len[@] = bvresize(pl_bits[@],9) + int(6,9)

  entities
    ha = headerAdd();
    cm = chipMapper();
    qm = qpskMod();
    ps = pulseShape();
  end
  
  structure
    ch_pl_bits: pl_bits --> ha.pl_bits;
    ch_data: ha.data --> cm.data;
    ch_chip: cm.chip --> qm.chip;
    ch_symb: qm.symb --> ps.symb;
    ch_len: ha.len --> ps.len;
    ch_done: ps.done --> done;
    ch_hsp: ps.hsp --> hsp;
  end

end
