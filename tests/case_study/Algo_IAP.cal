actor Algo_IAP () 
  int(size=13) PQF_AC, int(size=11) PTR, int(size=3) AC_PRED_DIR 
  ==> 
  int(size=13) QF_AC :
  
  NewVop:
  contract AC_PRED_DIR:1 ==>
    guard AC_PRED_DIR[@] = -int(2,3)
  end
  
  Skip:
  contract AC_PRED_DIR:1 ==>
    guard AC_PRED_DIR[@] != -int(2,3)
    guard AC_PRED_DIR[@] < int(0,3)
  end
  
  Start:
  contract AC_PRED_DIR:1, PTR:1, PQF_AC:63 ==> QF_AC:63
    guard AC_PRED_DIR[@] >= int(0,3)
  end
  
  //stream 
  invariant rd@(AC_PRED_DIR) = 0 ==> state(start)
  
  invariant state(pred) ==> int(1,8) <= count && count <= int(64,8)
  
  invariant mode(NewVop) && tot@(AC_PRED_DIR) > 0 ==> AC_PRED_DIR[@] = -int(2,3)
  invariant mode(NewVop) ==> tot@(QF_AC) = 0
  invariant mode(NewVop) ==> state(start)
  
  invariant mode(Skip) && tot@(AC_PRED_DIR) > 0 ==> AC_PRED_DIR[@] != -int(2,3) && AC_PRED_DIR[@] < int(0,3)
  invariant mode(Skip) ==> tot@(QF_AC) = 0
  invariant mode(Skip) ==> state(pred) || state(start)
  invariant mode(Skip) && state(pred) ==> rd@(AC_PRED_DIR) = 1
  invariant mode(Skip) && rd@(AC_PRED_DIR) = 1 ==> count = int(64,8)
  
  invariant mode(Start) && tot@(AC_PRED_DIR) > 0 ==> AC_PRED_DIR[@] >= int(0,3)
  invariant mode(Start) && state(start) ==> (
  	(rd@(AC_PRED_DIR) = 0 && rd@(PTR) = 0 && tot@(QF_AC) = 0 && rd@(PQF_AC) = 0) ||  
  	(rd@(AC_PRED_DIR) = 1 && rd@(PTR) = 1 && tot@(QF_AC) = 63 && rd@(PQF_AC) = 63))
  invariant mode(Start) && state(pred) ==> rd@(AC_PRED_DIR) = 1 && rd@(PTR) = 1
  invariant mode(Start) && state(pred) ==> tot@(QF_AC) = bv2int(count)-1 && rd@(PQF_AC) = bv2int(count)-1
  

  int(size=8) count;

  // Use 3 address lines for component index to save address calculation effort
  // Also, location 0 is reserved for all uncoded blocks. This protocol must
  // be identical to the buffer addressing in Predict.cal and Sequence.cal, since
  // pointer values are generated there.
  int(size=11) BUF_SIZE = (MAXW_IN_MB + int(2,11)) * int(8,11);

  int(size=11) ptr;

  int(size=11) pred_ptr;


  // Initialize to the dummy values needed for uncoded blocks (always mapped to index 0)
  // Add 4 address lines  so that we can store the left edge and top edge AC values (14 in all).
  Map(int(size=11) -> int(size=13), size=15744) buf;

  int(size=4) comp;

  bool top;

  bool acpred_flag;

  newvop: action AC_PRED_DIR:[ s ] ==>
  guard
    s = -int(2,3)
  do
    comp := int(0,4);
    ptr := int(8,11);
    // Start at 8, since 0-7 are reserved

  end

  skip: action AC_PRED_DIR:[ s ] ==>
  guard
    s < int(0,3)
  do
    count := int(64,8);
  end

  start: action AC_PRED_DIR:[ s ], PTR:[ p ] ==>
  do
    count := int(1,8);
    pred_ptr := p;
    top := s = int(2,3);
    acpred_flag := s != int(0,3);
  end

  advance: action ==>
  guard
    count = int(64,8)
  do
    comp := comp + int(1,4);
    if comp = int(6,4) then
      comp := int(0,4);
      ptr := if ptr = int(8,11) then
        BUF_SIZE - int(8,11)
      else
        ptr - int(8,11)
      end;
    end
  end

  copy: action PQF_AC:[ ac ] ==> QF_AC:[ pred_ ]
  var
    int(size=13) pred_ := ac , 
    int(size=4) v = bvresize (count & int(7,8), 4) ,
    int(size=4) h = bvresize( (count >> int(3,8)) & int(7,8), 4) , 
    bool top_edge = (h = int(0,4)) ,
    bool left_edge = (v = int(0,4)) , 
    int(size=5) index = bvresize(if top_edge then
      v
    else
      (h | int(8,4))
    end, 5)
  do
    if acpred_flag and ((top and top_edge) or ((not top) and left_edge)) then
      pred_ := pred_ + buf[((pred_ptr << int(4,11)) | bvresize(index,11))];
    end
    if left_edge or top_edge then
      buf[(((ptr | bvresize(comp,11)) << int(4,11)) | bvresize(index,11))] := pred_;
    end
    count := count + int(1,8);
  end


  schedule fsm start :
    start ( newvop ) --> start;
    start ( skip ) --> pred;
    start ( start ) --> pred;
    pred ( copy ) --> pred;
    pred ( advance ) --> start;
  end

  priority
    newvop > skip;
    newvop > start;
    skip > start;
    advance > copy;
  end

end
