
actor Algo_DCRinvpred () 
	int(size=12) BTYPE, 
	int(size=11) A, 
	int(size=11) B, 
	int(size=11) C, 
	int(size=13) QFS_DC, 
	int(size=6) QP 
	==>
	int(size=13) QF_DC, 
	int(size=11) PTR, 
	int(size=3) AC_PRED_DIR ,
	int(size=3) MODE, 
	bool SIGNED, 
	int(size=6) QUANT :
	
	StartMode:
	contract
		BTYPE:3
		==>
		AC_PRED_DIR:1
		
		guard (BTYPE[@] & NEWVOP) != 0x000
		ensures AC_PRED_DIR[@] = -int2bv(2,3)
		
	end
	
	InterMode:
	contract
		BTYPE:1,
		QP:1,
		QFS_DC:1
		==>
		QF_DC:1,
		PTR:1,
		AC_PRED_DIR:1,
		MODE:1,
		SIGNED:1,
		QUANT:1
		
		guard (BTYPE[@] & NEWVOP) = 0x000
		guard (BTYPE[@] & INTER) != 0x000 && (BTYPE[@] & ACCODED) != 0x000
		ensures AC_PRED_DIR[@] = int2bv(0,3)
		ensures MODE[@] = int2bv(0,3)
	end
	
	OtherMode:
	contract
		BTYPE:1,
		QP:1
		==>
		AC_PRED_DIR:1
		
		guard (BTYPE[@] & NEWVOP) = 0x000
		guard (BTYPE[@] & INTRA) = 0x000
		guard (BTYPE[@] & ACCODED) = 0x000
		ensures AC_PRED_DIR[@] = -int2bv(1,3)
	end
	
	IntraMode:
	contract
		BTYPE:1,
		A:1,
		B:1,
		C:1,
		QFS_DC:1,
		QP:1
		==>
		QF_DC:1,
		PTR:1,
		AC_PRED_DIR:1,
		MODE:1,
		SIGNED:1,
		QUANT:1
		
		guard (BTYPE[@] & NEWVOP) = 0x000
		guard (BTYPE[@] & INTER) = 0x000
		guard (BTYPE[@] & INTRA) != 0x000
		ensures int2bv(0,3) <= AC_PRED_DIR[@] && AC_PRED_DIR[@] <= int2bv(2,3)
		ensures int2bv(0,3) <= MODE[@] && MODE[@] <= int2bv(2,3)
	end
	
	invariant rd@(BTYPE) = 0 ==> state(read)
	
	invariant mode(StartMode) && tot@(BTYPE) > 0 ==> (BTYPE[@] & NEWVOP) != 0x000
	invariant mode(InterMode) && tot@(BTYPE) > 0 ==> (BTYPE[@] & NEWVOP) = 0x000 && (BTYPE[@] & INTER) != 0x000 && (BTYPE[@] & ACCODED) != 0x000
	invariant mode(OtherMode) && tot@(BTYPE) > 0 ==> (BTYPE[@] & NEWVOP) = 0x000 && (BTYPE[@] & INTRA) = 0x000 && (BTYPE[@] & ACCODED) = 0x000
	invariant mode(IntraMode) && tot@(BTYPE) > 0 ==> (BTYPE[@] & NEWVOP) = 0x000 && (BTYPE[@] & INTER) = 0x000 && (BTYPE[@] & INTRA) != 0x000
	
	// Start Mode
	invariant mode(StartMode) ==> state(read) || state(getw) || state(geth)
	invariant mode(StartMode) && rd@(BTYPE) = 1 ==> state(getw)
	invariant mode(StartMode) && rd@(BTYPE) = 2 ==> state(geth)
	invariant mode(StartMode) && rd@(BTYPE) = 3 ==> state(read)
	invariant mode(StartMode) ==>
		rd@(QP) = 0 && rd@(QFS_DC) = 0 && tot@(MODE) = 0 && tot@(PTR) = 0 && tot@(SIGNED) = 0 && tot@(QUANT) = 0 && tot(QF_DC) = 0
	invariant mode(StartMode) && rd@(BTYPE) = 0 ==> tot@(AC_PRED_DIR) = 0
	invariant mode(StartMode) && rd@(BTYPE) > 0 ==> tot@(AC_PRED_DIR) = 1
	invariant mode(StartMode) && tot@(AC_PRED_DIR) > 0 ==> AC_PRED_DIR[@] = -int2bv(2,3)
	
	
	// Inter Mode
	invariant mode(InterMode) ==> state(read) || state(inter) || state(sat) || state(advance)
	invariant mode(InterMode) ==> rd@(A) = 0 && rd@(B) = 0 && rd@(C) = 0
	
	invariant mode(InterMode) && state(read) ==>
		(rd@(BTYPE) = 0 && rd@(QP) = 0 && rd@(QFS_DC) = 0 && tot@(AC_PRED_DIR) = 0 && tot@(MODE) = 0 && tot@(PTR) = 0 && tot@(SIGNED) = 0 && tot@(QUANT) = 0 && tot@(QF_DC) = 0) ||
		(rd@(BTYPE) = 1 && rd@(QP) = 1 && rd@(QFS_DC) = 1 && tot@(AC_PRED_DIR) = 1 && tot@(MODE) = 1 && tot@(PTR) = 1 && tot@(SIGNED) = 1 && tot@(QUANT) = 1  && tot@(QF_DC) = 1)
		
	invariant mode(InterMode) && state(inter) ==> 
		rd@(BTYPE) = 1 && rd@(QP) = 1 && rd@(QFS_DC) = 0 && tot@(AC_PRED_DIR) = 1 && tot@(MODE) = 1 && tot@(PTR) = 1 && tot@(SIGNED) = 1 && tot@(QUANT) = 1  && tot@(QF_DC) = 0
	invariant mode(InterMode) && state(sat) ==> 
		rd@(BTYPE) = 1 && rd@(QP) = 1 && rd@(QFS_DC) = 1 && tot@(AC_PRED_DIR) = 1 && tot@(MODE) = 1 && tot@(PTR) = 1 && tot@(SIGNED) = 1 && tot@(QUANT) = 1  && tot@(QF_DC) = 0
	invariant mode(InterMode) && state(advance)  ==> 
		rd@(BTYPE) = 1 && rd@(QP) = 1 && rd@(QFS_DC) = 1 && tot@(AC_PRED_DIR) = 1 && tot@(MODE) = 1 && tot@(PTR) = 1 && tot@(SIGNED) = 1 && tot@(QUANT) = 1  && tot@(QF_DC) = 1
	invariant mode(InterMode) && tot@(AC_PRED_DIR) > 0 ==> AC_PRED_DIR[@] = int2bv(0,3) && MODE[@] = int2bv(0,3)
	
	// Intra Mode
	invariant mode(IntraMode) ==> state(read) || state(intra) || state(sat) || state(advance)
	
	invariant mode(IntraMode) && state(read) ==>
		(rd@(BTYPE) = 0 && rd@(A) = 0 && rd@(B) = 0 && rd@(C) = 0 && rd@(QP) = 0 && rd@(QFS_DC) = 0 && tot@(AC_PRED_DIR) = 0 && tot@(MODE) = 0 && tot@(PTR) = 0 && tot@(SIGNED) = 0 && tot@(QUANT) = 0 && tot@(QF_DC) = 0) ||
		(rd@(BTYPE) = 1 && rd@(A) = 1 && rd@(B) = 1 && rd@(C) = 1 && rd@(QP) = 1 && rd@(QFS_DC) = 1 && tot@(AC_PRED_DIR) = 1 && tot@(MODE) = 1 && tot@(PTR) = 1 && tot@(SIGNED) = 1 && tot@(QUANT) = 1  && tot@(QF_DC) = 1)
		
	invariant mode(IntraMode) && state(intra) ==> 
		rd@(BTYPE) = 1 && rd@(A) = 1 && rd@(B) = 1 && rd@(C) = 1 && rd@(QP) = 1 && rd@(QFS_DC) = 0 && tot@(AC_PRED_DIR) = 1 && tot@(MODE) = 1 && tot@(PTR) = 1 && tot@(SIGNED) = 1 && tot@(QUANT) = 1  && tot@(QF_DC) = 0
	invariant mode(IntraMode) && state(sat) ==> 
		rd@(BTYPE) = 1 && rd@(A) = 1 && rd@(B) = 1 && rd@(C) = 1 && rd@(QP) = 1 && rd@(QFS_DC) = 1 && tot@(AC_PRED_DIR) = 1 && tot@(MODE) = 1 && tot@(PTR) = 1 && tot@(SIGNED) = 1 && tot@(QUANT) = 1  && tot@(QF_DC) = 0
	invariant mode(IntraMode) && state(advance)  ==> 
		rd@(BTYPE) = 1 && rd@(A) = 1 && rd@(B) = 1 && rd@(C) = 1 && rd@(QP) = 1 && rd@(QFS_DC) = 1 && tot@(AC_PRED_DIR) = 1 && tot@(MODE) = 1 && tot@(PTR) = 1 && tot@(SIGNED) = 1 && tot@(QUANT) = 1  && tot@(QF_DC) = 1
	invariant mode(IntraMode) && tot@(AC_PRED_DIR) > 0 ==> int2bv(0,3) <= AC_PRED_DIR[@] && AC_PRED_DIR[@] <= int2bv(2,3) && AC_PRED_DIR[@] = MODE[@]
	
	
	// Other Mode
	invariant mode(OtherMode) ==> state(read) || state(advance)
	
	invariant mode(OtherMode) && state(read) ==>
		(rd@(BTYPE) = 0 && rd@(A) = 0 && rd@(B) = 0 && rd@(C) = 0 && rd@(QP) = 0 && rd@(QFS_DC) = 0 && tot@(AC_PRED_DIR) = 0 && tot@(MODE) = 0 && tot@(PTR) = 0 && tot@(SIGNED) = 0 && tot@(QUANT) = 0 && tot@(QF_DC) = 0) ||
		(rd@(BTYPE) = 1 && rd@(A) = 0 && rd@(B) = 0 && rd@(C) = 0 && rd@(QP) = 1 && rd@(QFS_DC) = 0 && tot@(AC_PRED_DIR) = 1 && tot@(MODE) = 0 && tot@(PTR) = 0 && tot@(SIGNED) = 0 && tot@(QUANT) = 0 && tot@(QF_DC) = 0)
		
	invariant mode(OtherMode) && state(advance) ==>
		(rd@(BTYPE) = 1 && rd@(A) = 0 && rd@(B) = 0 && rd@(C) = 0 && rd@(QP) = 1 && rd@(QFS_DC) = 0 && tot@(AC_PRED_DIR) = 1 && tot@(MODE) = 0 && tot@(PTR) = 0 && tot@(SIGNED) = 0 && tot@(QUANT) = 0 && tot@(QF_DC) = 0)
	invariant mode(OtherMode) && tot@(AC_PRED_DIR) > 0 ==> AC_PRED_DIR[@] = -int2bv(1,3)
	
	// Decoded 'quantiser_scale' - see ISO/IEC 14496-2
	int(size=6) s_QP;

	// Flag to indicate whether 'quantiser_scale' is even or odd
	int(size=2) round;

	// Have 4 8x8 blocks per MB
	int(size=32) BUF_SIZE = int2bv(984,32);

	// Pointer to current 8x8 block on current row
	// using circular buffer addressing. Start at 4, since 0-3 are reserved.
	int(size=32) ptr;

	// 8x8 block component in macroblock index
	int(size=4) comp;

	  // JWJ: increased size
	// Initialize to the dummy values needed for uncoded blocks (always mapped to index 0)
	Map(int(size=32) -> int(size=13)) dc_buf; //:= [ DCVAL : for int k in 1 .. BUF_SIZE ];

	// Decoded DC prediction value
	int(size=13) dc_pred;
	// Decoded 'dc_scalar'
	int(size=7) scaler;
	int(size=13) dc_val;

	// Flag to indicate INTER or INTRA block
	bool is_signed;
	
	
	function saturate(int(size=13) x) --> int(size=13):
		if x < -2048 then
			-2048
		else
			if x > 2047 then
				2047
			else
				x
			end
		end
	end
	
	function dc_scaler() --> int(size=7) :
		if (comp & 4) = 0 then
		// Y component
			if s_QP > 0 and s_QP < 5 then
				8
			else
				if s_QP > 4 and s_QP < 9 then
					2 * s_QP
				else
					if s_QP > 8 and s_QP < 25 then
						s_QP + 8
					else
						(2 * s_QP) - 16
					end
				end
			end
		else
		// UV component
			if s_QP > 0 and s_QP < 5 then
				8
			else
				if s_QP > 4 and s_QP < 25 then
					(s_QP + 13) >> 1
				else
					s_QP - 6
				end
			end
		end
	end
	
	initialize ==>
	do
		comp := 0x0;
		ptr := int2bv(8,32);
	end

	// Reconstructed DC coefficient  
	start: action BTYPE:[ cmd ] ==> AC_PRED_DIR:[ int2bv(-2,3) ]
	guard
		(cmd & NEWVOP) != 0x000
	do
		comp := 0x0;
		ptr := int2bv(8,32);
	end

	// Used to skip BTYPE tokens where necessary
	skip: action BTYPE:[ x ] ==>
	end

	read.inter_ac: action BTYPE:[ cmd ], QP:[ qp ] ==> AC_PRED_DIR:[ int2bv(0,3) ], MODE:[ int2bv(0,3) ], PTR:[ int2bv(0,11) ],
		SIGNED:[ true ], QUANT:[ s_QP ]
	guard
		(cmd & INTER) != 0x000 &&
		(cmd & ACCODED) != 0x000
	do
		is_signed := true;
		s_QP := qp;
		round := bvresize( ((s_QP & int2bv(1,6)) ^ int2bv(1,6)) , 2 );
	end

	read.other: action BTYPE:[ cmd ], QP:[ qp ] ==> AC_PRED_DIR:[ int2bv(-1,3) ]
	guard
		(cmd & INTRA) = 0x000 &&
		(cmd & ACCODED) = 0x000
	do
		s_QP := qp;
	end


	read.intra: action BTYPE:[ cmd ], QP:[ qp ], A:[ a ], B:[ b ], C:[ c ] ==> PTR:[ if top then
			c
		else
			a
		end ], AC_PRED_DIR:[ s ], MODE:[ s ], SIGNED:[ is_signed ], QUANT:[ s_QP ]
	var
		int(size=13) dca = dc_buf[bvresize(a,32)] , 
		int(size=13) dcb = dc_buf[bvresize(b,32)] ,
		int(size=13) dcc = dc_buf[bvresize(c,32)] , 
		int(size=13) horiz = abs(dcb - dcc) ,
		int(size=13) vert = abs(dca - dcb) , 
		bool top = vert < horiz , 
		int(size=3) s , 
		bool ac = (cmd & ACPRED) != int2bv(0,12)
	do
		s_QP := qp;
		scaler := dc_scaler();
		// Retrieve 'dc_scalar'. See ISO/IEC 14496-2 Table 7-1.
		dc_pred := 
			(if top then
				dcc
			else
				dca
			end) 
			+ bvresize( (scaler >> int2bv(1,7)) / scaler , 13 );
			
		// See ISO/IEC 14496-2 Section 7.4.3.2.
		s := 
			if not ac then
				int2bv(0,3)
			else
				if top then
					int2bv(2,3)
				else
					int2bv(1,3)
				end
			end;
		// Set 'ac_pred_dir'
		is_signed := scaler = int2bv(0,7);
		// Will never be true!

	end

	getdc.inter: action QFS_DC:[ dc ] ==>
	var
		int(size=13) v = (bvresize(s_QP,13) * ((abs(dc) << int2bv(1,13)) + int2bv(1,13))) - bvresize(round,13) // See ISO/IEC 14496-2 Section 7.4.4.2.1 (H.263).

	do
		dc_val := if dc = int2bv(0,13) then
			int2bv(0,13)
		else
			if not is_signed then
				dc
			else
				if dc < int2bv(0,13) then
					-v
				else
					v
				end
			end
		end;
	end

	// Do inverse prediction on INTRA block DC
	getdc.intra: action QFS_DC:[ dc ] ==>
	do
		dc_val := (dc + dc_pred) * bvresize(scaler,13);
		// See ISO/IEC 14496-2 Section 7.4.3.2 and Section 7.4.4.1.1.

	end

	sat: action ==> QF_DC:[ dc ]
	var
		int(size=13) dc = saturate(dc_val)
	do
		dc_buf[(ptr | bvresize(comp,32))] := dc;
	end

	advance: action ==>
	do
		comp := comp + int2bv(1,4);
		if comp = int2bv(6,4) then
			comp := int2bv(0,4);
			ptr := if ptr = int2bv(8,32) then
				BUF_SIZE - int2bv(8,32)
			else
				ptr - int2bv(8,32)
			end;
		end
	end


	schedule fsm read :
		read ( start ) --> getw;
		read ( read.inter_ac ) --> inter;
		read ( read.intra ) --> intra;
		read ( read.other ) --> advance;
		getw ( skip ) --> geth;
		geth ( skip ) --> read;
		intra ( getdc.intra ) --> sat;
		inter ( getdc.inter ) --> sat;
		sat ( sat ) --> advance;
		advance ( advance ) --> read;
	end


	priority
		start > read.inter_ac;
		start > read.other;
		start > read.intra;
		read.inter_ac > read.other;
		read.inter_ac > read.intra;
		read.other > read.intra;
	end

end