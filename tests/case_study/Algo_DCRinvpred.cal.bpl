// ---------------------------------------------------------------
// -- Types and global variables ---------------------------------
// ---------------------------------------------------------------
type Ref;
type Chan a;
type Field a;
type Actor;
type CType = <a>[Chan a]int;
type MType = <a>[Chan a][int]a;
type Obj = <a>[Field a]a;
type HType = [Ref]Obj;
type ModeType = [Actor]int;

var M#: MType;
var C#: CType;
var R#: CType;
var I#: CType;
var B#: CType;
var Mode#: ModeType;
var I#sub: CType;

var H#: HType;

const unique this#: Actor;

function AT#Min(x:int, y: int): int { if x <= y then x else y }

// ---------------------------------------------------------------
// -- Axiomatisation for map data type ---------------------------
// ---------------------------------------------------------------
type Map a b;

function Map#Select<T,U>(Map T U, T): U;
function Map#Store<T,U>(Map T U, T, U): Map T U;
axiom (
  forall<T,U> m: Map T U, k1: T, val: U :: { Map#Store(m,k1,val) }
    Map#Select(Map#Store(m,k1,val),k1) == val
);
axiom (
  forall<T,U> m: Map T U, k1: T, k2: T, val: U :: { Map#Select(Map#Store(m,k1,val),k2) }
    k1 != k2 ==> Map#Select(Map#Store(m,k1,val),k2) == Map#Select(m,k2)
);

// ---------------------------------------------------------------
// -- Bit vector operations --------------------------------------
// ---------------------------------------------------------------
// Size: 13
function {:bvbuiltin "bvand"} AT#BvAnd13(a: bv13, b: bv13): bv13;
function {:bvbuiltin "bvor"} AT#BvOr13(a: bv13, b: bv13): bv13;
function {:bvbuiltin "bvnot"} AT#BvNot13(a: bv13): bv13;
function {:bvbuiltin "bvneg"} AT#BvNeg13(a: bv13): bv13;
function {:bvbuiltin "bvadd"} AT#BvAdd13(a: bv13, b: bv13): bv13;
function {:bvbuiltin "bvsub"} AT#BvSub13(a: bv13, b: bv13): bv13;
function {:bvbuiltin "bvmul"} AT#BvMul13(a: bv13, b: bv13): bv13;
function {:bvbuiltin "bvsdiv"} AT#BvSdiv13(a: bv13, b: bv13): bv13;
function {:bvbuiltin "bvudiv"} AT#BvUdiv13(a: bv13, b: bv13): bv13;
function {:bvbuiltin "bvshl"} AT#BvShl13(bv13,bv13): bv13;
function {:bvbuiltin "bvlshr"} AT#BvLshr13(bv13,bv13): bv13;
function {:bvbuiltin "bvashr"} AT#BvAshr13(bv13,bv13): bv13;
function {:bvbuiltin "bvule"} AT#BvUle13(a: bv13, b: bv13): bool;
function {:bvbuiltin "bvult"} AT#BvUlt13(a: bv13, b: bv13): bool;
function {:bvbuiltin "bvuge"} AT#BvUge13(a: bv13, b: bv13): bool;
function {:bvbuiltin "bvugt"} AT#BvUgt13(a: bv13, b: bv13): bool;
function {:bvbuiltin "bvsle"} AT#BvSle13(a: bv13, b: bv13): bool;
function {:bvbuiltin "bvslt"} AT#BvSlt13(a: bv13, b: bv13): bool;
function {:bvbuiltin "bvsge"} AT#BvSge13(a: bv13, b: bv13): bool;
function {:bvbuiltin "bvsgt"} AT#BvSgt13(a: bv13, b: bv13): bool;
function AT#BvXor13(a: bv13, b: bv13): bv13;
function AT#BvAbs13(a: bv13): bv13;

axiom (forall a,b: bv13 :: AT#BvXor13(a,b) == AT#BvAnd13(AT#BvOr13(a,b), AT#BvNot13(AT#BvAnd13(a,b))) );
axiom (forall a,b: bv13 :: AT#BvAbs13(a) == (if AT#BvSle13(0bv13,a) then a else AT#BvNeg13(a)) );

// ---------------------------------------------------------------
// -- Bit vector operations --------------------------------------
// ---------------------------------------------------------------
// Size: 6
function {:bvbuiltin "bvand"} AT#BvAnd6(a: bv6, b: bv6): bv6;
function {:bvbuiltin "bvor"} AT#BvOr6(a: bv6, b: bv6): bv6;
function {:bvbuiltin "bvnot"} AT#BvNot6(a: bv6): bv6;
function {:bvbuiltin "bvneg"} AT#BvNeg6(a: bv6): bv6;
function {:bvbuiltin "bvadd"} AT#BvAdd6(a: bv6, b: bv6): bv6;
function {:bvbuiltin "bvsub"} AT#BvSub6(a: bv6, b: bv6): bv6;
function {:bvbuiltin "bvmul"} AT#BvMul6(a: bv6, b: bv6): bv6;
function {:bvbuiltin "bvsdiv"} AT#BvSdiv6(a: bv6, b: bv6): bv6;
function {:bvbuiltin "bvudiv"} AT#BvUdiv6(a: bv6, b: bv6): bv6;
function {:bvbuiltin "bvshl"} AT#BvShl6(bv6,bv6): bv6;
function {:bvbuiltin "bvlshr"} AT#BvLshr6(bv6,bv6): bv6;
function {:bvbuiltin "bvashr"} AT#BvAshr6(bv6,bv6): bv6;
function {:bvbuiltin "bvule"} AT#BvUle6(a: bv6, b: bv6): bool;
function {:bvbuiltin "bvult"} AT#BvUlt6(a: bv6, b: bv6): bool;
function {:bvbuiltin "bvuge"} AT#BvUge6(a: bv6, b: bv6): bool;
function {:bvbuiltin "bvugt"} AT#BvUgt6(a: bv6, b: bv6): bool;
function {:bvbuiltin "bvsle"} AT#BvSle6(a: bv6, b: bv6): bool;
function {:bvbuiltin "bvslt"} AT#BvSlt6(a: bv6, b: bv6): bool;
function {:bvbuiltin "bvsge"} AT#BvSge6(a: bv6, b: bv6): bool;
function {:bvbuiltin "bvsgt"} AT#BvSgt6(a: bv6, b: bv6): bool;
function AT#BvXor6(a: bv6, b: bv6): bv6;
function AT#BvAbs6(a: bv6): bv6;

axiom (forall a,b: bv6 :: AT#BvXor6(a,b) == AT#BvAnd6(AT#BvOr6(a,b), AT#BvNot6(AT#BvAnd6(a,b))) );
axiom (forall a,b: bv6 :: AT#BvAbs6(a) == (if AT#BvSle6(0bv6,a) then a else AT#BvNeg6(a)) );

// ---------------------------------------------------------------
// -- Bit vector operations --------------------------------------
// ---------------------------------------------------------------
// Size: 12
function {:bvbuiltin "bvand"} AT#BvAnd12(a: bv12, b: bv12): bv12;
function {:bvbuiltin "bvor"} AT#BvOr12(a: bv12, b: bv12): bv12;
function {:bvbuiltin "bvnot"} AT#BvNot12(a: bv12): bv12;
function {:bvbuiltin "bvneg"} AT#BvNeg12(a: bv12): bv12;
function {:bvbuiltin "bvadd"} AT#BvAdd12(a: bv12, b: bv12): bv12;
function {:bvbuiltin "bvsub"} AT#BvSub12(a: bv12, b: bv12): bv12;
function {:bvbuiltin "bvmul"} AT#BvMul12(a: bv12, b: bv12): bv12;
function {:bvbuiltin "bvsdiv"} AT#BvSdiv12(a: bv12, b: bv12): bv12;
function {:bvbuiltin "bvudiv"} AT#BvUdiv12(a: bv12, b: bv12): bv12;
function {:bvbuiltin "bvshl"} AT#BvShl12(bv12,bv12): bv12;
function {:bvbuiltin "bvlshr"} AT#BvLshr12(bv12,bv12): bv12;
function {:bvbuiltin "bvashr"} AT#BvAshr12(bv12,bv12): bv12;
function {:bvbuiltin "bvule"} AT#BvUle12(a: bv12, b: bv12): bool;
function {:bvbuiltin "bvult"} AT#BvUlt12(a: bv12, b: bv12): bool;
function {:bvbuiltin "bvuge"} AT#BvUge12(a: bv12, b: bv12): bool;
function {:bvbuiltin "bvugt"} AT#BvUgt12(a: bv12, b: bv12): bool;
function {:bvbuiltin "bvsle"} AT#BvSle12(a: bv12, b: bv12): bool;
function {:bvbuiltin "bvslt"} AT#BvSlt12(a: bv12, b: bv12): bool;
function {:bvbuiltin "bvsge"} AT#BvSge12(a: bv12, b: bv12): bool;
function {:bvbuiltin "bvsgt"} AT#BvSgt12(a: bv12, b: bv12): bool;
function AT#BvXor12(a: bv12, b: bv12): bv12;
function AT#BvAbs12(a: bv12): bv12;

axiom (forall a,b: bv12 :: AT#BvXor12(a,b) == AT#BvAnd12(AT#BvOr12(a,b), AT#BvNot12(AT#BvAnd12(a,b))) );
axiom (forall a,b: bv12 :: AT#BvAbs12(a) == (if AT#BvSle12(0bv12,a) then a else AT#BvNeg12(a)) );

// ---------------------------------------------------------------
// -- Bit vector operations --------------------------------------
// ---------------------------------------------------------------
// Size: 7
function {:bvbuiltin "bvand"} AT#BvAnd7(a: bv7, b: bv7): bv7;
function {:bvbuiltin "bvor"} AT#BvOr7(a: bv7, b: bv7): bv7;
function {:bvbuiltin "bvnot"} AT#BvNot7(a: bv7): bv7;
function {:bvbuiltin "bvneg"} AT#BvNeg7(a: bv7): bv7;
function {:bvbuiltin "bvadd"} AT#BvAdd7(a: bv7, b: bv7): bv7;
function {:bvbuiltin "bvsub"} AT#BvSub7(a: bv7, b: bv7): bv7;
function {:bvbuiltin "bvmul"} AT#BvMul7(a: bv7, b: bv7): bv7;
function {:bvbuiltin "bvsdiv"} AT#BvSdiv7(a: bv7, b: bv7): bv7;
function {:bvbuiltin "bvudiv"} AT#BvUdiv7(a: bv7, b: bv7): bv7;
function {:bvbuiltin "bvshl"} AT#BvShl7(bv7,bv7): bv7;
function {:bvbuiltin "bvlshr"} AT#BvLshr7(bv7,bv7): bv7;
function {:bvbuiltin "bvashr"} AT#BvAshr7(bv7,bv7): bv7;
function {:bvbuiltin "bvule"} AT#BvUle7(a: bv7, b: bv7): bool;
function {:bvbuiltin "bvult"} AT#BvUlt7(a: bv7, b: bv7): bool;
function {:bvbuiltin "bvuge"} AT#BvUge7(a: bv7, b: bv7): bool;
function {:bvbuiltin "bvugt"} AT#BvUgt7(a: bv7, b: bv7): bool;
function {:bvbuiltin "bvsle"} AT#BvSle7(a: bv7, b: bv7): bool;
function {:bvbuiltin "bvslt"} AT#BvSlt7(a: bv7, b: bv7): bool;
function {:bvbuiltin "bvsge"} AT#BvSge7(a: bv7, b: bv7): bool;
function {:bvbuiltin "bvsgt"} AT#BvSgt7(a: bv7, b: bv7): bool;
function AT#BvXor7(a: bv7, b: bv7): bv7;
function AT#BvAbs7(a: bv7): bv7;

axiom (forall a,b: bv7 :: AT#BvXor7(a,b) == AT#BvAnd7(AT#BvOr7(a,b), AT#BvNot7(AT#BvAnd7(a,b))) );
axiom (forall a,b: bv7 :: AT#BvAbs7(a) == (if AT#BvSle7(0bv7,a) then a else AT#BvNeg7(a)) );

// ---------------------------------------------------------------
// -- Bit vector operations --------------------------------------
// ---------------------------------------------------------------
// Size: 4
function {:bvbuiltin "bvand"} AT#BvAnd4(a: bv4, b: bv4): bv4;
function {:bvbuiltin "bvor"} AT#BvOr4(a: bv4, b: bv4): bv4;
function {:bvbuiltin "bvnot"} AT#BvNot4(a: bv4): bv4;
function {:bvbuiltin "bvneg"} AT#BvNeg4(a: bv4): bv4;
function {:bvbuiltin "bvadd"} AT#BvAdd4(a: bv4, b: bv4): bv4;
function {:bvbuiltin "bvsub"} AT#BvSub4(a: bv4, b: bv4): bv4;
function {:bvbuiltin "bvmul"} AT#BvMul4(a: bv4, b: bv4): bv4;
function {:bvbuiltin "bvsdiv"} AT#BvSdiv4(a: bv4, b: bv4): bv4;
function {:bvbuiltin "bvudiv"} AT#BvUdiv4(a: bv4, b: bv4): bv4;
function {:bvbuiltin "bvshl"} AT#BvShl4(bv4,bv4): bv4;
function {:bvbuiltin "bvlshr"} AT#BvLshr4(bv4,bv4): bv4;
function {:bvbuiltin "bvashr"} AT#BvAshr4(bv4,bv4): bv4;
function {:bvbuiltin "bvule"} AT#BvUle4(a: bv4, b: bv4): bool;
function {:bvbuiltin "bvult"} AT#BvUlt4(a: bv4, b: bv4): bool;
function {:bvbuiltin "bvuge"} AT#BvUge4(a: bv4, b: bv4): bool;
function {:bvbuiltin "bvugt"} AT#BvUgt4(a: bv4, b: bv4): bool;
function {:bvbuiltin "bvsle"} AT#BvSle4(a: bv4, b: bv4): bool;
function {:bvbuiltin "bvslt"} AT#BvSlt4(a: bv4, b: bv4): bool;
function {:bvbuiltin "bvsge"} AT#BvSge4(a: bv4, b: bv4): bool;
function {:bvbuiltin "bvsgt"} AT#BvSgt4(a: bv4, b: bv4): bool;
function AT#BvXor4(a: bv4, b: bv4): bv4;
function AT#BvAbs4(a: bv4): bv4;

axiom (forall a,b: bv4 :: AT#BvXor4(a,b) == AT#BvAnd4(AT#BvOr4(a,b), AT#BvNot4(AT#BvAnd4(a,b))) );
axiom (forall a,b: bv4 :: AT#BvAbs4(a) == (if AT#BvSle4(0bv4,a) then a else AT#BvNeg4(a)) );

// ---------------------------------------------------------------
// -- Bit vector operations --------------------------------------
// ---------------------------------------------------------------
// Size: 32
function {:bvbuiltin "bvand"} AT#BvAnd32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvor"} AT#BvOr32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvnot"} AT#BvNot32(a: bv32): bv32;
function {:bvbuiltin "bvneg"} AT#BvNeg32(a: bv32): bv32;
function {:bvbuiltin "bvadd"} AT#BvAdd32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvsub"} AT#BvSub32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvmul"} AT#BvMul32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvsdiv"} AT#BvSdiv32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvudiv"} AT#BvUdiv32(a: bv32, b: bv32): bv32;
function {:bvbuiltin "bvshl"} AT#BvShl32(bv32,bv32): bv32;
function {:bvbuiltin "bvlshr"} AT#BvLshr32(bv32,bv32): bv32;
function {:bvbuiltin "bvashr"} AT#BvAshr32(bv32,bv32): bv32;
function {:bvbuiltin "bvule"} AT#BvUle32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvult"} AT#BvUlt32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvuge"} AT#BvUge32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvugt"} AT#BvUgt32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvsle"} AT#BvSle32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvslt"} AT#BvSlt32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvsge"} AT#BvSge32(a: bv32, b: bv32): bool;
function {:bvbuiltin "bvsgt"} AT#BvSgt32(a: bv32, b: bv32): bool;
function AT#BvXor32(a: bv32, b: bv32): bv32;
function AT#BvAbs32(a: bv32): bv32;

axiom (forall a,b: bv32 :: AT#BvXor32(a,b) == AT#BvAnd32(AT#BvOr32(a,b), AT#BvNot32(AT#BvAnd32(a,b))) );
axiom (forall a,b: bv32 :: AT#BvAbs32(a) == (if AT#BvSle32(0bv32,a) then a else AT#BvNeg32(a)) );

// ---------------------------------------------------------------
// -- Bit vector operations --------------------------------------
// ---------------------------------------------------------------
// Size: 3
function {:bvbuiltin "bvand"} AT#BvAnd3(a: bv3, b: bv3): bv3;
function {:bvbuiltin "bvor"} AT#BvOr3(a: bv3, b: bv3): bv3;
function {:bvbuiltin "bvnot"} AT#BvNot3(a: bv3): bv3;
function {:bvbuiltin "bvneg"} AT#BvNeg3(a: bv3): bv3;
function {:bvbuiltin "bvadd"} AT#BvAdd3(a: bv3, b: bv3): bv3;
function {:bvbuiltin "bvsub"} AT#BvSub3(a: bv3, b: bv3): bv3;
function {:bvbuiltin "bvmul"} AT#BvMul3(a: bv3, b: bv3): bv3;
function {:bvbuiltin "bvsdiv"} AT#BvSdiv3(a: bv3, b: bv3): bv3;
function {:bvbuiltin "bvudiv"} AT#BvUdiv3(a: bv3, b: bv3): bv3;
function {:bvbuiltin "bvshl"} AT#BvShl3(bv3,bv3): bv3;
function {:bvbuiltin "bvlshr"} AT#BvLshr3(bv3,bv3): bv3;
function {:bvbuiltin "bvashr"} AT#BvAshr3(bv3,bv3): bv3;
function {:bvbuiltin "bvule"} AT#BvUle3(a: bv3, b: bv3): bool;
function {:bvbuiltin "bvult"} AT#BvUlt3(a: bv3, b: bv3): bool;
function {:bvbuiltin "bvuge"} AT#BvUge3(a: bv3, b: bv3): bool;
function {:bvbuiltin "bvugt"} AT#BvUgt3(a: bv3, b: bv3): bool;
function {:bvbuiltin "bvsle"} AT#BvSle3(a: bv3, b: bv3): bool;
function {:bvbuiltin "bvslt"} AT#BvSlt3(a: bv3, b: bv3): bool;
function {:bvbuiltin "bvsge"} AT#BvSge3(a: bv3, b: bv3): bool;
function {:bvbuiltin "bvsgt"} AT#BvSgt3(a: bv3, b: bv3): bool;
function AT#BvXor3(a: bv3, b: bv3): bv3;
function AT#BvAbs3(a: bv3): bv3;

axiom (forall a,b: bv3 :: AT#BvXor3(a,b) == AT#BvAnd3(AT#BvOr3(a,b), AT#BvNot3(AT#BvAnd3(a,b))) );
axiom (forall a,b: bv3 :: AT#BvAbs3(a) == (if AT#BvSle3(0bv3,a) then a else AT#BvNeg3(a)) );

// ---------------------------------------------------------------
// -- End of prelude ---------------------------------------------
// ---------------------------------------------------------------

function Algo_DCRinvpred#saturate(x: bv13) returns (out: bv13);
function Algo_DCRinvpred#dc_scaler() returns (out: bv7);
procedure Algo_DCRinvpred#init#0()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (I#[BTYPE] == 0) && (R#[BTYPE] == 0) && (C#[BTYPE] == 0);
  assume (I#[A] == 0) && (R#[A] == 0) && (C#[A] == 0);
  assume (I#[B] == 0) && (R#[B] == 0) && (C#[B] == 0);
  assume (I#[C] == 0) && (R#[C] == 0) && (C#[C] == 0);
  assume (I#[QFS_DC] == 0) && (R#[QFS_DC] == 0) && (C#[QFS_DC] == 0);
  assume (I#[QP] == 0) && (R#[QP] == 0) && (C#[QP] == 0);
  assume (I#[QF_DC] == 0) && (R#[QF_DC] == 0) && (C#[QF_DC] == 0);
  assume (I#[PTR] == 0) && (R#[PTR] == 0) && (C#[PTR] == 0);
  assume (I#[AC_PRED_DIR] == 0) && (R#[AC_PRED_DIR] == 0) && (C#[AC_PRED_DIR] == 0);
  assume (I#[MODE] == 0) && (R#[MODE] == 0) && (C#[MODE] == 0);
  assume (I#[SIGNED] == 0) && (R#[SIGNED] == 0) && (C#[SIGNED] == 0);
  assume (I#[QUANT] == 0) && (R#[QUANT] == 0) && (C#[QUANT] == 0);
  comp := 0bv4;
  ptr := 8bv32;
}
procedure Algo_DCRinvpred#start#1()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  var QP#0: bv6;
  var C#0: bv11;
  var B#0: bv11;
  var BTYPE#0: bv12;
  var A#0: bv11;
  var QFS_DC#0: bv13;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (0 <= I#[BTYPE]) && (I#[BTYPE] <= R#[BTYPE]) && (R#[BTYPE] <= C#[BTYPE]);
  assume (0 <= I#[A]) && (I#[A] <= R#[A]) && (R#[A] <= C#[A]);
  assume (0 <= I#[B]) && (I#[B] <= R#[B]) && (R#[B] <= C#[B]);
  assume (0 <= I#[C]) && (I#[C] <= R#[C]) && (R#[C] <= C#[C]);
  assume (0 <= I#[QFS_DC]) && (I#[QFS_DC] <= R#[QFS_DC]) && (R#[QFS_DC] <= C#[QFS_DC]);
  assume (0 <= I#[QP]) && (I#[QP] <= R#[QP]) && (R#[QP] <= C#[QP]);
  assume (0 <= I#[QF_DC]) && (I#[QF_DC] <= R#[QF_DC]) && (R#[QF_DC] <= C#[QF_DC]);
  assume (0 <= I#[PTR]) && (I#[PTR] <= R#[PTR]) && (R#[PTR] <= C#[PTR]);
  assume (0 <= I#[AC_PRED_DIR]) && (I#[AC_PRED_DIR] <= R#[AC_PRED_DIR]) && (R#[AC_PRED_DIR] <= C#[AC_PRED_DIR]);
  assume (0 <= I#[MODE]) && (I#[MODE] <= R#[MODE]) && (R#[MODE] <= C#[MODE]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[QUANT]) && (I#[QUANT] <= R#[QUANT]) && (R#[QUANT] <= C#[QUANT]);
  assume 1 <= (C#[BTYPE] - R#[BTYPE]);
  BTYPE#0 := M#[BTYPE][R#[BTYPE]];
  R#[BTYPE] := R#[BTYPE] + 1;
  assume (AT#BvAnd12(BTYPE#0, NEWVOP) != 0bv12) && (St# == read);
  comp := 0bv4;
  ptr := 8bv32;
  if (St# == read) {
    St# := getw;
  }
  M#[AC_PRED_DIR][C#[AC_PRED_DIR]] := AT#BvNeg3(2bv3);
  C#[AC_PRED_DIR] := C#[AC_PRED_DIR] + 1;
}
procedure Algo_DCRinvpred#skip#2()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  var QP#0: bv6;
  var C#0: bv11;
  var B#0: bv11;
  var BTYPE#0: bv12;
  var A#0: bv11;
  var QFS_DC#0: bv13;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (0 <= I#[BTYPE]) && (I#[BTYPE] <= R#[BTYPE]) && (R#[BTYPE] <= C#[BTYPE]);
  assume (0 <= I#[A]) && (I#[A] <= R#[A]) && (R#[A] <= C#[A]);
  assume (0 <= I#[B]) && (I#[B] <= R#[B]) && (R#[B] <= C#[B]);
  assume (0 <= I#[C]) && (I#[C] <= R#[C]) && (R#[C] <= C#[C]);
  assume (0 <= I#[QFS_DC]) && (I#[QFS_DC] <= R#[QFS_DC]) && (R#[QFS_DC] <= C#[QFS_DC]);
  assume (0 <= I#[QP]) && (I#[QP] <= R#[QP]) && (R#[QP] <= C#[QP]);
  assume (0 <= I#[QF_DC]) && (I#[QF_DC] <= R#[QF_DC]) && (R#[QF_DC] <= C#[QF_DC]);
  assume (0 <= I#[PTR]) && (I#[PTR] <= R#[PTR]) && (R#[PTR] <= C#[PTR]);
  assume (0 <= I#[AC_PRED_DIR]) && (I#[AC_PRED_DIR] <= R#[AC_PRED_DIR]) && (R#[AC_PRED_DIR] <= C#[AC_PRED_DIR]);
  assume (0 <= I#[MODE]) && (I#[MODE] <= R#[MODE]) && (R#[MODE] <= C#[MODE]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[QUANT]) && (I#[QUANT] <= R#[QUANT]) && (R#[QUANT] <= C#[QUANT]);
  assume 1 <= (C#[BTYPE] - R#[BTYPE]);
  BTYPE#0 := M#[BTYPE][R#[BTYPE]];
  R#[BTYPE] := R#[BTYPE] + 1;
  assume (St# == getw) || (St# == geth);
  if (St# == getw) {
    St# := geth;
  } else {
    if (St# == geth) {
      St# := read;
    }
  }
}
procedure Algo_DCRinvpred#read.inter_ac#3()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  var QP#0: bv6;
  var C#0: bv11;
  var B#0: bv11;
  var BTYPE#0: bv12;
  var A#0: bv11;
  var QFS_DC#0: bv13;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (0 <= I#[BTYPE]) && (I#[BTYPE] <= R#[BTYPE]) && (R#[BTYPE] <= C#[BTYPE]);
  assume (0 <= I#[A]) && (I#[A] <= R#[A]) && (R#[A] <= C#[A]);
  assume (0 <= I#[B]) && (I#[B] <= R#[B]) && (R#[B] <= C#[B]);
  assume (0 <= I#[C]) && (I#[C] <= R#[C]) && (R#[C] <= C#[C]);
  assume (0 <= I#[QFS_DC]) && (I#[QFS_DC] <= R#[QFS_DC]) && (R#[QFS_DC] <= C#[QFS_DC]);
  assume (0 <= I#[QP]) && (I#[QP] <= R#[QP]) && (R#[QP] <= C#[QP]);
  assume (0 <= I#[QF_DC]) && (I#[QF_DC] <= R#[QF_DC]) && (R#[QF_DC] <= C#[QF_DC]);
  assume (0 <= I#[PTR]) && (I#[PTR] <= R#[PTR]) && (R#[PTR] <= C#[PTR]);
  assume (0 <= I#[AC_PRED_DIR]) && (I#[AC_PRED_DIR] <= R#[AC_PRED_DIR]) && (R#[AC_PRED_DIR] <= C#[AC_PRED_DIR]);
  assume (0 <= I#[MODE]) && (I#[MODE] <= R#[MODE]) && (R#[MODE] <= C#[MODE]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[QUANT]) && (I#[QUANT] <= R#[QUANT]) && (R#[QUANT] <= C#[QUANT]);
  assume (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP]));
  BTYPE#0 := M#[BTYPE][R#[BTYPE]];
  R#[BTYPE] := R#[BTYPE] + 1;
  QP#0 := M#[QP][R#[QP]];
  R#[QP] := R#[QP] + 1;
  assume !((AT#BvAnd12(BTYPE#0, NEWVOP) != 0bv12) && (St# == read));
  assume (AT#BvAnd12(BTYPE#0, INTER) != 0bv12) && (AT#BvAnd12(BTYPE#0, ACCODED) != 0bv12) && (St# == read);
  is_signed := true;
  s_QP := QP#0;
  round := AT#BvXor6(AT#BvAnd6(s_QP, 1bv6), 1bv6)[2:0];
  if (St# == read) {
    St# := inter;
  }
  M#[AC_PRED_DIR][C#[AC_PRED_DIR]] := 0bv3;
  C#[AC_PRED_DIR] := C#[AC_PRED_DIR] + 1;
  M#[MODE][C#[MODE]] := 0bv3;
  C#[MODE] := C#[MODE] + 1;
  M#[PTR][C#[PTR]] := 0bv11;
  C#[PTR] := C#[PTR] + 1;
  M#[SIGNED][C#[SIGNED]] := true;
  C#[SIGNED] := C#[SIGNED] + 1;
  M#[QUANT][C#[QUANT]] := s_QP;
  C#[QUANT] := C#[QUANT] + 1;
}
procedure Algo_DCRinvpred#read.other#4()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  var QP#0: bv6;
  var C#0: bv11;
  var B#0: bv11;
  var BTYPE#0: bv12;
  var A#0: bv11;
  var QFS_DC#0: bv13;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (0 <= I#[BTYPE]) && (I#[BTYPE] <= R#[BTYPE]) && (R#[BTYPE] <= C#[BTYPE]);
  assume (0 <= I#[A]) && (I#[A] <= R#[A]) && (R#[A] <= C#[A]);
  assume (0 <= I#[B]) && (I#[B] <= R#[B]) && (R#[B] <= C#[B]);
  assume (0 <= I#[C]) && (I#[C] <= R#[C]) && (R#[C] <= C#[C]);
  assume (0 <= I#[QFS_DC]) && (I#[QFS_DC] <= R#[QFS_DC]) && (R#[QFS_DC] <= C#[QFS_DC]);
  assume (0 <= I#[QP]) && (I#[QP] <= R#[QP]) && (R#[QP] <= C#[QP]);
  assume (0 <= I#[QF_DC]) && (I#[QF_DC] <= R#[QF_DC]) && (R#[QF_DC] <= C#[QF_DC]);
  assume (0 <= I#[PTR]) && (I#[PTR] <= R#[PTR]) && (R#[PTR] <= C#[PTR]);
  assume (0 <= I#[AC_PRED_DIR]) && (I#[AC_PRED_DIR] <= R#[AC_PRED_DIR]) && (R#[AC_PRED_DIR] <= C#[AC_PRED_DIR]);
  assume (0 <= I#[MODE]) && (I#[MODE] <= R#[MODE]) && (R#[MODE] <= C#[MODE]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[QUANT]) && (I#[QUANT] <= R#[QUANT]) && (R#[QUANT] <= C#[QUANT]);
  assume (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP]));
  BTYPE#0 := M#[BTYPE][R#[BTYPE]];
  R#[BTYPE] := R#[BTYPE] + 1;
  QP#0 := M#[QP][R#[QP]];
  R#[QP] := R#[QP] + 1;
  assume !((AT#BvAnd12(BTYPE#0, INTER) != 0bv12) && (AT#BvAnd12(BTYPE#0, ACCODED) != 0bv12) && (St# == read));
  assume !((AT#BvAnd12(BTYPE#0, NEWVOP) != 0bv12) && (St# == read));
  assume (AT#BvAnd12(BTYPE#0, INTRA) == 0bv12) && (AT#BvAnd12(BTYPE#0, ACCODED) == 0bv12) && (St# == read);
  s_QP := QP#0;
  if (St# == read) {
    St# := advance;
  }
  M#[AC_PRED_DIR][C#[AC_PRED_DIR]] := AT#BvNeg3(1bv3);
  C#[AC_PRED_DIR] := C#[AC_PRED_DIR] + 1;
}
procedure Algo_DCRinvpred#read.intra#5()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  var QP#0: bv6;
  var C#0: bv11;
  var B#0: bv11;
  var BTYPE#0: bv12;
  var A#0: bv11;
  var QFS_DC#0: bv13;
  var dca: bv13;
  var dcb: bv13;
  var dcc: bv13;
  var horiz: bv13;
  var vert: bv13;
  var top: bool;
  var s: bv3;
  var ac: bool;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (0 <= I#[BTYPE]) && (I#[BTYPE] <= R#[BTYPE]) && (R#[BTYPE] <= C#[BTYPE]);
  assume (0 <= I#[A]) && (I#[A] <= R#[A]) && (R#[A] <= C#[A]);
  assume (0 <= I#[B]) && (I#[B] <= R#[B]) && (R#[B] <= C#[B]);
  assume (0 <= I#[C]) && (I#[C] <= R#[C]) && (R#[C] <= C#[C]);
  assume (0 <= I#[QFS_DC]) && (I#[QFS_DC] <= R#[QFS_DC]) && (R#[QFS_DC] <= C#[QFS_DC]);
  assume (0 <= I#[QP]) && (I#[QP] <= R#[QP]) && (R#[QP] <= C#[QP]);
  assume (0 <= I#[QF_DC]) && (I#[QF_DC] <= R#[QF_DC]) && (R#[QF_DC] <= C#[QF_DC]);
  assume (0 <= I#[PTR]) && (I#[PTR] <= R#[PTR]) && (R#[PTR] <= C#[PTR]);
  assume (0 <= I#[AC_PRED_DIR]) && (I#[AC_PRED_DIR] <= R#[AC_PRED_DIR]) && (R#[AC_PRED_DIR] <= C#[AC_PRED_DIR]);
  assume (0 <= I#[MODE]) && (I#[MODE] <= R#[MODE]) && (R#[MODE] <= C#[MODE]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[QUANT]) && (I#[QUANT] <= R#[QUANT]) && (R#[QUANT] <= C#[QUANT]);
  assume (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (1 <= (C#[A] - R#[A])) && (1 <= (C#[B] - R#[B])) && (1 <= (C#[C] - R#[C]));
  BTYPE#0 := M#[BTYPE][R#[BTYPE]];
  R#[BTYPE] := R#[BTYPE] + 1;
  QP#0 := M#[QP][R#[QP]];
  R#[QP] := R#[QP] + 1;
  A#0 := M#[A][R#[A]];
  R#[A] := R#[A] + 1;
  B#0 := M#[B][R#[B]];
  R#[B] := R#[B] + 1;
  C#0 := M#[C][R#[C]];
  R#[C] := R#[C] + 1;
  assume !((AT#BvAnd12(BTYPE#0, INTRA) == 0bv12) && (AT#BvAnd12(BTYPE#0, ACCODED) == 0bv12) && (St# == read));
  assume !((AT#BvAnd12(BTYPE#0, INTER) != 0bv12) && (AT#BvAnd12(BTYPE#0, ACCODED) != 0bv12) && (St# == read));
  assume !((AT#BvAnd12(BTYPE#0, NEWVOP) != 0bv12) && (St# == read));
  assume St# == read;
  assume dca == Map#Select(dc_buf, 0bv21 ++ A#0);
  assume dcb == Map#Select(dc_buf, 0bv21 ++ B#0);
  assume dcc == Map#Select(dc_buf, 0bv21 ++ C#0);
  assume horiz == AT#BvAbs13(AT#BvSub13(dcb, dcc));
  assume vert == AT#BvAbs13(AT#BvSub13(dca, dcb));
  assume top == AT#BvSlt13(vert, horiz);
  assume ac == (AT#BvAnd12(BTYPE#0, ACPRED) != 0bv12);
  s_QP := QP#0;
  scaler := Algo_DCRinvpred#dc_scaler();
  dc_pred := AT#BvAdd13((if top then dcc else dca), 0bv6 ++ AT#BvSdiv7(AT#BvAshr7(scaler, 1bv7), scaler));
  s := (if !ac then 0bv3 else (if top then 2bv3 else 1bv3));
  is_signed := scaler == 0bv7;
  if (St# == read) {
    St# := intra;
  }
  M#[PTR][C#[PTR]] := (if top then C#0 else A#0);
  C#[PTR] := C#[PTR] + 1;
  M#[AC_PRED_DIR][C#[AC_PRED_DIR]] := s;
  C#[AC_PRED_DIR] := C#[AC_PRED_DIR] + 1;
  M#[MODE][C#[MODE]] := s;
  C#[MODE] := C#[MODE] + 1;
  M#[SIGNED][C#[SIGNED]] := is_signed;
  C#[SIGNED] := C#[SIGNED] + 1;
  M#[QUANT][C#[QUANT]] := s_QP;
  C#[QUANT] := C#[QUANT] + 1;
}
procedure Algo_DCRinvpred#getdc.inter#6()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  var QP#0: bv6;
  var C#0: bv11;
  var B#0: bv11;
  var BTYPE#0: bv12;
  var A#0: bv11;
  var QFS_DC#0: bv13;
  var v: bv13;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (0 <= I#[BTYPE]) && (I#[BTYPE] <= R#[BTYPE]) && (R#[BTYPE] <= C#[BTYPE]);
  assume (0 <= I#[A]) && (I#[A] <= R#[A]) && (R#[A] <= C#[A]);
  assume (0 <= I#[B]) && (I#[B] <= R#[B]) && (R#[B] <= C#[B]);
  assume (0 <= I#[C]) && (I#[C] <= R#[C]) && (R#[C] <= C#[C]);
  assume (0 <= I#[QFS_DC]) && (I#[QFS_DC] <= R#[QFS_DC]) && (R#[QFS_DC] <= C#[QFS_DC]);
  assume (0 <= I#[QP]) && (I#[QP] <= R#[QP]) && (R#[QP] <= C#[QP]);
  assume (0 <= I#[QF_DC]) && (I#[QF_DC] <= R#[QF_DC]) && (R#[QF_DC] <= C#[QF_DC]);
  assume (0 <= I#[PTR]) && (I#[PTR] <= R#[PTR]) && (R#[PTR] <= C#[PTR]);
  assume (0 <= I#[AC_PRED_DIR]) && (I#[AC_PRED_DIR] <= R#[AC_PRED_DIR]) && (R#[AC_PRED_DIR] <= C#[AC_PRED_DIR]);
  assume (0 <= I#[MODE]) && (I#[MODE] <= R#[MODE]) && (R#[MODE] <= C#[MODE]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[QUANT]) && (I#[QUANT] <= R#[QUANT]) && (R#[QUANT] <= C#[QUANT]);
  assume 1 <= (C#[QFS_DC] - R#[QFS_DC]);
  QFS_DC#0 := M#[QFS_DC][R#[QFS_DC]];
  R#[QFS_DC] := R#[QFS_DC] + 1;
  assume St# == inter;
  assume v == AT#BvSub13(AT#BvMul13(0bv7 ++ s_QP, AT#BvAdd13(AT#BvShl13(AT#BvAbs13(QFS_DC#0), 1bv13), 1bv13)), 0bv11 ++ round);
  dc_val := (if QFS_DC#0 == 0bv13 then 0bv13 else (if !is_signed then QFS_DC#0 else (if AT#BvSlt13(QFS_DC#0, 0bv13) then AT#BvNeg13(v) else v)));
  if (St# == inter) {
    St# := sat;
  }
}
procedure Algo_DCRinvpred#getdc.intra#7()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  var QP#0: bv6;
  var C#0: bv11;
  var B#0: bv11;
  var BTYPE#0: bv12;
  var A#0: bv11;
  var QFS_DC#0: bv13;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (0 <= I#[BTYPE]) && (I#[BTYPE] <= R#[BTYPE]) && (R#[BTYPE] <= C#[BTYPE]);
  assume (0 <= I#[A]) && (I#[A] <= R#[A]) && (R#[A] <= C#[A]);
  assume (0 <= I#[B]) && (I#[B] <= R#[B]) && (R#[B] <= C#[B]);
  assume (0 <= I#[C]) && (I#[C] <= R#[C]) && (R#[C] <= C#[C]);
  assume (0 <= I#[QFS_DC]) && (I#[QFS_DC] <= R#[QFS_DC]) && (R#[QFS_DC] <= C#[QFS_DC]);
  assume (0 <= I#[QP]) && (I#[QP] <= R#[QP]) && (R#[QP] <= C#[QP]);
  assume (0 <= I#[QF_DC]) && (I#[QF_DC] <= R#[QF_DC]) && (R#[QF_DC] <= C#[QF_DC]);
  assume (0 <= I#[PTR]) && (I#[PTR] <= R#[PTR]) && (R#[PTR] <= C#[PTR]);
  assume (0 <= I#[AC_PRED_DIR]) && (I#[AC_PRED_DIR] <= R#[AC_PRED_DIR]) && (R#[AC_PRED_DIR] <= C#[AC_PRED_DIR]);
  assume (0 <= I#[MODE]) && (I#[MODE] <= R#[MODE]) && (R#[MODE] <= C#[MODE]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[QUANT]) && (I#[QUANT] <= R#[QUANT]) && (R#[QUANT] <= C#[QUANT]);
  assume 1 <= (C#[QFS_DC] - R#[QFS_DC]);
  QFS_DC#0 := M#[QFS_DC][R#[QFS_DC]];
  R#[QFS_DC] := R#[QFS_DC] + 1;
  assume St# == intra;
  dc_val := AT#BvMul13(AT#BvAdd13(QFS_DC#0, dc_pred), 0bv6 ++ scaler);
  if (St# == intra) {
    St# := sat;
  }
}
procedure Algo_DCRinvpred#sat#8()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  var QP#0: bv6;
  var C#0: bv11;
  var B#0: bv11;
  var BTYPE#0: bv12;
  var A#0: bv11;
  var QFS_DC#0: bv13;
  var dc: bv13;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (0 <= I#[BTYPE]) && (I#[BTYPE] <= R#[BTYPE]) && (R#[BTYPE] <= C#[BTYPE]);
  assume (0 <= I#[A]) && (I#[A] <= R#[A]) && (R#[A] <= C#[A]);
  assume (0 <= I#[B]) && (I#[B] <= R#[B]) && (R#[B] <= C#[B]);
  assume (0 <= I#[C]) && (I#[C] <= R#[C]) && (R#[C] <= C#[C]);
  assume (0 <= I#[QFS_DC]) && (I#[QFS_DC] <= R#[QFS_DC]) && (R#[QFS_DC] <= C#[QFS_DC]);
  assume (0 <= I#[QP]) && (I#[QP] <= R#[QP]) && (R#[QP] <= C#[QP]);
  assume (0 <= I#[QF_DC]) && (I#[QF_DC] <= R#[QF_DC]) && (R#[QF_DC] <= C#[QF_DC]);
  assume (0 <= I#[PTR]) && (I#[PTR] <= R#[PTR]) && (R#[PTR] <= C#[PTR]);
  assume (0 <= I#[AC_PRED_DIR]) && (I#[AC_PRED_DIR] <= R#[AC_PRED_DIR]) && (R#[AC_PRED_DIR] <= C#[AC_PRED_DIR]);
  assume (0 <= I#[MODE]) && (I#[MODE] <= R#[MODE]) && (R#[MODE] <= C#[MODE]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[QUANT]) && (I#[QUANT] <= R#[QUANT]) && (R#[QUANT] <= C#[QUANT]);
  assume true;
  assume St# == sat;
  assume dc == Algo_DCRinvpred#saturate(dc_val);
  dc_buf := Map#Store(dc_buf, AT#BvOr32(ptr, 0bv28 ++ comp), dc);
  if (St# == sat) {
    St# := advance;
  }
  M#[QF_DC][C#[QF_DC]] := dc;
  C#[QF_DC] := C#[QF_DC] + 1;
}
procedure Algo_DCRinvpred#advance#9()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  var QP#0: bv6;
  var C#0: bv11;
  var B#0: bv11;
  var BTYPE#0: bv12;
  var A#0: bv11;
  var QFS_DC#0: bv13;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (0 <= I#[BTYPE]) && (I#[BTYPE] <= R#[BTYPE]) && (R#[BTYPE] <= C#[BTYPE]);
  assume (0 <= I#[A]) && (I#[A] <= R#[A]) && (R#[A] <= C#[A]);
  assume (0 <= I#[B]) && (I#[B] <= R#[B]) && (R#[B] <= C#[B]);
  assume (0 <= I#[C]) && (I#[C] <= R#[C]) && (R#[C] <= C#[C]);
  assume (0 <= I#[QFS_DC]) && (I#[QFS_DC] <= R#[QFS_DC]) && (R#[QFS_DC] <= C#[QFS_DC]);
  assume (0 <= I#[QP]) && (I#[QP] <= R#[QP]) && (R#[QP] <= C#[QP]);
  assume (0 <= I#[QF_DC]) && (I#[QF_DC] <= R#[QF_DC]) && (R#[QF_DC] <= C#[QF_DC]);
  assume (0 <= I#[PTR]) && (I#[PTR] <= R#[PTR]) && (R#[PTR] <= C#[PTR]);
  assume (0 <= I#[AC_PRED_DIR]) && (I#[AC_PRED_DIR] <= R#[AC_PRED_DIR]) && (R#[AC_PRED_DIR] <= C#[AC_PRED_DIR]);
  assume (0 <= I#[MODE]) && (I#[MODE] <= R#[MODE]) && (R#[MODE] <= C#[MODE]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[QUANT]) && (I#[QUANT] <= R#[QUANT]) && (R#[QUANT] <= C#[QUANT]);
  assume true;
  assume St# == advance;
  comp := AT#BvAdd4(comp, 1bv4);
  if (comp == 6bv4) {
    comp := 0bv4;
    ptr := (if ptr == 8bv32 then AT#BvSub32(BUF_SIZE, 8bv32) else AT#BvSub32(ptr, 8bv32));
  }
  if (St# == advance) {
    St# := read;
  }
}
procedure Algo_DCRinvpred##GuardWD#10()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var BTYPE: Chan (bv12);
  var A: Chan (bv11);
  var B: Chan (bv11);
  var C: Chan (bv11);
  var QFS_DC: Chan (bv13);
  var QP: Chan (bv6);
  var QF_DC: Chan (bv13);
  var PTR: Chan (bv11);
  var AC_PRED_DIR: Chan (bv3);
  var MODE: Chan (bv3);
  var SIGNED: Chan (bool);
  var QUANT: Chan (bv6);
  var St#: int;
  var sat: int;
  var geth: int;
  var advance: int;
  var intra: int;
  var inter: int;
  var getw: int;
  var read: int;
  var NEWVOP: bv12;
  var INTRA: bv12;
  var INTER: bv12;
  var MOTION: bv12;
  var ACCODED: bv12;
  var ACPRED: bv12;
  var s_QP: bv6;
  var round: bv2;
  var BUF_SIZE: bv32;
  var ptr: bv32;
  var comp: bv4;
  var dc_buf: Map (bv32) (bv13);
  var dc_pred: bv13;
  var scaler: bv7;
  var dc_val: bv13;
  var is_signed: bool;
  var BTYPE#0: bv12;
  var QFS_DC#0: bv13;
  var C#0: bv11;
  var B#0: bv11;
  var QP#0: bv6;
  var A#0: bv11;
  assume (A != B) && (A != C) && (A != PTR) && (B != C) && (B != PTR) && (C != PTR) && (QFS_DC != QF_DC) && (QP != QUANT) && (AC_PRED_DIR != MODE);
  assume sat == 6;
  assume geth == 5;
  assume advance == 4;
  assume intra == 3;
  assume inter == 2;
  assume getw == 1;
  assume read == 0;
  assume NEWVOP == 2048bv12;
  assume INTRA == 1024bv12;
  assume INTER == 512bv12;
  assume MOTION == 8bv12;
  assume ACCODED == 2bv12;
  assume ACPRED == 1bv12;
  assume BUF_SIZE == 984bv32;
  assume (0 <= I#[BTYPE]) && (I#[BTYPE] <= R#[BTYPE]) && (R#[BTYPE] <= C#[BTYPE]);
  assume (0 <= I#[A]) && (I#[A] <= R#[A]) && (R#[A] <= C#[A]);
  assume (0 <= I#[B]) && (I#[B] <= R#[B]) && (R#[B] <= C#[B]);
  assume (0 <= I#[C]) && (I#[C] <= R#[C]) && (R#[C] <= C#[C]);
  assume (0 <= I#[QFS_DC]) && (I#[QFS_DC] <= R#[QFS_DC]) && (R#[QFS_DC] <= C#[QFS_DC]);
  assume (0 <= I#[QP]) && (I#[QP] <= R#[QP]) && (R#[QP] <= C#[QP]);
  assume (0 <= I#[QF_DC]) && (I#[QF_DC] <= R#[QF_DC]) && (R#[QF_DC] <= C#[QF_DC]);
  assume (0 <= I#[PTR]) && (I#[PTR] <= R#[PTR]) && (R#[PTR] <= C#[PTR]);
  assume (0 <= I#[AC_PRED_DIR]) && (I#[AC_PRED_DIR] <= R#[AC_PRED_DIR]) && (R#[AC_PRED_DIR] <= C#[AC_PRED_DIR]);
  assume (0 <= I#[MODE]) && (I#[MODE] <= R#[MODE]) && (R#[MODE] <= C#[MODE]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[QUANT]) && (I#[QUANT] <= R#[QUANT]) && (R#[QUANT] <= C#[QUANT]);
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'skip' and 'getdc.intra' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#0)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && ((St# == getw) || (St# == geth)) && true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == intra));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'skip' and 'advance' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#1)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && ((St# == getw) || (St# == geth)) && true && true && (St# == advance));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'skip' and 'start' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#2)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && ((St# == getw) || (St# == geth)) && true && (1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'skip' and 'read.inter_ac' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#3)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && ((St# == getw) || (St# == geth)) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'skip' and 'read.other' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#4)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && ((St# == getw) || (St# == geth)) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'skip' and 'getdc.inter' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#5)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && ((St# == getw) || (St# == geth)) && true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == inter));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'skip' and 'read.intra' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#6)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && ((St# == getw) || (St# == geth)) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (1 <= (C#[A] - R#[A])) && (1 <= (C#[B] - R#[B])) && (1 <= (C#[C] - R#[C])) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'skip' and 'sat' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#7)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && ((St# == getw) || (St# == geth)) && true && true && (St# == sat));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'getdc.intra' and 'advance' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#8)"} !(true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == intra) && true && true && (St# == advance));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'getdc.intra' and 'start' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#9)"} !(true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == intra) && true && (1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'getdc.intra' and 'read.inter_ac' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#10)"} !(true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == intra) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'getdc.intra' and 'read.other' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#11)"} !(true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == intra) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'getdc.intra' and 'getdc.inter' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#12)"} !(true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == intra) && true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == inter));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'getdc.intra' and 'read.intra' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#13)"} !(true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == intra) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (1 <= (C#[A] - R#[A])) && (1 <= (C#[B] - R#[B])) && (1 <= (C#[C] - R#[C])) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'getdc.intra' and 'sat' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#14)"} !(true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == intra) && true && true && (St# == sat));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'advance' and 'start' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#15)"} !(true && true && (St# == advance) && true && (1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'advance' and 'read.inter_ac' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#16)"} !(true && true && (St# == advance) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'advance' and 'read.other' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#17)"} !(true && true && (St# == advance) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'advance' and 'getdc.inter' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#18)"} !(true && true && (St# == advance) && true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == inter));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'advance' and 'read.intra' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#19)"} !(true && true && (St# == advance) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (1 <= (C#[A] - R#[A])) && (1 <= (C#[B] - R#[B])) && (1 <= (C#[C] - R#[C])) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'advance' and 'sat' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#20)"} !(true && true && (St# == advance) && true && true && (St# == sat));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'start' and 'read.inter_ac' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#21)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'start' and 'read.other' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#22)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'start' and 'getdc.inter' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#23)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read) && true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == inter));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'start' and 'read.intra' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#24)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (1 <= (C#[A] - R#[A])) && (1 <= (C#[B] - R#[B])) && (1 <= (C#[C] - R#[C])) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'start' and 'sat' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#25)"} !(true && (1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read) && true && true && (St# == sat));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'read.inter_ac' and 'read.other' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#26)"} !(true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'read.inter_ac' and 'getdc.inter' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#27)"} !(true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read) && true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == inter));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'read.inter_ac' and 'read.intra' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#28)"} !(true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (1 <= (C#[A] - R#[A])) && (1 <= (C#[B] - R#[B])) && (1 <= (C#[C] - R#[C])) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'read.inter_ac' and 'sat' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#29)"} !(true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read) && true && true && (St# == sat));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'read.other' and 'getdc.inter' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#30)"} !(true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read) && true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == inter));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'read.other' and 'read.intra' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#31)"} !(true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (1 <= (C#[A] - R#[A])) && (1 <= (C#[B] - R#[B])) && (1 <= (C#[C] - R#[C])) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'read.other' and 'sat' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#32)"} !(true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read) && true && true && (St# == sat));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'getdc.inter' and 'read.intra' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#33)"} !(true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == inter) && true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (1 <= (C#[A] - R#[A])) && (1 <= (C#[B] - R#[B])) && (1 <= (C#[C] - R#[C])) && (St# == read));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'getdc.inter' and 'sat' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#34)"} !(true && (1 <= (C#[QFS_DC] - R#[QFS_DC])) && (St# == inter) && true && true && (St# == sat));
  assert {:msg "Algo_DCRinvpred.cal(2.1): The actions 'read.intra' and 'sat' of actor 'Algo_DCRinvpred' might not have mutually exclusive guards (#35)"} !(true && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTRA) == 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) == 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], INTER) != 0bv12) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], ACCODED) != 0bv12) && (St# == read))) && (!((1 <= (C#[BTYPE] - R#[BTYPE])) && (AT#BvAnd12(M#[BTYPE][R#[BTYPE]], NEWVOP) != 0bv12) && (St# == read))) && (1 <= (C#[BTYPE] - R#[BTYPE])) && (1 <= (C#[QP] - R#[QP])) && (1 <= (C#[A] - R#[A])) && (1 <= (C#[B] - R#[B])) && (1 <= (C#[C] - R#[C])) && (St# == read) && true && true && (St# == sat));
}
