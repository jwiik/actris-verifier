// Address.cal
//
// Author: David B. Parlour (dave.parlour@xilinx.com)
//
// Copyright (c) 2004-2005 Xilinx Inc.
// All Rights Reserved
//
// Disclaimer:  THIS PROGRAM IS PROVIDED "AS IS" WITH NO WARRANTY 
//              WHATSOEVER AND XILINX SPECIFICALLY DISCLAIMS ANY 
//              IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
//              A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.
// Frame buffer address generation for motion compensation

@merge
actor Mgnt_Address ()
	int(size=9) MV, 
	int(size=12) BTYPE 
	==> 
	int(size=24) RA,
	int(size=24) WA, 
	int(size=4) halfpel :


	NewVop: contract BTYPE:3 ==>
      guard (BTYPE[@] & NEWVOP) != int(0,12)
    end
	
	NoMotion: contract BTYPE:1 ==> WA:64
      guard (BTYPE[@] & NEWVOP) = int(0,12)
      guard (BTYPE[@] & INTRA) != int(0,12)
    end

    Motion: contract BTYPE:1, MV:2 ==> WA:64, RA:81, halfpel:1
      guard (BTYPE[@] & NEWVOP) = int(0,12)
      guard (BTYPE[@] & INTRA) = int(0,12)
      guard (BTYPE[@] & MOTION) != int(0,12)
    end
    
    Neither: contract BTYPE:1 ==> WA:64, RA:81, halfpel:1
      guard (BTYPE[@] & NEWVOP) = int(0,12)
      guard (BTYPE[@] & INTRA) = int(0,12)
      guard (BTYPE[@] & MOTION) = int(0,12)
    end
    
	// Frame buffer
	//  * sized for max width, max height + half the search window.
	//  * pixels are written/read ring-buffer fashion
	//  * write pointer leads by half the search window to prevent
	//    over-writing motion comp pixels from the last frame
	//  * luma, chroma_u, chroma_v components are separated
	//  * addressing is pixel-based [x + w * y]
	int(size=32) maxw_in_pixels = bvresize(MAXW_IN_MB,32) * int(16,32);

	int(size=32) maxh_in_pixels = bvresize(MAXH_IN_MB,32) * int(16,32);

	int(size=32) half_search_in_pixels = SEARCHWIN_IN_MB * int(8,32) + int(16,32);

	int(size=32) luma_pixel_offset = maxw_in_pixels * half_search_in_pixels;

	int(size=32) chroma_pixel_offset = luma_pixel_offset / int(4,32);

	int(size=32) max_luma_pixels = maxw_in_pixels * maxh_in_pixels + luma_pixel_offset;

	int(size=32) max_chroma_pixels = max_luma_pixels / int(4,32);

	int(size=32) luma_base = int(0,32);

	int(size=32) chroma_u_base = max_luma_pixels;

	int(size=32) chroma_v_base = chroma_u_base + max_chroma_pixels;

	// Pointers to the start of the ring buffers
	int(size=24) luma_write_ring_start := int(0,24);

	int(size=24) chroma_write_ring_start := int(0,24);

	int(size=24) luma_read_ring_start;

	int(size=24) chroma_read_ring_start;

	// Properties of the current VOP
	int(size=8) vop_width;

	int(size=8) vop_height;

	int(size=9) vop_luma_width;

	int(size=9) vop_luma_height;

	int(size=9) vop_chroma_width;

	int(size=9) vop_chroma_height;

	// Expected coordinates of the next macroblock in VOP
	int(size=9) next_mbx;

	int(size=9) next_mby;

	int(size=9) next_comp;

	int(size=24) next_luma_x;

	int(size=24) next_luma_y;

	int(size=24) next_chroma_x;

	int(size=24) next_chroma_y;

	// Set up for next vop - start reading from the prior write location.
	procedure advance_vop()
	begin
		vop_luma_width := (bvresize(vop_width,9) << int(4,9));
		vop_luma_height := (bvresize(vop_height,9) << int(4,9));
		vop_chroma_width := (bvresize(vop_width,9) << int(3,9));
		vop_chroma_height := (bvresize(vop_height,9) << int(3,9));
		// Read ring buffers now start from previous write location.
		// Move write location ahead by the offset value.
		luma_read_ring_start := luma_write_ring_start;
		luma_write_ring_start := bvresize(bvresize(luma_write_ring_start,32) - luma_pixel_offset,24);
		if luma_write_ring_start < int(0,24) then
			luma_write_ring_start := bvresize(bvresize(luma_write_ring_start,32) + max_luma_pixels, 24);
		end
		chroma_read_ring_start := chroma_write_ring_start;
		chroma_write_ring_start := bvresize(bvresize(chroma_write_ring_start,32) - chroma_pixel_offset,24);
		if chroma_write_ring_start < int(0,24) then
			chroma_write_ring_start := bvresize(bvresize(chroma_write_ring_start,32) + max_chroma_pixels,24);
		end
		next_mbx := int(0,9);
		next_mby := int(0,9);
		next_comp := int(0,9);
		next_luma_x := int(0,24);
		next_luma_y := int(0,24);
		next_chroma_x := int(0,24);
		next_chroma_y := int(0,24);
	end

	// Values used to form motion-compensation addresses
	int(size=8) read_count;

	int(size=5) read_row;

	int(size=5) read_col;

	int(size=8) write_count;

	int(size=24) current_w;

	int(size=24) current_h;

	int(size=24) current_size;

	int(size=24) current_base;

	int(size=24) current_read_ring_start;

	int(size=24) current_write_ring_start;

	int(size=24) current_x;

	int(size=24) current_y;

	// Move pointers to next block
	procedure advance_block()
	begin
	// Parameters for buffer addressing
		current_w := if next_comp < int(4,9) then
			bvresize(vop_luma_width,24)
		else
			bvresize(vop_chroma_width,24)
		end;
		current_h := if next_comp < int(4,9) then
			bvresize(vop_luma_height,24)
		else
			bvresize(vop_chroma_height,24)
		end;
		current_size := if next_comp < int(4,9) then
			bvresize(max_luma_pixels,24)
		else
			bvresize(max_chroma_pixels,24)
		end;
		current_x := if next_comp < int(4,9) then
			next_luma_x
		else
			next_chroma_x
		end;
		current_y := if next_comp < int(4,9) then
			next_luma_y
		else
			next_chroma_y
		end;
		current_read_ring_start := if next_comp < int(4,9) then
			luma_read_ring_start
		else
			chroma_read_ring_start
		end;
		current_write_ring_start := if next_comp < int(4,9) then
			luma_write_ring_start
		else
			chroma_write_ring_start
		end;
		current_base := if next_comp < int(4,9) then
			bvresize(luma_base,24)
		else
			if next_comp = int(4,9) then
				bvresize(chroma_u_base,24)
			else
				bvresize(chroma_v_base,24)
			end
		end;
		// Advance the MB coordinates
		// Note:    comp layout
		//      Y         U       V
		//  +---+---+   +---+   +---+
		//  | 0 | 1 |   | 4 |   | 5 |
		//  +---+---+   +---+   +---+
		//  | 2 | 3 | 
		//  +---+---+
		next_comp := next_comp + int(1,9);
		// Move right one block on 0->1 or 2->3 transition  
		if next_comp = int(1,9) or next_comp = int(3,9) then
			next_luma_x := next_luma_x + int(8,24);
		end
		// Move left and down one block on 1->2 transition
		// Note: 'down' is increasing y
		if next_comp = int(2,9) then
			next_luma_x := next_luma_x - int(8,24);
			next_luma_y := next_luma_y + int(8,24);
		end
		// When comp wraps, look for end of row
		if next_comp > int(5,9) then
			next_comp := int(0,9);
			next_mbx := next_mbx + int(1,9);
			// Move chroma x one block to right (value is used both by U and V)
			next_chroma_x := next_chroma_x + int(8,24);
			if next_mbx >= bvresize(vop_width,9) then
			// reset to start of line
				next_mbx := int(0,9);
				next_luma_x := int(0,24);
				next_chroma_x := int(0,24);
				// Move one block down - no handling for VOP height overflow.
				next_mby := next_mby + int(1,9);
				next_luma_y := next_luma_y + int(8,24);
				next_chroma_y := next_chroma_y + int(8,24);
			else
			// No line wrap, so move luma (x,y) up and right one block
				next_luma_x := next_luma_x + int(8,24);
				next_luma_y := next_luma_y - int(8,24);
			end
		end
	end

	// Buffer read address. Saturates (x,y) to the size (w,h) and wraps the pointer in either direction
	// (dx, dy) is an arbitrary offset from the upper left corner of the current block.
	function generate_read_addr(int(size=9) dx, int(size=9) dy) --> int(size=24)
	var
		int(size=24) x = current_x + bvresize(dx,24),
		int(size=24) x_sat = if x < int(0,24) then
			int(0,24)
		else
			if x >= current_w then
				(current_w - int(1,24))
			else
				x
			end
		end,
		int(size=24) y = current_y + bvresize(dy,24),
		int(size=24) y_sat = if y < int(0,24) then
			int(0,24)
		else
			if y >= current_h then
				(current_h - int(1,24))
			else
				y
			end
		end,
		int(size=24) i = current_read_ring_start + x_sat + y_sat * current_w,
		int(size=24) i_wrap = if i < int(0,24) then
			i + current_size
		else
			if i >= current_size then
				i - current_size
			else
				i
			end
		end :
		current_base + i_wrap
	end

	// Buffer write address. Does not saturate, only wraps the pointer at the top end
	// (dx, dy) are offsets from the upper left corner of the current block and must lie in the block
	function generate_write_addr(int(size=8) dx, int(size=8) dy) --> int(size=24)
	var
		int(size=24) x = current_x + bvresize(dx,24),
		int(size=24) y = current_y + bvresize(dy,24),
		int(size=24) i = current_write_ring_start + x + y * current_w,
		int(size=24) i_wrap = if i >= current_size then
			i - current_size
		else
			i
		end :
		current_base + i_wrap
	end

	bool round;

	cmd.newVop: action BTYPE:[ cmd ] ==>
	guard
		(cmd & NEWVOP) != int(0,12)
	do
		round := (cmd & ROUND_TYPE) != int(0,12);
	end
	
	getw: action BTYPE:[ w ] ==>
	do
		vop_width := bvresize(w,8);
	end
	
	geth: action BTYPE:[ h ] ==>
	do
		vop_height := bvresize(h,8);
		advance_vop();
	end

	// Pure texture
	cmd.noMotion: action BTYPE:[ cmd ] ==>
	guard
		(cmd & INTRA) != int(0,12)
	do
	// Disable motion comp addressing
		read_count := int(81,8);
		write_count := int(0,8);
	end

	int(size=9) mvx;

	int(size=9) mvy;

	bool interp_x;

	// Pure motion
	// Encode flags on halfpel: bit2 = interp. x
	//                          bit1 = interp. y
	//                          bit0 = round
	cmd.motion: action BTYPE:[ cmd ] ==>
	guard
		(cmd & MOTION) != int(0,12)
	end

	getmvx: action MV:[ x ] ==>
	do
		interp_x := (x & int(1,9)) = int(1,9);
		mvx := (x >> int(1,9));
	end

	getmvy: action MV:[ y ] ==> halfpel:[ if interp_x then
			int(4,4)
		else
			int(0,4)
		end + if interp_y then
			int(2,4)
		else
			int(0,4)
		end + if round then
			int(1,4)
		else
			int(0,4)
		end ]
	var
		bool interp_y = ((y & int(1,9)) = int(1,9))
	do
		mvy := (y >> int(1,9));
		read_count := int(0,8);
		read_row := int(0,5);
		read_col := int(0,5);
		write_count := int(0,8);
	end

	// No change in the block
	cmd.neither: action BTYPE:[ cmd ] ==> halfpel:[ int(0,4) ]
	do
		mvx := int(0,9);
		mvy := int(0,9);
		read_count := int(0,8);
		read_row := int(0,5);
		read_col := int(0,5);
		write_count := int(0,8);
	end

	// First set up the buffer pointers for the latest block
	init: action ==>
	do
		advance_block();
	end

	done: action ==>
	guard
		write_count = int(64,8) and read_count = int(81,8)
	end

	// Generate write addresses. Priorities are use to make this alternate
	// with the read address generation action (to keep the queues balanced).
	write_addr: action ==> WA:[ a ]
	guard
		write_count < int(64,8),
		write_count < read_count // this makes these two actions alternate

	var
		int(size=24) a = generate_write_addr((write_count & int(7,8)), (write_count >> int(3,8)))
	do
		write_count := write_count + int(1,8);
	end

	read_addr: action ==> RA:[ a ]
	guard
		read_count < int(81,8)
	var
		int(size=24) a = generate_read_addr(mvx + bvresize(read_col,9), mvy + bvresize(read_row,9))
	do
		read_count := read_count + int(1,8);
		read_col := read_col + int(1,5);
		if read_col >= int(9,5) then
			read_col := int(0,5);
			read_row := read_row + int(1,5);
		end
	end

	schedule fsm s_cmd :
		s_cmd ( cmd.newVop ) --> s_getw;
		s_cmd ( cmd.noMotion ) --> s_init;
		s_cmd ( cmd.motion ) --> getmvx;
		//    cmd          ( cmd.both        ) --> s_init;
		s_cmd ( cmd.neither ) --> s_init;
		s_init ( init ) --> generate;
		generate ( done ) --> s_cmd;
		generate ( write_addr ) --> generate;
		generate ( read_addr ) --> generate;
		s_getw ( getw ) --> s_geth;
		s_geth ( geth ) --> s_cmd;
		getmvx ( getmvx ) --> getmvy;
		getmvy ( getmvy ) --> s_init;
	end

	priority
		cmd.newVop > cmd.noMotion;
		cmd.newVop > cmd.motion;
		cmd.newVop > cmd.neither;
		cmd.noMotion > cmd.motion;
		cmd.noMotion > cmd.neither;
		cmd.motion > cmd.neither;
		done > write_addr;
		done > read_addr;
		write_addr > read_addr;
		
	end

end