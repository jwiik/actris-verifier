// ---------------------------------------------------------------
// -- Types and global variables ---------------------------------
// ---------------------------------------------------------------
type Ref;
type Chan a;
type Field a;
type Actor;
type CType = <a>[Chan a]int;
type MType = <a>[Chan a][int]a;
type Obj = <a>[Field a]a;
type HType = [Ref]Obj;
type ModeType = [Actor]int;

var M#: MType;
var C#: CType;
var R#: CType;
var I#: CType;
var B#: CType;
var Mode#: ModeType;
var I#sub: CType;

var H#: HType;

const unique this#: Actor;
function AT#Min(x:int, y: int): int { if x <= y then x else y }

// ---------------------------------------------------------------
// -- Axiomatisation for map data type ---------------------------
// ---------------------------------------------------------------
type Map a b;
function List#Empty<U>(U): Map int U;
function Map#Empty<T,U>(T, U): Map T U;
function Map#Select<T,U>(Map T U, T): U;
function Map#Store<T,U>(Map T U, T, U): Map T U;
axiom (
  forall<T,U> m: Map T U, k1: T, val: U :: { Map#Store(m,k1,val) }
    Map#Select(Map#Store(m,k1,val),k1) == val
);
axiom (
  forall<T,U> m: Map T U, k1: T, k2: T, val: U :: { Map#Select(Map#Store(m,k1,val),k2) }
    k1 != k2 ==> Map#Select(Map#Store(m,k1,val),k2) == Map#Select(m,k2)
);

// ---------------------------------------------------------------
// -- End of prelude ---------------------------------------------
// ---------------------------------------------------------------

function Algo_IDCT2D_ISOIEC_23002_1#pmul_1_1(X: bv32) returns (out: bv32);
function Algo_IDCT2D_ISOIEC_23002_1#pmul_1_2(X: bv32) returns (out: bv32);
function Algo_IDCT2D_ISOIEC_23002_1#pmul_2_1(X: bv32) returns (out: bv32);
function Algo_IDCT2D_ISOIEC_23002_1#pmul_2_2(X: bv32) returns (out: bv32);
function Algo_IDCT2D_ISOIEC_23002_1#pmul_3_1(X: bv32) returns (out: bv32);
function Algo_IDCT2D_ISOIEC_23002_1#pmul_3_2(X: bv32) returns (out: bv32);
function Algo_IDCT2D_ISOIEC_23002_1#clip(x: bv32, lim: bv32) returns (out: bv9);
procedure Algo_IDCT2D_ISOIEC_23002_1#anon__0()
  modifies C#, R#, M#, I#, H#, I#sub;
{
  var IN: Chan (bv13);
  var SIGNED: Chan (bool);
  var OUT: Chan (bv9);
  var A#ch: Chan (bv32);
  var B#ch: Chan (bv32);
  var C#ch: Chan (bv32);
  var D#ch: Chan (bv32);
  var E#ch: Chan (bv32);
  var F#ch: Chan (bv32);
  var G#ch: Chan (bv32);
  var H#ch: Chan (bv32);
  var I#ch: Chan (bv32);
  var J#ch: Chan (bv32);
  var scale#ch: Chan (Map (int) (bv32));
  var anon__0: int;
  var A: bv32;
  var B: bv32;
  var C: bv32;
  var D: bv32;
  var E: bv32;
  var F: bv32;
  var G: bv32;
  var H: bv32;
  var I: bv32;
  var J: bv32;
  var scale: Map (int) (bv32);
  var block1: Map (int) (bv32);
  var block2: Map (int) (bv32);
  var output: Map (int) (bv9);
  var idct1d#xb: bv32;
  var idct1d#temp2: bv32;
  var idct1d#xa: bv32;
  var idct1d#temp4: bv32;
  var idct1d#temp1: bv32;
  var idct1d#temp3: bv32;
  var i: int;
  var IN#0: Map (int) (bv13);
  var SIGNED#0: bool;
  assume (A#ch != B#ch) && (A#ch != C#ch) && (A#ch != D#ch) && (A#ch != E#ch) && (A#ch != F#ch) && (A#ch != G#ch) && (A#ch != H#ch) && (A#ch != I#ch) && (A#ch != J#ch) && (B#ch != C#ch) && (B#ch != D#ch) && (B#ch != E#ch) && (B#ch != F#ch) && (B#ch != G#ch) && (B#ch != H#ch) && (B#ch != I#ch) && (B#ch != J#ch) && (C#ch != D#ch) && (C#ch != E#ch) && (C#ch != F#ch) && (C#ch != G#ch) && (C#ch != H#ch) && (C#ch != I#ch) && (C#ch != J#ch) && (D#ch != E#ch) && (D#ch != F#ch) && (D#ch != G#ch) && (D#ch != H#ch) && (D#ch != I#ch) && (D#ch != J#ch) && (E#ch != F#ch) && (E#ch != G#ch) && (E#ch != H#ch) && (E#ch != I#ch) && (E#ch != J#ch) && (F#ch != G#ch) && (F#ch != H#ch) && (F#ch != I#ch) && (F#ch != J#ch) && (G#ch != H#ch) && (G#ch != I#ch) && (G#ch != J#ch) && (H#ch != I#ch) && (H#ch != J#ch) && (I#ch != J#ch);
  assume (0 <= I#[IN]) && (I#[IN] <= R#[IN]) && (R#[IN] <= C#[IN]);
  assume (0 <= I#[SIGNED]) && (I#[SIGNED] <= R#[SIGNED]) && (R#[SIGNED] <= C#[SIGNED]);
  assume (0 <= I#[OUT]) && (I#[OUT] <= R#[OUT]) && (R#[OUT] <= C#[OUT]);
  assume (0 <= I#[D#ch]) && (I#[D#ch] <= R#[D#ch]) && (R#[D#ch] <= C#[D#ch]);
  assume (0 <= I#[G#ch]) && (I#[G#ch] <= R#[G#ch]) && (R#[G#ch] <= C#[G#ch]);
  assume (0 <= I#[J#ch]) && (I#[J#ch] <= R#[J#ch]) && (R#[J#ch] <= C#[J#ch]);
  assume (0 <= I#[A#ch]) && (I#[A#ch] <= R#[A#ch]) && (R#[A#ch] <= C#[A#ch]);
  assume (0 <= I#[I#ch]) && (I#[I#ch] <= R#[I#ch]) && (R#[I#ch] <= C#[I#ch]);
  assume (0 <= I#[C#ch]) && (I#[C#ch] <= R#[C#ch]) && (R#[C#ch] <= C#[C#ch]);
  assume (0 <= I#[F#ch]) && (I#[F#ch] <= R#[F#ch]) && (R#[F#ch] <= C#[F#ch]);
  assume (0 <= I#[E#ch]) && (I#[E#ch] <= R#[E#ch]) && (R#[E#ch] <= C#[E#ch]);
  assume (0 <= I#[H#ch]) && (I#[H#ch] <= R#[H#ch]) && (R#[H#ch] <= C#[H#ch]);
  assume (0 <= I#[B#ch]) && (I#[B#ch] <= R#[B#ch]) && (R#[B#ch] <= C#[B#ch]);
  assume (0 <= I#[scale#ch]) && (I#[scale#ch] <= R#[scale#ch]) && (R#[scale#ch] <= C#[scale#ch]);
  assume anon__0 == 0;
  assume Mode#[this#] == anon__0;
  assume A == 1024bv32;
  assume B == 1138bv32;
  assume C == 1730bv32;
  assume D == 1609bv32;
  assume E == 1264bv32;
  assume F == 1922bv32;
  assume G == 1788bv32;
  assume H == 2923bv32;
  assume I == 2718bv32;
  assume J == 2528bv32;
  assume scale == Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(Map#Store(List#Empty(A), 0, A), 1, B), 2, C), 3, D), 4, A), 5, D), 6, C), 7, B), 8, B), 9, E), 10, F), 11, G), 12, B), 13, G), 14, F), 15, E), 16, C), 17, F), 18, H), 19, I), 20, C), 21, I), 22, H), 23, F), 24, D), 25, G), 26, I), 27, J), 28, D), 29, J), 30, I), 31, G), 32, A), 33, B), 34, C), 35, D), 36, A), 37, D), 38, C), 39, B), 40, D), 41, G), 42, I), 43, J), 44, D), 45, J), 46, I), 47, G), 48, C), 49, F), 50, H), 51, I), 52, C), 53, I), 54, H), 55, F), 56, B), 57, E), 58, F), 59, G), 60, B), 61, G), 62, F), 63, E);
  assume (I#[IN] == R#[IN]) && (R#[IN] == C#[IN]);
  assume (I#[SIGNED] == R#[SIGNED]) && (R#[SIGNED] == C#[SIGNED]);
  assume (I#[OUT] == R#[OUT]) && (R#[OUT] == C#[OUT]);
  assume Mode#[this#] == anon__0;
  assume R# == I#;
  assume (Mode#[this#] == anon__0) ==> ((C#[IN] - I#[IN]) <= 64) && ((C#[SIGNED] - I#[SIGNED]) <= 1);
  C#[IN] := C#[IN] + 64;
  C#[SIGNED] := C#[SIGNED] + 1;
  // Action: anon__6, Step: 0
  assert {:msg "Algo_IDCT2D_ISOIEC_23002_1.cal(38.9): Input pattern might not be satisfied for action 'anon__6' (#0)"} 64 <= (C#[IN] - R#[IN]);
  IN#0 := Map#Store(IN#0, 0, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 1, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 2, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 3, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 4, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 5, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 6, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 7, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 8, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 9, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 10, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 11, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 12, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 13, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 14, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 15, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 16, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 17, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 18, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 19, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 20, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 21, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 22, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 23, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 24, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 25, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 26, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 27, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 28, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 29, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 30, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 31, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 32, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 33, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 34, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 35, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 36, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 37, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 38, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 39, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 40, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 41, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 42, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 43, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 44, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 45, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 46, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 47, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 48, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 49, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 50, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 51, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 52, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 53, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 54, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 55, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 56, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 57, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 58, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 59, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 60, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 61, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 62, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  IN#0 := Map#Store(IN#0, 63, M#[IN][R#[IN]]);
  R#[IN] := R#[IN] + 1;
  assert {:msg "Algo_IDCT2D_ISOIEC_23002_1.cal(38.29): Input pattern might not be satisfied for action 'anon__6' (#1)"} 1 <= (C#[SIGNED] - R#[SIGNED]);
  SIGNED#0 := M#[SIGNED][R#[SIGNED]];
  R#[SIGNED] := R#[SIGNED] + 1;
  havoc block2;
  havoc idct1d#temp1;
  havoc block2;
  havoc i;
  havoc block2;
  havoc block1;
  havoc output;
  havoc block2;
  havoc idct1d#temp3;
  havoc block1;
  havoc block2;
  havoc block1;
  havoc block2;
  havoc block1;
  havoc block1;
  havoc block2;
  havoc block2;
  havoc block2;
  havoc block2;
  havoc block1;
  havoc idct1d#xb;
  havoc block1;
  havoc idct1d#xa;
  havoc block1;
  havoc block1;
  havoc idct1d#temp2;
  havoc block2;
  havoc block1;
  havoc block2;
  havoc block1;
  havoc block1;
  havoc block1;
  havoc idct1d#temp4;
  havoc block2;
  havoc block2;
  havoc block1;
  havoc block1;
  havoc block2;
  havoc block2;
  havoc block1;
  havoc block1;
  M#[OUT][C#[OUT]] := Map#Select(output, 0);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 1);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 2);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 3);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 4);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 5);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 6);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 7);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 8);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 9);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 10);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 11);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 12);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 13);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 14);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 15);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 16);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 17);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 18);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 19);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 20);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 21);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 22);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 23);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 24);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 25);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 26);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 27);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 28);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 29);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 30);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 31);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 32);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 33);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 34);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 35);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 36);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 37);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 38);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 39);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 40);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 41);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 42);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 43);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 44);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 45);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 46);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 47);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 48);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 49);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 50);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 51);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 52);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 53);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 54);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 55);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 56);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 57);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 58);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 59);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 60);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 61);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 62);
  C#[OUT] := C#[OUT] + 1;
  M#[OUT][C#[OUT]] := Map#Select(output, 63);
  C#[OUT] := C#[OUT] + 1;
  assume (Mode#[this#] == anon__0) ==> ((C#[IN] - I#[IN]) <= 64) && ((C#[SIGNED] - I#[SIGNED]) <= 1);
  assert {:msg "The correct amount of tokens might not be produced on output OUT (#2)"} (C#[OUT] - R#[OUT]) == 64;
}
