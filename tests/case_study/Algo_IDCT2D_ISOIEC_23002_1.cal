
@merge
actor Algo_IDCT2D_ISOIEC_23002_1()
	int(size=13) IN, bool SIGNED ==> int(size=9) OUT :
	
	//Main: contract IN:64, SIGNED:1 ==> OUT:64 end
	
	//action invariant tot(OUT) = rd(IN)
	//action invariant tot(OUT) = 64*rd(SIGNED)
	

	int(size=32) A = int(1024,32);

	int(size=32)  B = int(1138,32);

	int(size=32)  C = int(1730,32);

	int(size=32)  D = int(1609,32);

	int(size=32)  E = int(1264,32);

	int(size=32)  F = int(1922,32);

	int(size=32)  G = int(1788,32);

	int(size=32)  H = int(2923,32);

	int(size=32)  I = int(2718,32);

	int(size=32)  J = int(2528,32);

	List(type: int(size=32), size=64) scale = [
		A, B, C, D, A, D, C, B,
		B, E, F, G, B, G, F, E,
		C, F, H, I, C, I, H, F,
		D, G, I, J, D, J, I, G,
		A, B, C, D, A, D, C, B,
		D, G, I, J, D, J, I, G,
		C, F, H, I, C, I, H, F,
		B, E, F, G, B, G, F, E
	];

	idct: 
	action IN:[ x ] repeat 64, SIGNED:[ s ] ==> OUT:[ output ] repeat 64
	var
		int(size=32) block1[64] := [ scale[n] * bvresize(x[n],32) : for int n in 0 .. 63 ],
		int(size=32) block2[64],
		int(size=9) output[64]
	do
		// multiplier-based scaling
		block1[0] := block1[0] + (int(1,32) << int(12,32));

		// scaled 1D IDCT for rows and columns
		idct1d(block1, block2);
		idct1d(block2, block1);
		if s then
			output := [ clip((block1[n] >> int(13,32)), -int(255,32)) : for int n in 0 .. 63 ]
		else
			output := [ clip((block1[n] >>  int(13,32)), int(0,32)) : for int n in 0 .. 63 ]
		end
	end

	procedure idct1d(int(size=32) X[64], int(size=32) Y[64])
	var
		int(size=32) temp1,
		int(size=32) temp2,
		int(size=32) temp3,
		int(size=32) temp4,
		int(size=32) xa,
		int(size=32) xb
	begin
		foreach int i in 0 .. 7 do
			xa := X[8 * i + 1] + X[8 * i + 7];
			xb := X[8 * i + 1] - X[8 * i + 7];
			X[8 * i + 1] := xa + X[8 * i + 3];
			X[8 * i + 3] := xa - X[8 * i + 3];
			X[8 * i + 7] := xb + X[8 * i + 5];
			X[8 * i + 5] := xb - X[8 * i + 5];
			temp1 := pmul_1_1(X[8 * i + 3]);
			temp4 := pmul_1_2(X[8 * i + 3]);
			temp3 := pmul_1_1(X[8 * i + 5]);
			temp2 := pmul_1_2(X[8 * i + 5]);
			X[8 * i + 3] := temp1 - temp2;
			X[8 * i + 5] := temp3 + temp4;
			temp1 := pmul_2_1(X[8 * i + 1]);
			temp4 := pmul_2_2(X[8 * i + 1]);
			temp3 := pmul_2_1(X[8 * i + 7]);
			temp2 := pmul_2_2(X[8 * i + 7]);
			X[8 * i + 1] := temp1 + temp2;
			X[8 * i + 7] := temp3 - temp4;
			temp1 := pmul_3_1(X[8 * i + 2]);
			temp4 := pmul_3_2(X[8 * i + 2]);
			temp3 := pmul_3_1(X[8 * i + 6]);
			temp2 := pmul_3_2(X[8 * i + 6]);
			X[8 * i + 2] := temp1 - temp2;
			X[8 * i + 6] := temp3 + temp4;
			xa := X[8 * i + 0] + X[8 * i + 4];
			xb := X[8 * i + 0] - X[8 * i + 4];
			X[8 * i + 0] := xa + X[8 * i + 6];
			X[8 * i + 6] := xa - X[8 * i + 6];
			X[8 * i + 4] := xb + X[8 * i + 2];
			X[8 * i + 2] := xb - X[8 * i + 2];
			Y[i + 8 * 0] := X[8 * i + 0] + X[8 * i + 1];
			Y[i + 8 * 1] := X[8 * i + 4] + X[8 * i + 5];
			Y[i + 8 * 2] := X[8 * i + 2] + X[8 * i + 3];
			Y[i + 8 * 3] := X[8 * i + 6] + X[8 * i + 7];
			Y[i + 8 * 4] := X[8 * i + 6] - X[8 * i + 7];
			Y[i + 8 * 5] := X[8 * i + 2] - X[8 * i + 3];
			Y[i + 8 * 6] := X[8 * i + 4] - X[8 * i + 5];
			Y[i + 8 * 7] := X[8 * i + 0] - X[8 * i + 1];
		end
	end

	function pmul_1_1(int(size=32) X) --> int(size=32)
	:
		X - (X >> int(3,32)) - (X >> int(7,32))
	end

	function pmul_1_2(int(size=32) X) --> int(size=32)
	:
		((X >> int(3,32)) - (X >> int(7,32))) + ((((X >> int(3,32)) - (X >> int(7,32))) - (X >> int(11,32))) >> int(1,32))
	end

	function pmul_2_1(int(size=32) X) --> int(size=32)
	:
		(((X >> int(9,32)) - X) >> int(2,32)) - ((X >> int(9,32)) - X)
	end

	function pmul_2_2(int(size=32) X) --> int(size=32) :
		(X >> int(1,32))
	end

	function pmul_3_1(int(size=32) X) --> int(size=32)
	:
		((X + (X >> int(5,32))) >> int(2,32)) + (X >> int(4,32))
	end

	function pmul_3_2(int(size=32) X) --> int(size=32)
	:
		X + (X >> int(5,32)) - ((X + (X >> int(5,32))) >> int(2,32))
	end

	function clip(int(size=32) x, int(size=32) lim) --> int(size=9) :
		if x < lim then
			bvresize(lim,9)
		else
			if x > int(255,32) then
				int(255,9)
			else
				bvresize(x,9)
			end
		end
	end

end