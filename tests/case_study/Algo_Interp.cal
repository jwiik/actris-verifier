/*************************************************************************
* This software module was originally developed by David B. Parlour (Xilinx Inc.), 
* in the course of development of the ISO/IEC 23002-5 (Video Tool Library) 
* for reference purposes and its performance may not have been optimized. 
* This software module is an implementation of one or more tools as 
* specified by the ISO/IEC 23002-5.
* 
* ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
* license to copy, distribute, and make derivative works of this software 
* module or modifications thereof for use in implementations of the 
* ISO/IEC 23002-5 in products that satisfy conformance criteria (if any). 
* 
* Those intending to use this software module in products are advised that 
* its use may infringe existing patents. ISO/IEC have no liability for use 
* of this software module or modifications thereof.
* 
* Copyright is not released for products that do not conform to audiovisual 
* and image-coding related ITU Recommendations and/or ISO/IEC International 
* Standards. 
* 
* Assurance that the originally developed software module can be used 
* (1) in the ISO/IEC 23002-5 once the ISO/IEC 23002-5 has been adopted; and 
* (2) to develop the ISO/IEC 23002-5: 
* 
* Xilinx Inc.  grants ISO/IEC all rights necessary to 
* include the originally developed software module or modifications thereof 
* in the ISO/IEC 23002-5 and to permit ISO/IEC to offer You a royalty-free, 
* worldwide, non-exclusive, copyright license to copy, distribute, and make 
* derivative works for use in implementations of the ISO/IEC 23002-5 in 
* products that satisfy conformance criteria (if any), and to the extent 
* that such originally developed software module or portions of it are 
* included in the ISO/IEC 23002-5.  To the extent that Xilinx Inc. 
* owns patent rights that would be required to make, use, or 
* sell the originally developed software module or portions thereof 
* included in the ISO/IEC 23002-5 in a conforming product, Xilinx Inc.
* will assure the ISO/IEC that it is willing to 
* negotiate licenses under reasonable and non-discriminatory terms and 
* conditions with applicants throughout the world.
* 
* ISO/IEC gives You a free license to this software module or modifications 
* thereof for the sole  purpose of developing theISO/IEC 23002-5
* 
* Xilinx Inc. retains full right to modify and use the 
* code for its own purpose, assign or donate the code to a third party and 
* to inhibit third parties from using the code for products that do not 
* conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
* Standards. 
* 
* This copyright notice must be included in all copies or derivative works. 
* Copyright (c) ISO/IEC 2007-2011.
*************************************************************************/

/********************************************
*  Algo_Interp_HalfpelBilinearRoundingControl
*
* Author: David B. Parlour (dave.parlour@xilinx.com)
*
* Interpolation for motion compensation
*********************************/

actor Algo_Interp_HalfpelBilinearRoundingControl () 
	int(size=9) RD, 
	int(size=4) halfpel 
		==>
		int(size=9) MOT :
		
	Main: contract RD:81, halfpel:1 ==> MOT:17 end

	stream invariant rd@(halfpel) = 0 ==> state(start)

	// Compensation function
	function compensate(int(size=9) p00, int(size=9) p10, int(size=9) p01, int(size=9) p11) --> int(size=9) :
		if flags = int(0,3) then
			p00
		else
			if flags = int(1,3) then
			// interpolate y only
				((p00 + p01 + int(1,9)) - bvresize(round,9)) >> int(1,9)
			else
				if flags = int(2,3) then
				// interpolate x only
					((p00 + p10 + int(1,9)) - bvresize(round,9)) >> int(1,9)
				else
				// interpolate x and y
					((p00 + p10 + p01 + p11 + int(2,9)) - bvresize(round,9)) >> int(2,9)
				end
			end
		end
	end

	int(size=5) x;

	int(size=5) y;

	int(size=3) flags;

	int(size=2) round;

	start: action halfpel:[ f ] ==>
	ensures x = int(0,5) && y = int(0,5)
	do
		x := int(0,5);
		y := int(0,5);
		flags := bvresize(f >> int(1,4) , 3);
		round := bvresize(f & int(1,4) , 2);
	end

	done: action ==>
	guard
		y = int(9,5)
	end

	int(size=9) d0;

	int(size=9) d1;

	int(size=9) d2;

	int(size=9) d3;

	int(size=9) d4;

	int(size=9) d5;

	int(size=9) d6;

	int(size=9) d7;

	int(size=9) d8;

	int(size=9) d9;

	row_col_0: action RD:[ d ] ==>
	guard
		(x = int(0,5)) or (y = int(0,5))
	ensures prev(x) >= int(8,5) ==> y = prev(y)+int(1,5) && x = int(0,5)
	ensures prev(x) < int(8,5) ==> x = prev(x)+int(1,5) && y = prev(y) 
	do
		d9 := d8;
		d8 := d7;
		d7 := d6;
		d6 := d5;
		d5 := d4;
		d4 := d3;
		d3 := d2;
		d2 := d1;
		d1 := d0;
		d0 := d;
		x := x + int(1,5);
		if x >= int(9,5) then
			x := int(0,5);
			y := y + int(1,5);
		end
	end

	other: action RD:[ d ] ==> MOT:[ p ]
	guard
		(x != int(0,5)),
		(y != int(0,5)),
		y != int(9,5)
	ensures prev(x) >= int(8,5) ==> y = prev(y)+int(1,5) && x = int(0,5)
	ensures prev(x) < int(8,5) ==> x = prev(x)+int(1,5) && y = prev(y) 
	var
		int(size=9) p = compensate(d9, d8, d0, d)
	do
		d9 := d8;
		d8 := d7;
		d7 := d6;
		d6 := d5;
		d5 := d4;
		d4 := d3;
		d3 := d2;
		d2 := d1;
		d1 := d0;
		d0 := d;
		x := x + int(1,5);
		if x >= int(9,5) then
			x := int(0,5);
			y := y + int(1,5);
		end
	end

	schedule fsm start :
		start ( start ) --> interpolate;
		interpolate ( done ) --> start;
		interpolate ( row_col_0 ) --> interpolate;
		interpolate ( other ) --> interpolate;
	end

	priority
		done > row_col_0;
		done > other;
		row_col_0 > other;
	end

end