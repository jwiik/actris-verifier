@noinfer
actor Add int in1, int in2 ==> int out :
  stream invariant rd(in1) = tot(out) && rd(in2) = tot(out)
  stream invariant (forall int i :: every(out,i) ==> out[i] = in1[i]+in2[i])
  action in1:[i], in2:[j] ==> out:[i+j] end
end

@noinfer
actor Delay(int k) int in ==> int out :
  stream invariant rd(in) = tot(out)-1
  stream invariant out[0] = k
  stream invariant (forall int i :: every(out,i,1,0) ==> out[i] = in[i-1])
  initialize ==> out:[k] end
  action in:[i] ==> out:[i] end
end

@noinfer
actor Split int in ==> int out1, int out2 :
  stream invariant rd(in) = tot(out1) && rd(in) = tot(out2)
  stream invariant (forall int i :: every(out1,i) ==> out1[i] = in[i] && out2[i] = in[i])
  action in:[i] ==> out1:[i], out2:[i] end
end

network Net int in ==> int out :
  
  action in:1 ==> out:1
    requires 0 <= in[@]
    ensures out[0] = in[0]
    ensures @(out) > 0 ==> out[@] = out[@-1]+in[@]
  end
  
  invariant tokens(b,1)
  
  chinvariant @(a) = @(b) 
  chinvariant @(b) = @(c) 
  chinvariant @(c) = @(d)
  chinvariant @(d) = @(e)
  chinvariant @(c) > 0 ==> c[0] = a[0]
  chinvariant @(c) > 0 ==> c[@-1] = b[@]
  
  entities
    add = Add();
    del = Delay(0);
    spl = Split();
  end
  
  structure
    a: in --> add.in1;
    b: del.out --> add.in2;
    c: add.out --> spl.in;
    d: spl.out1 --> out;
    e: spl.out2 --> del.in;
  end

end