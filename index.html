<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Actris Verifier</title>

    <!-- Bootstrap -->
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="css/base.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <!-- Static navbar -->
      <nav class="navbar navbar-default">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">Actris</a>
          </div>
          <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
              <li><a href="#">Home</a></li>
              <li><a href="#publications">Publications</a></li>
              <li><a href="#download">Download</a></li>
              <li><a href="#instructions">Instructions</a></li>
              <li><a href="#credits">Credits</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div><!--/.container-fluid -->
      </nav>
      <div class="row">
        <div id="intro" class="col-sm-12">
          <h1>Actris <small>An automatic verifier for dynamic dataflow networks and actors</small></h1>
          <p>Actris is an automatic verifier for dynamic dataflow networks and actors. The verifier checks the networks and actors for functional correctness with respect to contracts. The language used to express actors is essentially a subset of the CAL Actor Language.</p>
          <p>Actris translates actors, networks and their contracts into code in the Boogie intermediate verification language. The Boogie verifier then carries out the rest of the proof by generating verification conditions that are discharged by the Z3 SMT solver.</p>
        </div>
      </div>
      
      <div class="row">
        <div id="example" class="col-sm-12">
          <h2>Example</h2>
          <p>As an example, consider the network illustrated below:</p>
          <img src="1.svg" />
          <p>It consists of the two actors <code>Add</code> and <code>Delay</code>. The source code of these actors is given below.</p>
          <figure class="highlight">
<pre><code class="language-html" data-lang="html"><span class="keyword">actor</span> Add <span class="keyword">int</span> in1, <span class="keyword">int</span> in2 ==> <span class="keyword">int</span> out1:
  <span class="keyword">action</span> in1:[i], in2:[j] ==> out1:[i+j] <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre></figure>
<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="keyword">actor</span> Delay(<span class="keyword">int</span> k) <span class="keyword">int</span> in1 ==> <span class="keyword">int</span> out1:
  <span class="keyword">initialize</span> ==> out1:[k] <span class="keyword">end</span>
  <span class="keyword">action</span> in1:[i] ==> out1:[i] <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre>
          </figure>
          <p>In Actris, also networks are described in a similar format to that of actors:</p>
          <figure class="highlight">
          <pre><code class="language-html" data-lang="html"><span class="keyword">network</span> SumNet <span class="keyword">int</span> in1 ==> <span class="keyword">int</span> out1:
  <span class="keyword">contract</span> in1:1 ==> out1:1
    <span class="keyword">requires</span> 0 &lt;= in1[@]
    <span class="keyword">ensures</span> out[@] >= in1[@]
    <span class="keyword">ensures</span> out[0] = in1[0]
    <span class="keyword">ensures</span> 0 &lt; @(out) ==> out[@] = out[@-1]+in1[@]
  <span class="keyword">end</span>  
  
  <span class="keyword">contract invariant</span> tokens(b,1)
  <span class="keyword">action invariant</span> b[0] = 0
  <span class="keyword">action invariant</span> 0 &lt;= b[@]
  
  <span class="keyword">entities</span>
    add = Add();
    del = Delay(0);
  <span class="keyword">end</span>  
  
  <span class="keyword">structure</span>
    a: in1 --> add.in1;
    b: del.out1 --> add.in2;
    c: add.out1 --> out1;
    d: add.out1 --> del.in1;
  <span class="keyword">end</span>  
<span class="keyword">end</span>  
</code></pre>
          </figure>
          <p>
            Here the contract specifies the intended behaviour of the network: The network takes one input token on the iport <code>in1</code>
            and outputs one token on the outport <code>out1</code>. For more details on what e.g. the <code>requires</code>, <code>ensures</code> and 
            <code>invariant</code> keywords mean, we refer to the papers mentioned below.
          </p>
          <p>
            Actris is able to automatically prove that the network satisfies its contract. It does so by translating the contracts, actors and 
            networks into input for the Boogie program verifier. The Boogie verifier then carries out the rest of the proof by generating
            proof obligations which are discharged using the Z3 SMT solver.
          </p>
        </div>
      </div>
      <div class="row">
        <div id="download" class="col-sm-12">
          <h2>Download</h2>
          <p>Actris is available open source at <a href="https://github.com/jwiik/actris-verifier">GitHub</a>. The latest version together as well as some working examples can be downloaded <a href="https://github.com/jwiik/actris-verifier/releases/latest">here</a>. The examples bundled with the distribution include e.g. digital filters, a ZigBee transmitter and a MPEG-4 decoder.</p>
        </div>
      </div>
      <div class="row">
        <div id="instructions" class="col-sm-12">
          <h2>Instructions</h2>
          <p> The tool is written in Scala and should be cross-platform. It has been tested on macOS 10.11, Ubuntu and Windows 7 and requires Java 7 or later. It also requires that the Boogie program verifier is available on the system <code>PATH</code>.</p>
          <p>The tool can be installed by running the command <code>make install</code> in the root folder of the distributable zip-file.</p>
          <p>
            To verify the example described above on a UNIX-based system, run the command, assuming that <code>actris</code> is available 
            on the path and that the actors and networks are saved in the files <code>Add.actor</code>, <code>Delay.actor</code> and <code>SumNet.actor</code>:
          </p>
          <p><code>actris Add.actor Delay.actor SumNet.actor</code></p>
          <p>On Windows systems, the <code>actris.bat</code> file can be used to run the tool.</p>
          <p>
            Starting from v1.0.0, Actris supports a new verification approach, based on finding static schedules for contracts.
            This can significantly reduce the number of invariant annotations needed for verification.
            To use this approach, Actris should be run with the <code>--schedule</code> parameter:
          </p>
          <p><code>actris --schedule:SumNet Add.actor Delay.actor SumNet.actor</code></p>
          <p>
            The scheduling backend depends on the SPIN model checker. Hence, SPIN should be available on the <code>PATH</code>. Additionally
            the scheduling backend also uses the Java API of the Z3 SMT solver as well as the <a href="https://github.com/epfl-lara/ScalaZ3">ScalaZ3</a> 
            binders.        
          </p>
        </div>
      </div>
      <div class="row">
        <div id="publications" class="col-sm-12">
          <h2>Publications</h2>
          <p>The principles behind the tool has been documented in the following publications:</p>
          <ul class="list-unstyled publications">
            <li>Wiik, Jonatan and Boström, Pontus. <a href="http://dx.doi.org/10.1007/978-3-319-66197-1_9">Specification and Automated Verification of Dynamic Dataflow Networks</a>. In: 15th International Conference on Software Engineering and Formal Methods, SEFM 2017, Lecture Notes in Computer Science, Springer, 2017.</li>
            <li>Wiik, Jonatan and Boström, Pontus. <a href="http://tucs.fi/publications/view/?pub_id=tWiBo16a">Specification and Automated Verification of Dynamic Dataflow Networks</a>. TUCS Technical Reports 1170, 2016.</li>
          </ul>
        </div>
      </div>

    </div>
  </body>
</html>
